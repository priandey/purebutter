create database purebutter
with owner postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.bool
is 'boolean, ''true''/''false''';

-- Unknown how to generate base type type

comment on type pg_catalog.bytea
is 'variable-length string, binary values escaped';

-- Unknown how to generate base type type

comment on type pg_catalog.char
is 'single character';

-- Unknown how to generate base type type

comment on type pg_catalog.name
is '63-byte type for storing system identifiers';

-- Unknown how to generate base type type

comment on type pg_catalog.int8
is '~18 digit integer, 8-byte storage';

-- Unknown how to generate base type type

comment on type pg_catalog.int2
is '-32 thousand to 32 thousand, 2-byte storage';

-- Unknown how to generate base type type

comment on type pg_catalog.int4
is '-2 billion to 2 billion integer, 4-byte storage';

-- Unknown how to generate base type type

comment on type pg_catalog.regproc
is 'registered procedure';

-- Unknown how to generate base type type

comment on type pg_catalog.text
is 'variable-length string, no limit specified';

-- Unknown how to generate base type type

comment on type pg_catalog.oid
is 'object identifier(oid), maximum 4 billion';

-- Unknown how to generate base type type

comment on type pg_catalog.tid
is '(block, offset), physical location of tuple';

-- Unknown how to generate base type type

comment on type pg_catalog.xid
is 'transaction id';

-- Unknown how to generate base type type

comment on type pg_catalog.cid
is 'command identifier type, sequence in transaction id';

-- Unknown how to generate base type type

-- Unknown how to generate base type type

comment on type pg_catalog.xml
is 'XML content';

-- Unknown how to generate base type type

comment on type pg_catalog.pg_node_tree
is 'string representing an internal node tree';

-- Unknown how to generate base type type

comment on type pg_catalog.smgr
is 'storage manager';

-- Unknown how to generate base type type

comment on type pg_catalog.point
is 'geometric point ''(x, y)''';

-- Unknown how to generate base type type

comment on type pg_catalog.lseg
is 'geometric line segment ''(pt1,pt2)''';

-- Unknown how to generate base type type

comment on type pg_catalog.path
is 'geometric path ''(pt1,...)''';

-- Unknown how to generate base type type

comment on type pg_catalog.box
is 'geometric box ''(lower left,upper right)''';

-- Unknown how to generate base type type

comment on type pg_catalog.polygon
is 'geometric polygon ''(pt1,...)''';

-- Unknown how to generate base type type

comment on type pg_catalog.line
is 'geometric line';

-- Unknown how to generate base type type

comment on type pg_catalog.cidr
is 'network IP address/netmask, network address';

-- Unknown how to generate base type type

comment on type pg_catalog.float4
is 'single-precision floating point number, 4-byte storage';

-- Unknown how to generate base type type

comment on type pg_catalog.float8
is 'double-precision floating point number, 8-byte storage';

-- Unknown how to generate base type type

comment on type pg_catalog.abstime
is 'absolute, limited-range date and time (Unix system time)';

-- Unknown how to generate base type type

comment on type pg_catalog.reltime
is 'relative, limited-range time interval (Unix delta time)';

-- Unknown how to generate base type type

comment on type pg_catalog.tinterval
is '(abstime,abstime), time interval';

-- Unknown how to generate base type type

comment on type pg_catalog.circle
is 'geometric circle ''(center,radius)''';

-- Unknown how to generate base type type

comment on type pg_catalog.macaddr8
is 'XX:XX:XX:XX:XX:XX:XX:XX, MAC address';

-- Unknown how to generate base type type

comment on type pg_catalog.money
is 'monetary amounts, $d,ddd.cc';

-- Unknown how to generate base type type

comment on type pg_catalog.macaddr
is 'XX:XX:XX:XX:XX:XX, MAC address';

-- Unknown how to generate base type type

comment on type pg_catalog.inet
is 'IP address/netmask, host address, netmask optional';

-- Unknown how to generate base type type

comment on type pg_catalog.aclitem
is 'access control list';

-- Unknown how to generate base type type

comment on type pg_catalog.bpchar
is 'char(length), blank-padded string, fixed storage length';

-- Unknown how to generate base type type

comment on type pg_catalog.varchar
is 'varchar(length), non-blank-padded string, variable storage length';

-- Unknown how to generate base type type

comment on type pg_catalog.date
is 'date';

-- Unknown how to generate base type type

comment on type pg_catalog.time
is 'time of day';

-- Unknown how to generate base type type

comment on type pg_catalog.timestamp
is 'date and time';

-- Unknown how to generate base type type

comment on type pg_catalog.timestamptz
is 'date and time with time zone';

-- Unknown how to generate base type type

comment on type pg_catalog.interval
is '@ <number> <units>, time interval';

-- Unknown how to generate base type type

comment on type pg_catalog.timetz
is 'time of day with time zone';

-- Unknown how to generate base type type

comment on type pg_catalog.bit
is 'fixed-length bit string';

-- Unknown how to generate base type type

comment on type pg_catalog.varbit
is 'variable-length bit string';

-- Unknown how to generate base type type

comment on type pg_catalog.numeric
is 'numeric(precision, decimal), arbitrary precision number';

-- Unknown how to generate base type type

comment on type pg_catalog.refcursor
is 'reference to cursor (portal name)';

-- Unknown how to generate base type type

comment on type pg_catalog.regprocedure
is 'registered procedure (with args)';

-- Unknown how to generate base type type

comment on type pg_catalog.regoper
is 'registered operator';

-- Unknown how to generate base type type

comment on type pg_catalog.regoperator
is 'registered operator (with args)';

-- Unknown how to generate base type type

comment on type pg_catalog.regclass
is 'registered class';

-- Unknown how to generate base type type

comment on type pg_catalog.regtype
is 'registered type';

-- Unknown how to generate base type type

comment on type pg_catalog.uuid
is 'UUID datatype';

-- Unknown how to generate base type type

comment on type pg_catalog.txid_snapshot
is 'txid snapshot';

-- Unknown how to generate base type type

comment on type pg_catalog.pg_lsn
is 'PostgreSQL LSN datatype';

-- Unknown how to generate base type type

comment on type pg_catalog.pg_ndistinct
is 'multivariate ndistinct coefficients';

-- Unknown how to generate base type type

comment on type pg_catalog.pg_dependencies
is 'multivariate dependencies';

-- Unknown how to generate base type type

comment on type pg_catalog.tsvector
is 'text representation for text search';

-- Unknown how to generate base type type

comment on type pg_catalog.tsquery
is 'query representation for text search';

-- Unknown how to generate base type type

comment on type pg_catalog.gtsvector
is 'GiST index internal text representation for text search';

-- Unknown how to generate base type type

comment on type pg_catalog.regconfig
is 'registered text search configuration';

-- Unknown how to generate base type type

comment on type pg_catalog.regdictionary
is 'registered text search dictionary';

-- Unknown how to generate base type type

comment on type pg_catalog.jsonb
is 'Binary JSON';

-- Unknown how to generate base type type

comment on type pg_catalog.regnamespace
is 'registered namespace';

-- Unknown how to generate base type type

comment on type pg_catalog.regrole
is 'registered role';

create domain information_schema.cardinal_number as integer
  constraint cardinal_number_domain_check check (VALUE >= 0);

create domain information_schema.character_data as varchar;

create domain information_schema.sql_identifier as varchar;

create domain information_schema.time_stamp as timestamp(2) with time zone
  default CURRENT_TIMESTAMP(2);

create domain information_schema.yes_or_no as varchar(3)
  constraint yes_or_no_check check ((VALUE) :: text = ANY
                                    ((ARRAY ['YES' :: character varying, 'NO' :: character varying]) :: text []));

create table if not exists pg_catalog.pg_default_acl
(
  defaclrole      oid    not null,
  defaclnamespace oid    not null,
  defaclobjtype   "char" not null,
  defaclacl       aclitem []
);

create unique index if not exists pg_default_acl_role_nsp_obj_index
  on pg_catalog.pg_default_acl (defaclrole, defaclnamespace, defaclobjtype);

create unique index if not exists pg_default_acl_oid_index
  on pg_catalog.pg_default_acl (oid);

create table if not exists pg_catalog.pg_pltemplate
(
  tmplname      name    not null,
  tmpltrusted   boolean not null,
  tmpldbacreate boolean not null,
  tmplhandler   text    not null,
  tmplinline    text,
  tmplvalidator text,
  tmpllibrary   text    not null,
  tmplacl       aclitem []
);

create unique index if not exists pg_pltemplate_name_index
  on pg_catalog.pg_pltemplate (tmplname);

create table if not exists pg_catalog.pg_tablespace
(
  spcname    name not null,
  spcowner   oid  not null,
  spcacl     aclitem [],
  spcoptions text []
);

create unique index if not exists pg_tablespace_oid_index
  on pg_catalog.pg_tablespace (oid);

create unique index if not exists pg_tablespace_spcname_index
  on pg_catalog.pg_tablespace (spcname);

create table if not exists pg_catalog.pg_shdepend
(
  dbid       oid     not null,
  classid    oid     not null,
  objid      oid     not null,
  objsubid   integer not null,
  refclassid oid     not null,
  refobjid   oid     not null,
  deptype    "char"  not null
);

create index if not exists pg_shdepend_depender_index
  on pg_catalog.pg_shdepend (dbid, classid, objid, objsubid);

create index if not exists pg_shdepend_reference_index
  on pg_catalog.pg_shdepend (refclassid, refobjid);

create table if not exists pg_catalog.pg_type
(
  typname        name     not null,
  typnamespace   oid      not null,
  typowner       oid      not null,
  typlen         smallint not null,
  typbyval       boolean  not null,
  typtype        "char"   not null,
  typcategory    "char"   not null,
  typispreferred boolean  not null,
  typisdefined   boolean  not null,
  typdelim       "char"   not null,
  typrelid       oid      not null,
  typelem        oid      not null,
  typarray       oid      not null,
  typinput       regproc  not null,
  typoutput      regproc  not null,
  typreceive     regproc  not null,
  typsend        regproc  not null,
  typmodin       regproc  not null,
  typmodout      regproc  not null,
  typanalyze     regproc  not null,
  typalign       "char"   not null,
  typstorage     "char"   not null,
  typnotnull     boolean  not null,
  typbasetype    oid      not null,
  typtypmod      integer  not null,
  typndims       integer  not null,
  typcollation   oid      not null,
  typdefaultbin  pg_node_tree,
  typdefault     text,
  typacl         aclitem []
);

create unique index if not exists pg_type_oid_index
  on pg_catalog.pg_type (oid);

create unique index if not exists pg_type_typname_nsp_index
  on pg_catalog.pg_type (typname, typnamespace);

create table if not exists pg_catalog.pg_attribute
(
  attrelid      oid      not null,
  attname       name     not null,
  atttypid      oid      not null,
  attstattarget integer  not null,
  attlen        smallint not null,
  attnum        smallint not null,
  attndims      integer  not null,
  attcacheoff   integer  not null,
  atttypmod     integer  not null,
  attbyval      boolean  not null,
  attstorage    "char"   not null,
  attalign      "char"   not null,
  attnotnull    boolean  not null,
  atthasdef     boolean  not null,
  atthasmissing boolean  not null,
  attidentity   "char"   not null,
  attisdropped  boolean  not null,
  attislocal    boolean  not null,
  attinhcount   integer  not null,
  attcollation  oid      not null,
  attacl        aclitem [],
  attoptions    text [],
  attfdwoptions text [],
  attmissingval anyarray
);

create unique index if not exists pg_attribute_relid_attnam_index
  on pg_catalog.pg_attribute (attrelid, attname);

create unique index if not exists pg_attribute_relid_attnum_index
  on pg_catalog.pg_attribute (attrelid, attnum);

create table if not exists pg_catalog.pg_proc
(
  proname         name      not null,
  pronamespace    oid       not null,
  proowner        oid       not null,
  prolang         oid       not null,
  procost         real      not null,
  prorows         real      not null,
  provariadic     oid       not null,
  protransform    regproc   not null,
  prokind         "char"    not null,
  prosecdef       boolean   not null,
  proleakproof    boolean   not null,
  proisstrict     boolean   not null,
  proretset       boolean   not null,
  provolatile     "char"    not null,
  proparallel     "char"    not null,
  pronargs        smallint  not null,
  pronargdefaults smallint  not null,
  prorettype      oid       not null,
  proargtypes     oidvector not null,
  proallargtypes  oid [],
  proargmodes     "char" [],
  proargnames     text [],
  proargdefaults  pg_node_tree,
  protrftypes     oid [],
  prosrc          text      not null,
  probin          text,
  proconfig       text [],
  proacl          aclitem []
);

create unique index if not exists pg_proc_oid_index
  on pg_catalog.pg_proc (oid);

create unique index if not exists pg_proc_proname_args_nsp_index
  on pg_catalog.pg_proc (proname, proargtypes, pronamespace);

create table if not exists pg_catalog.pg_class
(
  relname             name     not null,
  relnamespace        oid      not null,
  reltype             oid      not null,
  reloftype           oid      not null,
  relowner            oid      not null,
  relam               oid      not null,
  relfilenode         oid      not null,
  reltablespace       oid      not null,
  relpages            integer  not null,
  reltuples           real     not null,
  relallvisible       integer  not null,
  reltoastrelid       oid      not null,
  relhasindex         boolean  not null,
  relisshared         boolean  not null,
  relpersistence      "char"   not null,
  relkind             "char"   not null,
  relnatts            smallint not null,
  relchecks           smallint not null,
  relhasoids          boolean  not null,
  relhasrules         boolean  not null,
  relhastriggers      boolean  not null,
  relhassubclass      boolean  not null,
  relrowsecurity      boolean  not null,
  relforcerowsecurity boolean  not null,
  relispopulated      boolean  not null,
  relreplident        "char"   not null,
  relispartition      boolean  not null,
  relrewrite          oid      not null,
  relfrozenxid        xid      not null,
  relminmxid          xid      not null,
  relacl              aclitem [],
  reloptions          text [],
  relpartbound        pg_node_tree
);

create unique index if not exists pg_class_oid_index
  on pg_catalog.pg_class (oid);

create unique index if not exists pg_class_relname_nsp_index
  on pg_catalog.pg_class (relname, relnamespace);

create index if not exists pg_class_tblspc_relfilenode_index
  on pg_catalog.pg_class (reltablespace, relfilenode);

create table if not exists pg_catalog.pg_authid
(
  rolname        name    not null,
  rolsuper       boolean not null,
  rolinherit     boolean not null,
  rolcreaterole  boolean not null,
  rolcreatedb    boolean not null,
  rolcanlogin    boolean not null,
  rolreplication boolean not null,
  rolbypassrls   boolean not null,
  rolconnlimit   integer not null,
  rolpassword    text,
  rolvaliduntil  timestamp with time zone
);

create unique index if not exists pg_authid_rolname_index
  on pg_catalog.pg_authid (rolname);

create unique index if not exists pg_authid_oid_index
  on pg_catalog.pg_authid (oid);

create table if not exists pg_catalog.pg_auth_members
(
  roleid       oid     not null,
  member       oid     not null,
  grantor      oid     not null,
  admin_option boolean not null
);

create unique index if not exists pg_auth_members_role_member_index
  on pg_catalog.pg_auth_members (roleid, member);

create unique index if not exists pg_auth_members_member_role_index
  on pg_catalog.pg_auth_members (member, roleid);

create table if not exists pg_catalog.pg_database
(
  datname       name    not null,
  datdba        oid     not null,
  encoding      integer not null,
  datcollate    name    not null,
  datctype      name    not null,
  datistemplate boolean not null,
  datallowconn  boolean not null,
  datconnlimit  integer not null,
  datlastsysoid oid     not null,
  datfrozenxid  xid     not null,
  datminmxid    xid     not null,
  dattablespace oid     not null,
  datacl        aclitem []
);

create unique index if not exists pg_database_datname_index
  on pg_catalog.pg_database (datname);

create unique index if not exists pg_database_oid_index
  on pg_catalog.pg_database (oid);

create table if not exists pg_catalog.pg_foreign_server
(
  srvname    name not null,
  srvowner   oid  not null,
  srvfdw     oid  not null,
  srvtype    text,
  srvversion text,
  srvacl     aclitem [],
  srvoptions text []
);

create unique index if not exists pg_foreign_server_oid_index
  on pg_catalog.pg_foreign_server (oid);

create unique index if not exists pg_foreign_server_name_index
  on pg_catalog.pg_foreign_server (srvname);

create table if not exists pg_catalog.pg_user_mapping
(
  umuser    oid not null,
  umserver  oid not null,
  umoptions text []
);

create unique index if not exists pg_user_mapping_oid_index
  on pg_catalog.pg_user_mapping (oid);

create unique index if not exists pg_user_mapping_user_server_index
  on pg_catalog.pg_user_mapping (umuser, umserver);

create table if not exists pg_catalog.pg_sequence
(
  seqrelid     oid     not null,
  seqtypid     oid     not null,
  seqstart     bigint  not null,
  seqincrement bigint  not null,
  seqmax       bigint  not null,
  seqmin       bigint  not null,
  seqcache     bigint  not null,
  seqcycle     boolean not null
);

create unique index if not exists pg_sequence_seqrelid_index
  on pg_catalog.pg_sequence (seqrelid);

create table if not exists pg_catalog.pg_foreign_data_wrapper
(
  fdwname      name not null,
  fdwowner     oid  not null,
  fdwhandler   oid  not null,
  fdwvalidator oid  not null,
  fdwacl       aclitem [],
  fdwoptions   text []
);

create unique index if not exists pg_foreign_data_wrapper_oid_index
  on pg_catalog.pg_foreign_data_wrapper (oid);

create unique index if not exists pg_foreign_data_wrapper_name_index
  on pg_catalog.pg_foreign_data_wrapper (fdwname);

create table if not exists pg_catalog.pg_shdescription
(
  objoid      oid  not null,
  classoid    oid  not null,
  description text not null
);

create unique index if not exists pg_shdescription_o_c_index
  on pg_catalog.pg_shdescription (objoid, classoid);

create table if not exists pg_catalog.pg_aggregate
(
  aggfnoid         regproc  not null,
  aggkind          "char"   not null,
  aggnumdirectargs smallint not null,
  aggtransfn       regproc  not null,
  aggfinalfn       regproc  not null,
  aggcombinefn     regproc  not null,
  aggserialfn      regproc  not null,
  aggdeserialfn    regproc  not null,
  aggmtransfn      regproc  not null,
  aggminvtransfn   regproc  not null,
  aggmfinalfn      regproc  not null,
  aggfinalextra    boolean  not null,
  aggmfinalextra   boolean  not null,
  aggfinalmodify   "char"   not null,
  aggmfinalmodify  "char"   not null,
  aggsortop        oid      not null,
  aggtranstype     oid      not null,
  aggtransspace    integer  not null,
  aggmtranstype    oid      not null,
  aggmtransspace   integer  not null,
  agginitval       text,
  aggminitval      text
);

create unique index if not exists pg_aggregate_fnoid_index
  on pg_catalog.pg_aggregate (aggfnoid);

create table if not exists pg_catalog.pg_am
(
  amname    name    not null,
  amhandler regproc not null,
  amtype    "char"  not null
);

create unique index if not exists pg_am_name_index
  on pg_catalog.pg_am (amname);

create unique index if not exists pg_am_oid_index
  on pg_catalog.pg_am (oid);

create table if not exists pg_catalog.pg_amop
(
  amopfamily     oid      not null,
  amoplefttype   oid      not null,
  amoprighttype  oid      not null,
  amopstrategy   smallint not null,
  amoppurpose    "char"   not null,
  amopopr        oid      not null,
  amopmethod     oid      not null,
  amopsortfamily oid      not null
);

create unique index if not exists pg_amop_fam_strat_index
  on pg_catalog.pg_amop (amopfamily, amoplefttype, amoprighttype, amopstrategy);

create unique index if not exists pg_amop_opr_fam_index
  on pg_catalog.pg_amop (amopopr, amoppurpose, amopfamily);

create unique index if not exists pg_amop_oid_index
  on pg_catalog.pg_amop (oid);

create table if not exists pg_catalog.pg_amproc
(
  amprocfamily    oid      not null,
  amproclefttype  oid      not null,
  amprocrighttype oid      not null,
  amprocnum       smallint not null,
  amproc          regproc  not null
);

create unique index if not exists pg_amproc_fam_proc_index
  on pg_catalog.pg_amproc (amprocfamily, amproclefttype, amprocrighttype, amprocnum);

create unique index if not exists pg_amproc_oid_index
  on pg_catalog.pg_amproc (oid);

create table if not exists pg_catalog.pg_attrdef
(
  adrelid oid      not null,
  adnum   smallint not null,
  adbin   pg_node_tree,
  adsrc   text
);

create unique index if not exists pg_attrdef_adrelid_adnum_index
  on pg_catalog.pg_attrdef (adrelid, adnum);

create unique index if not exists pg_attrdef_oid_index
  on pg_catalog.pg_attrdef (oid);

create table if not exists pg_catalog.pg_cast
(
  castsource  oid    not null,
  casttarget  oid    not null,
  castfunc    oid    not null,
  castcontext "char" not null,
  castmethod  "char" not null
);

create unique index if not exists pg_cast_oid_index
  on pg_catalog.pg_cast (oid);

create unique index if not exists pg_cast_source_target_index
  on pg_catalog.pg_cast (castsource, casttarget);

create table if not exists pg_catalog.pg_constraint
(
  conname       name    not null,
  connamespace  oid     not null,
  contype       "char"  not null,
  condeferrable boolean not null,
  condeferred   boolean not null,
  convalidated  boolean not null,
  conrelid      oid     not null,
  contypid      oid     not null,
  conindid      oid     not null,
  conparentid   oid     not null,
  confrelid     oid     not null,
  confupdtype   "char"  not null,
  confdeltype   "char"  not null,
  confmatchtype "char"  not null,
  conislocal    boolean not null,
  coninhcount   integer not null,
  connoinherit  boolean not null,
  conkey        smallint [],
  confkey       smallint [],
  conpfeqop     oid [],
  conppeqop     oid [],
  conffeqop     oid [],
  conexclop     oid [],
  conbin        pg_node_tree,
  consrc        text
);

create index if not exists pg_constraint_conparentid_index
  on pg_catalog.pg_constraint (conparentid);

create index if not exists pg_constraint_conname_nsp_index
  on pg_catalog.pg_constraint (conname, connamespace);

create unique index if not exists pg_constraint_conrelid_contypid_conname_index
  on pg_catalog.pg_constraint (conrelid, contypid, conname);

create index if not exists pg_constraint_contypid_index
  on pg_catalog.pg_constraint (contypid);

create unique index if not exists pg_constraint_oid_index
  on pg_catalog.pg_constraint (oid);

create table if not exists pg_catalog.pg_conversion
(
  conname        name    not null,
  connamespace   oid     not null,
  conowner       oid     not null,
  conforencoding integer not null,
  contoencoding  integer not null,
  conproc        regproc not null,
  condefault     boolean not null
);

create unique index if not exists pg_conversion_default_index
  on pg_catalog.pg_conversion (connamespace, conforencoding, contoencoding, oid);

create unique index if not exists pg_conversion_name_nsp_index
  on pg_catalog.pg_conversion (conname, connamespace);

create unique index if not exists pg_conversion_oid_index
  on pg_catalog.pg_conversion (oid);

create table if not exists pg_catalog.pg_depend
(
  classid     oid     not null,
  objid       oid     not null,
  objsubid    integer not null,
  refclassid  oid     not null,
  refobjid    oid     not null,
  refobjsubid integer not null,
  deptype     "char"  not null
);

create index if not exists pg_depend_depender_index
  on pg_catalog.pg_depend (classid, objid, objsubid);

create index if not exists pg_depend_reference_index
  on pg_catalog.pg_depend (refclassid, refobjid, refobjsubid);

create table if not exists pg_catalog.pg_description
(
  objoid      oid     not null,
  classoid    oid     not null,
  objsubid    integer not null,
  description text    not null
);

create unique index if not exists pg_description_o_c_o_index
  on pg_catalog.pg_description (objoid, classoid, objsubid);

create table if not exists pg_catalog.pg_index
(
  indexrelid     oid        not null,
  indrelid       oid        not null,
  indnatts       smallint   not null,
  indnkeyatts    smallint   not null,
  indisunique    boolean    not null,
  indisprimary   boolean    not null,
  indisexclusion boolean    not null,
  indimmediate   boolean    not null,
  indisclustered boolean    not null,
  indisvalid     boolean    not null,
  indcheckxmin   boolean    not null,
  indisready     boolean    not null,
  indislive      boolean    not null,
  indisreplident boolean    not null,
  indkey         int2vector not null,
  indcollation   oidvector  not null,
  indclass       oidvector  not null,
  indoption      int2vector not null,
  indexprs       pg_node_tree,
  indpred        pg_node_tree
);

create index if not exists pg_index_indrelid_index
  on pg_catalog.pg_index (indrelid);

create unique index if not exists pg_index_indexrelid_index
  on pg_catalog.pg_index (indexrelid);

create table if not exists pg_catalog.pg_inherits
(
  inhrelid  oid     not null,
  inhparent oid     not null,
  inhseqno  integer not null
);

create index if not exists pg_inherits_parent_index
  on pg_catalog.pg_inherits (inhparent);

create unique index if not exists pg_inherits_relid_seqno_index
  on pg_catalog.pg_inherits (inhrelid, inhseqno);

create table if not exists pg_catalog.pg_language
(
  lanname       name    not null,
  lanowner      oid     not null,
  lanispl       boolean not null,
  lanpltrusted  boolean not null,
  lanplcallfoid oid     not null,
  laninline     oid     not null,
  lanvalidator  oid     not null,
  lanacl        aclitem []
);

create unique index if not exists pg_language_name_index
  on pg_catalog.pg_language (lanname);

create unique index if not exists pg_language_oid_index
  on pg_catalog.pg_language (oid);

create table if not exists pg_catalog.pg_largeobject
(
  loid   oid     not null,
  pageno integer not null,
  data   bytea   not null
);

create unique index if not exists pg_largeobject_loid_pn_index
  on pg_catalog.pg_largeobject (loid, pageno);

create table if not exists pg_catalog.pg_namespace
(
  nspname  name not null,
  nspowner oid  not null,
  nspacl   aclitem []
);

create unique index if not exists pg_namespace_nspname_index
  on pg_catalog.pg_namespace (nspname);

create unique index if not exists pg_namespace_oid_index
  on pg_catalog.pg_namespace (oid);

create table if not exists pg_catalog.pg_opclass
(
  opcmethod    oid     not null,
  opcname      name    not null,
  opcnamespace oid     not null,
  opcowner     oid     not null,
  opcfamily    oid     not null,
  opcintype    oid     not null,
  opcdefault   boolean not null,
  opckeytype   oid     not null
);

create unique index if not exists pg_opclass_am_name_nsp_index
  on pg_catalog.pg_opclass (opcmethod, opcname, opcnamespace);

create unique index if not exists pg_opclass_oid_index
  on pg_catalog.pg_opclass (oid);

create table if not exists pg_catalog.pg_operator
(
  oprname      name    not null,
  oprnamespace oid     not null,
  oprowner     oid     not null,
  oprkind      "char"  not null,
  oprcanmerge  boolean not null,
  oprcanhash   boolean not null,
  oprleft      oid     not null,
  oprright     oid     not null,
  oprresult    oid     not null,
  oprcom       oid     not null,
  oprnegate    oid     not null,
  oprcode      regproc not null,
  oprrest      regproc not null,
  oprjoin      regproc not null
);

create unique index if not exists pg_operator_oid_index
  on pg_catalog.pg_operator (oid);

create unique index if not exists pg_operator_oprname_l_r_n_index
  on pg_catalog.pg_operator (oprname, oprleft, oprright, oprnamespace);

create table if not exists pg_catalog.pg_rewrite
(
  rulename   name    not null,
  ev_class   oid     not null,
  ev_type    "char"  not null,
  ev_enabled "char"  not null,
  is_instead boolean not null,
  ev_qual    pg_node_tree,
  ev_action  pg_node_tree
);

create unique index if not exists pg_rewrite_oid_index
  on pg_catalog.pg_rewrite (oid);

create unique index if not exists pg_rewrite_rel_rulename_index
  on pg_catalog.pg_rewrite (ev_class, rulename);

create table if not exists pg_catalog.pg_statistic
(
  starelid    oid      not null,
  staattnum   smallint not null,
  stainherit  boolean  not null,
  stanullfrac real     not null,
  stawidth    integer  not null,
  stadistinct real     not null,
  stakind1    smallint not null,
  stakind2    smallint not null,
  stakind3    smallint not null,
  stakind4    smallint not null,
  stakind5    smallint not null,
  staop1      oid      not null,
  staop2      oid      not null,
  staop3      oid      not null,
  staop4      oid      not null,
  staop5      oid      not null,
  stanumbers1 real [],
  stanumbers2 real [],
  stanumbers3 real [],
  stanumbers4 real [],
  stanumbers5 real [],
  stavalues1  anyarray,
  stavalues2  anyarray,
  stavalues3  anyarray,
  stavalues4  anyarray,
  stavalues5  anyarray
);

create unique index if not exists pg_statistic_relid_att_inh_index
  on pg_catalog.pg_statistic (starelid, staattnum, stainherit);

create table if not exists pg_catalog.pg_trigger
(
  tgrelid        oid        not null,
  tgname         name       not null,
  tgfoid         oid        not null,
  tgtype         smallint   not null,
  tgenabled      "char"     not null,
  tgisinternal   boolean    not null,
  tgconstrrelid  oid        not null,
  tgconstrindid  oid        not null,
  tgconstraint   oid        not null,
  tgdeferrable   boolean    not null,
  tginitdeferred boolean    not null,
  tgnargs        smallint   not null,
  tgattr         int2vector not null,
  tgargs         bytea      not null,
  tgqual         pg_node_tree,
  tgoldtable     name,
  tgnewtable     name
);

create index if not exists pg_trigger_tgconstraint_index
  on pg_catalog.pg_trigger (tgconstraint);

create unique index if not exists pg_trigger_tgrelid_tgname_index
  on pg_catalog.pg_trigger (tgrelid, tgname);

create unique index if not exists pg_trigger_oid_index
  on pg_catalog.pg_trigger (oid);

create table if not exists pg_catalog.pg_opfamily
(
  opfmethod    oid  not null,
  opfname      name not null,
  opfnamespace oid  not null,
  opfowner     oid  not null
);

create unique index if not exists pg_opfamily_am_name_nsp_index
  on pg_catalog.pg_opfamily (opfmethod, opfname, opfnamespace);

create unique index if not exists pg_opfamily_oid_index
  on pg_catalog.pg_opfamily (oid);

create table if not exists pg_catalog.pg_db_role_setting
(
  setdatabase oid not null,
  setrole     oid not null,
  setconfig   text []
);

create unique index if not exists pg_db_role_setting_databaseid_rol_index
  on pg_catalog.pg_db_role_setting (setdatabase, setrole);

create table if not exists pg_catalog.pg_largeobject_metadata
(
  lomowner oid not null,
  lomacl   aclitem []
);

create unique index if not exists pg_largeobject_metadata_oid_index
  on pg_catalog.pg_largeobject_metadata (oid);

create table if not exists pg_catalog.pg_extension
(
  extname        name    not null,
  extowner       oid     not null,
  extnamespace   oid     not null,
  extrelocatable boolean not null,
  extversion     text    not null,
  extconfig      oid [],
  extcondition   text []
);

create unique index if not exists pg_extension_oid_index
  on pg_catalog.pg_extension (oid);

create unique index if not exists pg_extension_name_index
  on pg_catalog.pg_extension (extname);

create table if not exists pg_catalog.pg_foreign_table
(
  ftrelid   oid not null,
  ftserver  oid not null,
  ftoptions text []
);

create unique index if not exists pg_foreign_table_relid_index
  on pg_catalog.pg_foreign_table (ftrelid);

create table if not exists pg_catalog.pg_policy
(
  polname       name    not null,
  polrelid      oid     not null,
  polcmd        "char"  not null,
  polpermissive boolean not null,
  polroles      oid [],
  polqual       pg_node_tree,
  polwithcheck  pg_node_tree
);

create unique index if not exists pg_policy_oid_index
  on pg_catalog.pg_policy (oid);

create unique index if not exists pg_policy_polrelid_polname_index
  on pg_catalog.pg_policy (polrelid, polname);

create table if not exists pg_catalog.pg_partitioned_table
(
  partrelid     oid        not null,
  partstrat     "char"     not null,
  partnatts     smallint   not null,
  partdefid     oid        not null,
  partattrs     int2vector not null,
  partclass     oidvector  not null,
  partcollation oidvector  not null,
  partexprs     pg_node_tree
);

create unique index if not exists pg_partitioned_table_partrelid_index
  on pg_catalog.pg_partitioned_table (partrelid);

create table if not exists pg_catalog.pg_statistic_ext
(
  stxrelid        oid        not null,
  stxname         name       not null,
  stxnamespace    oid        not null,
  stxowner        oid        not null,
  stxkeys         int2vector not null,
  stxkind         "char" []  not null,
  stxndistinct    pg_ndistinct,
  stxdependencies pg_dependencies
);

create index if not exists pg_statistic_ext_relid_index
  on pg_catalog.pg_statistic_ext (stxrelid);

create unique index if not exists pg_statistic_ext_oid_index
  on pg_catalog.pg_statistic_ext (oid);

create unique index if not exists pg_statistic_ext_name_index
  on pg_catalog.pg_statistic_ext (stxname, stxnamespace);

create table if not exists pg_catalog.pg_init_privs
(
  objoid    oid        not null,
  classoid  oid        not null,
  objsubid  integer    not null,
  privtype  "char"     not null,
  initprivs aclitem [] not null
);

create unique index if not exists pg_init_privs_o_c_o_index
  on pg_catalog.pg_init_privs (objoid, classoid, objsubid);

create table if not exists pg_catalog.pg_collation
(
  collname      name    not null,
  collnamespace oid     not null,
  collowner     oid     not null,
  collprovider  "char"  not null,
  collencoding  integer not null,
  collcollate   name    not null,
  collctype     name    not null,
  collversion   text
);

create unique index if not exists pg_collation_oid_index
  on pg_catalog.pg_collation (oid);

create unique index if not exists pg_collation_name_enc_nsp_index
  on pg_catalog.pg_collation (collname, collencoding, collnamespace);

create table if not exists pg_catalog.pg_event_trigger
(
  evtname    name   not null,
  evtevent   name   not null,
  evtowner   oid    not null,
  evtfoid    oid    not null,
  evtenabled "char" not null,
  evttags    text []
);

create unique index if not exists pg_event_trigger_evtname_index
  on pg_catalog.pg_event_trigger (evtname);

create unique index if not exists pg_event_trigger_oid_index
  on pg_catalog.pg_event_trigger (oid);

create table if not exists pg_catalog.pg_enum
(
  enumtypid     oid  not null,
  enumsortorder real not null,
  enumlabel     name not null
);

create unique index if not exists pg_enum_oid_index
  on pg_catalog.pg_enum (oid);

create unique index if not exists pg_enum_typid_label_index
  on pg_catalog.pg_enum (enumtypid, enumlabel);

create unique index if not exists pg_enum_typid_sortorder_index
  on pg_catalog.pg_enum (enumtypid, enumsortorder);

create table if not exists pg_catalog.pg_range
(
  rngtypid     oid     not null,
  rngsubtype   oid     not null,
  rngcollation oid     not null,
  rngsubopc    oid     not null,
  rngcanonical regproc not null,
  rngsubdiff   regproc not null
);

create unique index if not exists pg_range_rngtypid_index
  on pg_catalog.pg_range (rngtypid);

create table if not exists pg_catalog.pg_transform
(
  trftype    oid     not null,
  trflang    oid     not null,
  trffromsql regproc not null,
  trftosql   regproc not null
);

create unique index if not exists pg_transform_oid_index
  on pg_catalog.pg_transform (oid);

create unique index if not exists pg_transform_type_lang_index
  on pg_catalog.pg_transform (trftype, trflang);

create table if not exists pg_catalog.pg_shseclabel
(
  objoid   oid  not null,
  classoid oid  not null,
  provider text not null,
  label    text not null
);

create unique index if not exists pg_shseclabel_object_index
  on pg_catalog.pg_shseclabel (objoid, classoid, provider);

create table if not exists pg_catalog.pg_seclabel
(
  objoid   oid     not null,
  classoid oid     not null,
  objsubid integer not null,
  provider text    not null,
  label    text    not null
);

create unique index if not exists pg_seclabel_object_index
  on pg_catalog.pg_seclabel (objoid, classoid, objsubid, provider);

create table if not exists pg_catalog.pg_ts_dict
(
  dictname       name not null,
  dictnamespace  oid  not null,
  dictowner      oid  not null,
  dicttemplate   oid  not null,
  dictinitoption text
);

create unique index if not exists pg_ts_dict_dictname_index
  on pg_catalog.pg_ts_dict (dictname, dictnamespace);

create unique index if not exists pg_ts_dict_oid_index
  on pg_catalog.pg_ts_dict (oid);

create table if not exists pg_catalog.pg_ts_parser
(
  prsname      name    not null,
  prsnamespace oid     not null,
  prsstart     regproc not null,
  prstoken     regproc not null,
  prsend       regproc not null,
  prsheadline  regproc not null,
  prslextype   regproc not null
);

create unique index if not exists pg_ts_parser_prsname_index
  on pg_catalog.pg_ts_parser (prsname, prsnamespace);

create unique index if not exists pg_ts_parser_oid_index
  on pg_catalog.pg_ts_parser (oid);

create table if not exists pg_catalog.pg_ts_config
(
  cfgname      name not null,
  cfgnamespace oid  not null,
  cfgowner     oid  not null,
  cfgparser    oid  not null
);

create unique index if not exists pg_ts_config_cfgname_index
  on pg_catalog.pg_ts_config (cfgname, cfgnamespace);

create unique index if not exists pg_ts_config_oid_index
  on pg_catalog.pg_ts_config (oid);

create table if not exists pg_catalog.pg_ts_config_map
(
  mapcfg       oid     not null,
  maptokentype integer not null,
  mapseqno     integer not null,
  mapdict      oid     not null
);

create unique index if not exists pg_ts_config_map_index
  on pg_catalog.pg_ts_config_map (mapcfg, maptokentype, mapseqno);

create table if not exists pg_catalog.pg_ts_template
(
  tmplname      name    not null,
  tmplnamespace oid     not null,
  tmplinit      regproc not null,
  tmpllexize    regproc not null
);

create unique index if not exists pg_ts_template_tmplname_index
  on pg_catalog.pg_ts_template (tmplname, tmplnamespace);

create unique index if not exists pg_ts_template_oid_index
  on pg_catalog.pg_ts_template (oid);

create table if not exists pg_catalog.pg_replication_origin
(
  roident oid  not null,
  roname  text not null
);

create unique index if not exists pg_replication_origin_roiident_index
  on pg_catalog.pg_replication_origin (roident);

create unique index if not exists pg_replication_origin_roname_index
  on pg_catalog.pg_replication_origin (roname);

create table if not exists pg_catalog.pg_subscription
(
  subdbid         oid     not null,
  subname         name    not null,
  subowner        oid     not null,
  subenabled      boolean not null,
  subconninfo     text    not null,
  subslotname     name    not null,
  subsynccommit   text    not null,
  subpublications text [] not null
);

create unique index if not exists pg_subscription_oid_index
  on pg_catalog.pg_subscription (oid);

create unique index if not exists pg_subscription_subname_index
  on pg_catalog.pg_subscription (subdbid, subname);

create table if not exists pg_catalog.pg_subscription_rel
(
  srsubid    oid    not null,
  srrelid    oid    not null,
  srsubstate "char" not null,
  srsublsn   pg_lsn not null
);

create unique index if not exists pg_subscription_rel_srrelid_srsubid_index
  on pg_catalog.pg_subscription_rel (srrelid, srsubid);

create table if not exists pg_catalog.pg_publication
(
  pubname      name    not null,
  pubowner     oid     not null,
  puballtables boolean not null,
  pubinsert    boolean not null,
  pubupdate    boolean not null,
  pubdelete    boolean not null,
  pubtruncate  boolean not null
);

create unique index if not exists pg_publication_oid_index
  on pg_catalog.pg_publication (oid);

create unique index if not exists pg_publication_pubname_index
  on pg_catalog.pg_publication (pubname);

create table if not exists pg_catalog.pg_publication_rel
(
  prpubid oid not null,
  prrelid oid not null
);

create unique index if not exists pg_publication_rel_oid_index
  on pg_catalog.pg_publication_rel (oid);

create unique index if not exists pg_publication_rel_prrelid_prpubid_index
  on pg_catalog.pg_publication_rel (prrelid, prpubid);

create table if not exists information_schema.sql_features
(
  feature_id       information_schema.character_data,
  feature_name     information_schema.character_data,
  sub_feature_id   information_schema.character_data,
  sub_feature_name information_schema.character_data,
  is_supported     information_schema.yes_or_no,
  is_verified_by   information_schema.character_data,
  comments         information_schema.character_data
);

create table if not exists information_schema.sql_implementation_info
(
  implementation_info_id   information_schema.character_data,
  implementation_info_name information_schema.character_data,
  integer_value            information_schema.cardinal_number,
  character_value          information_schema.character_data,
  comments                 information_schema.character_data
);

create table if not exists information_schema.sql_languages
(
  sql_language_source               information_schema.character_data,
  sql_language_year                 information_schema.character_data,
  sql_language_conformance          information_schema.character_data,
  sql_language_integrity            information_schema.character_data,
  sql_language_implementation       information_schema.character_data,
  sql_language_binding_style        information_schema.character_data,
  sql_language_programming_language information_schema.character_data
);

create table if not exists information_schema.sql_packages
(
  feature_id     information_schema.character_data,
  feature_name   information_schema.character_data,
  is_supported   information_schema.yes_or_no,
  is_verified_by information_schema.character_data,
  comments       information_schema.character_data
);

create table if not exists information_schema.sql_parts
(
  feature_id     information_schema.character_data,
  feature_name   information_schema.character_data,
  is_supported   information_schema.yes_or_no,
  is_verified_by information_schema.character_data,
  comments       information_schema.character_data
);

create table if not exists information_schema.sql_sizing
(
  sizing_id       information_schema.cardinal_number,
  sizing_name     information_schema.character_data,
  supported_value information_schema.cardinal_number,
  comments        information_schema.character_data
);

create table if not exists information_schema.sql_sizing_profiles
(
  sizing_id      information_schema.cardinal_number,
  sizing_name    information_schema.character_data,
  profile_id     information_schema.character_data,
  required_value information_schema.cardinal_number,
  comments       information_schema.character_data
);

create table if not exists django_migrations
(
  id      serial                   not null
    constraint django_migrations_pkey
    primary key,
  app     varchar(255)             not null,
  name    varchar(255)             not null,
  applied timestamp with time zone not null
);

create table if not exists django_content_type
(
  id        serial       not null
    constraint django_content_type_pkey
    primary key,
  app_label varchar(100) not null,
  model     varchar(100) not null,
  constraint django_content_type_app_label_model_76bd3d3b_uniq
  unique (app_label, model)
);

create table if not exists auth_permission
(
  id              serial       not null
    constraint auth_permission_pkey
    primary key,
  name            varchar(255) not null,
  content_type_id integer      not null
    constraint auth_permission_content_type_id_2f476e4b_fk_django_co
    references django_content_type
      deferrable initially deferred,
  codename        varchar(100) not null,
  constraint auth_permission_content_type_id_codename_01ab375a_uniq
  unique (content_type_id, codename)
);

create index if not exists auth_permission_content_type_id_2f476e4b
  on auth_permission (content_type_id);

create table if not exists auth_group
(
  id   serial       not null
    constraint auth_group_pkey
    primary key,
  name varchar(150) not null
    constraint auth_group_name_key
    unique
);

create index if not exists auth_group_name_a6ea08ec_like
  on auth_group (name);

create table if not exists auth_group_permissions
(
  id            serial  not null
    constraint auth_group_permissions_pkey
    primary key,
  group_id      integer not null
    constraint auth_group_permissions_group_id_b120cbf9_fk_auth_group_id
    references auth_group
      deferrable initially deferred,
  permission_id integer not null
    constraint auth_group_permissio_permission_id_84c5c92e_fk_auth_perm
    references auth_permission
      deferrable initially deferred,
  constraint auth_group_permissions_group_id_permission_id_0cd325b0_uniq
  unique (group_id, permission_id)
);

create index if not exists auth_group_permissions_group_id_b120cbf9
  on auth_group_permissions (group_id);

create index if not exists auth_group_permissions_permission_id_84c5c92e
  on auth_group_permissions (permission_id);

create table if not exists user_customuser
(
  id           serial                   not null
    constraint user_customuser_pkey
    primary key,
  password     varchar(128)             not null,
  last_login   timestamp with time zone,
  is_superuser boolean                  not null,
  username     varchar(150)             not null
    constraint user_customuser_username_key
    unique,
  first_name   varchar(30)              not null,
  last_name    varchar(150)             not null,
  is_staff     boolean                  not null,
  is_active    boolean                  not null,
  date_joined  timestamp with time zone not null,
  email        varchar(254)             not null
);

create index if not exists user_customuser_username_24be6f7e_like
  on user_customuser (username);

create table if not exists user_customuser_groups
(
  id            serial  not null
    constraint user_customuser_groups_pkey
    primary key,
  customuser_id integer not null
    constraint user_customuser_grou_customuser_id_192632a7_fk_user_cust
    references user_customuser
      deferrable initially deferred,
  group_id      integer not null
    constraint user_customuser_groups_group_id_bcbc9e48_fk_auth_group_id
    references auth_group
      deferrable initially deferred,
  constraint user_customuser_groups_customuser_id_group_id_e0a2f621_uniq
  unique (customuser_id, group_id)
);

create index if not exists user_customuser_groups_customuser_id_192632a7
  on user_customuser_groups (customuser_id);

create index if not exists user_customuser_groups_group_id_bcbc9e48
  on user_customuser_groups (group_id);

create table if not exists user_customuser_user_permissions
(
  id            serial  not null
    constraint user_customuser_user_permissions_pkey
    primary key,
  customuser_id integer not null
    constraint user_customuser_user_customuser_id_4552d9cc_fk_user_cust
    references user_customuser
      deferrable initially deferred,
  permission_id integer not null
    constraint user_customuser_user_permission_id_e57e8b9a_fk_auth_perm
    references auth_permission
      deferrable initially deferred,
  constraint user_customuser_user_per_customuser_id_permission_a5da865d_uniq
  unique (customuser_id, permission_id)
);

create index if not exists user_customuser_user_permissions_customuser_id_4552d9cc
  on user_customuser_user_permissions (customuser_id);

create index if not exists user_customuser_user_permissions_permission_id_e57e8b9a
  on user_customuser_user_permissions (permission_id);

create table if not exists django_admin_log
(
  id              serial                   not null
    constraint django_admin_log_pkey
    primary key,
  action_time     timestamp with time zone not null,
  object_id       text,
  object_repr     varchar(200)             not null,
  action_flag     smallint                 not null
    constraint django_admin_log_action_flag_check
    check (action_flag >= 0),
  change_message  text                     not null,
  content_type_id integer
    constraint django_admin_log_content_type_id_c4bce8eb_fk_django_co
    references django_content_type
      deferrable initially deferred,
  user_id         integer                  not null
    constraint django_admin_log_user_id_c564eba6_fk_user_customuser_id
    references user_customuser
      deferrable initially deferred
);

create index if not exists django_admin_log_content_type_id_c4bce8eb
  on django_admin_log (content_type_id);

create index if not exists django_admin_log_user_id_c564eba6
  on django_admin_log (user_id);

create table if not exists products_product
(
  id              serial       not null
    constraint products_product_pkey
    primary key,
  name            varchar(255) not null,
  nutrition_grade varchar(1)   not null,
  url             varchar(255) not null,
  store           varchar(255) not null,
  category        varchar(140) not null,
  image_link      varchar(255) not null
);

create table if not exists django_session
(
  session_key  varchar(40)              not null
    constraint django_session_pkey
    primary key,
  session_data text                     not null,
  expire_date  timestamp with time zone not null
);

create index if not exists django_session_session_key_c0390e0f_like
  on django_session (session_key);

create index if not exists django_session_expire_date_a5c62663
  on django_session (expire_date);

create table if not exists django_site
(
  id     serial       not null
    constraint django_site_pkey
    primary key,
  domain varchar(100) not null
    constraint django_site_domain_a2e37b91_uniq
    unique,
  name   varchar(50)  not null
);

create index if not exists django_site_domain_a2e37b91_like
  on django_site (domain);

create table if not exists user_userfavorite
(
  id               serial  not null
    constraint user_userfavorite_pkey
    primary key,
  substitution_id  integer not null
    constraint user_userfavorite_substitution_id_61d82e1a_fk_products_
    references products_product
      deferrable initially deferred,
  to_substitute_id integer not null
    constraint user_userfavorite_to_substitute_id_f2d95ce7_fk_products_
    references products_product
      deferrable initially deferred,
  user_id          integer not null
    constraint user_userfavorite_user_id_a90b8a96_fk_user_customuser_id
    references user_customuser
      deferrable initially deferred
);

create index if not exists user_userfavorite_substitution_id_61d82e1a
  on user_userfavorite (substitution_id);

create index if not exists user_userfavorite_to_substitute_id_f2d95ce7
  on user_userfavorite (to_substitute_id);

create index if not exists user_userfavorite_user_id_a90b8a96
  on user_userfavorite (user_id);

create view pg_catalog.pg_roles as
  SELECT pg_authid.rolname,
         pg_authid.rolsuper,
         pg_authid.rolinherit,
         pg_authid.rolcreaterole,
         pg_authid.rolcreatedb,
         pg_authid.rolcanlogin,
         pg_authid.rolreplication,
         pg_authid.rolconnlimit,
         '********' :: text AS rolpassword,
         pg_authid.rolvaliduntil,
         pg_authid.rolbypassrls,
         s.setconfig        AS rolconfig,
         pg_authid.oid
  FROM (pg_authid
      LEFT JOIN pg_db_role_setting s ON (((pg_authid.oid = s.setrole) AND (s.setdatabase = (0) :: oid))));

create view pg_catalog.pg_shadow as
  SELECT pg_authid.rolname                    AS usename,
         pg_authid.oid                        AS usesysid,
         pg_authid.rolcreatedb                AS usecreatedb,
         pg_authid.rolsuper                   AS usesuper,
         pg_authid.rolreplication             AS userepl,
         pg_authid.rolbypassrls               AS usebypassrls,
         pg_authid.rolpassword                AS passwd,
         (pg_authid.rolvaliduntil) :: abstime AS valuntil,
         s.setconfig                          AS useconfig
  FROM (pg_authid
      LEFT JOIN pg_db_role_setting s ON (((pg_authid.oid = s.setrole) AND (s.setdatabase = (0) :: oid))))
  WHERE pg_authid.rolcanlogin;

create view pg_catalog.pg_group as
  SELECT pg_authid.rolname                                                                                        AS groname,
         pg_authid.oid                                                                                            AS grosysid,
         ARRAY(SELECT pg_auth_members.member
               FROM pg_auth_members
               WHERE (pg_auth_members.roleid = pg_authid.oid))                                                    AS grolist
  FROM pg_authid
  WHERE (NOT pg_authid.rolcanlogin);

create view pg_catalog.pg_user as
  SELECT pg_shadow.usename,
         pg_shadow.usesysid,
         pg_shadow.usecreatedb,
         pg_shadow.usesuper,
         pg_shadow.userepl,
         pg_shadow.usebypassrls,
         '********' :: text AS passwd,
         pg_shadow.valuntil,
         pg_shadow.useconfig
  FROM pg_shadow;

create view pg_catalog.pg_policies as
  SELECT n.nspname                                   AS schemaname,
         c.relname                                   AS tablename,
         pol.polname                                 AS policyname,
         CASE
           WHEN pol.polpermissive THEN 'PERMISSIVE' :: text
           ELSE 'RESTRICTIVE' :: text
             END                                     AS permissive,
         CASE
           WHEN (pol.polroles = '{0}' :: oid []) THEN (string_to_array('public' :: text, '' :: text)) :: name []
           ELSE ARRAY(SELECT pg_authid.rolname
                      FROM pg_authid
                      WHERE (pg_authid.oid = ANY (pol.polroles))
                      ORDER BY pg_authid.rolname)
             END                                     AS roles,
         CASE pol.polcmd
           WHEN 'r' :: "char" THEN 'SELECT' :: text
           WHEN 'a' :: "char" THEN 'INSERT' :: text
           WHEN 'w' :: "char" THEN 'UPDATE' :: text
           WHEN 'd' :: "char" THEN 'DELETE' :: text
           WHEN '*' :: "char" THEN 'ALL' :: text
           ELSE NULL :: text
             END                                     AS cmd,
         pg_get_expr(pol.polqual, pol.polrelid)      AS qual,
         pg_get_expr(pol.polwithcheck, pol.polrelid) AS with_check
  FROM ((pg_policy pol
      JOIN pg_class c ON ((c.oid = pol.polrelid)))
      LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)));

create view pg_catalog.pg_rules as
  SELECT n.nspname AS schemaname, c.relname AS tablename, r.rulename, pg_get_ruledef(r.oid) AS definition
  FROM ((pg_rewrite r
      JOIN pg_class c ON ((c.oid = r.ev_class)))
      LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
  WHERE (r.rulename <> '_RETURN' :: name);

create view pg_catalog.pg_views as
  SELECT n.nspname                   AS schemaname,
         c.relname                   AS viewname,
         pg_get_userbyid(c.relowner) AS viewowner,
         pg_get_viewdef(c.oid)       AS definition
  FROM (pg_class c
      LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
  WHERE (c.relkind = 'v' :: "char");

create view pg_catalog.pg_tables as
  SELECT n.nspname                   AS schemaname,
         c.relname                   AS tablename,
         pg_get_userbyid(c.relowner) AS tableowner,
         t.spcname                   AS tablespace,
         c.relhasindex               AS hasindexes,
         c.relhasrules               AS hasrules,
         c.relhastriggers            AS hastriggers,
         c.relrowsecurity            AS rowsecurity
  FROM ((pg_class c
      LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
      LEFT JOIN pg_tablespace t ON ((t.oid = c.reltablespace)))
  WHERE (c.relkind = ANY (ARRAY['r'::"char", 'p'::"char"]));

create view pg_catalog.pg_matviews as
  SELECT n.nspname                   AS schemaname,
         c.relname                   AS matviewname,
         pg_get_userbyid(c.relowner) AS matviewowner,
         t.spcname                   AS tablespace,
         c.relhasindex               AS hasindexes,
         c.relispopulated            AS ispopulated,
         pg_get_viewdef(c.oid)       AS definition
  FROM ((pg_class c
      LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
      LEFT JOIN pg_tablespace t ON ((t.oid = c.reltablespace)))
  WHERE (c.relkind = 'm' :: "char");

create view pg_catalog.pg_indexes as
  SELECT n.nspname              AS schemaname,
         c.relname              AS tablename,
         i.relname              AS indexname,
         t.spcname              AS tablespace,
         pg_get_indexdef(i.oid) AS indexdef
  FROM ((((pg_index x
      JOIN pg_class c ON ((c.oid = x.indrelid)))
      JOIN pg_class i ON ((i.oid = x.indexrelid)))
      LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
      LEFT JOIN pg_tablespace t ON ((t.oid = i.reltablespace)))
  WHERE ((c.relkind = ANY (ARRAY['r'::"char", 'm'::"char"])) AND (i.relkind = 'i' :: "char"));

create view pg_catalog.pg_sequences as
  SELECT n.nspname                   AS schemaname,
         c.relname                   AS sequencename,
         pg_get_userbyid(c.relowner) AS sequenceowner,
         (s.seqtypid) :: regtype     AS data_type,
         s.seqstart                  AS start_value,
         s.seqmin                    AS min_value,
         s.seqmax                    AS max_value,
         s.seqincrement              AS increment_by,
         s.seqcycle                  AS cycle,
         s.seqcache                  AS cache_size,
         CASE
           WHEN has_sequence_privilege(c.oid, 'SELECT,USAGE' :: text) THEN pg_sequence_last_value((c.oid) :: regclass)
           ELSE NULL :: bigint
             END                     AS last_value
  FROM ((pg_sequence s
      JOIN pg_class c ON ((c.oid = s.seqrelid)))
      LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
  WHERE ((NOT pg_is_other_temp_schema(n.oid)) AND (c.relkind = 'S' :: "char"));

create view pg_catalog.pg_stats as
  SELECT n.nspname     AS schemaname,
         c.relname     AS tablename,
         a.attname,
         s.stainherit  AS inherited,
         s.stanullfrac AS null_frac,
         s.stawidth    AS avg_width,
         s.stadistinct AS n_distinct,
         CASE
           WHEN (s.stakind1 = 1) THEN s.stavalues1
           WHEN (s.stakind2 = 1) THEN s.stavalues2
           WHEN (s.stakind3 = 1) THEN s.stavalues3
           WHEN (s.stakind4 = 1) THEN s.stavalues4
           WHEN (s.stakind5 = 1) THEN s.stavalues5
           ELSE NULL :: anyarray
             END       AS most_common_vals,
         CASE
           WHEN (s.stakind1 = 1) THEN s.stanumbers1
           WHEN (s.stakind2 = 1) THEN s.stanumbers2
           WHEN (s.stakind3 = 1) THEN s.stanumbers3
           WHEN (s.stakind4 = 1) THEN s.stanumbers4
           WHEN (s.stakind5 = 1) THEN s.stanumbers5
           ELSE NULL :: real []
             END       AS most_common_freqs,
         CASE
           WHEN (s.stakind1 = 2) THEN s.stavalues1
           WHEN (s.stakind2 = 2) THEN s.stavalues2
           WHEN (s.stakind3 = 2) THEN s.stavalues3
           WHEN (s.stakind4 = 2) THEN s.stavalues4
           WHEN (s.stakind5 = 2) THEN s.stavalues5
           ELSE NULL :: anyarray
             END       AS histogram_bounds,
         CASE
           WHEN (s.stakind1 = 3) THEN s.stanumbers1 [ 1 ]
           WHEN (s.stakind2 = 3) THEN s.stanumbers2 [ 1 ]
           WHEN (s.stakind3 = 3) THEN s.stanumbers3 [ 1 ]
           WHEN (s.stakind4 = 3) THEN s.stanumbers4 [ 1 ]
           WHEN (s.stakind5 = 3) THEN s.stanumbers5 [ 1 ]
           ELSE NULL :: real
             END       AS correlation,
         CASE
           WHEN (s.stakind1 = 4) THEN s.stavalues1
           WHEN (s.stakind2 = 4) THEN s.stavalues2
           WHEN (s.stakind3 = 4) THEN s.stavalues3
           WHEN (s.stakind4 = 4) THEN s.stavalues4
           WHEN (s.stakind5 = 4) THEN s.stavalues5
           ELSE NULL :: anyarray
             END       AS most_common_elems,
         CASE
           WHEN (s.stakind1 = 4) THEN s.stanumbers1
           WHEN (s.stakind2 = 4) THEN s.stanumbers2
           WHEN (s.stakind3 = 4) THEN s.stanumbers3
           WHEN (s.stakind4 = 4) THEN s.stanumbers4
           WHEN (s.stakind5 = 4) THEN s.stanumbers5
           ELSE NULL :: real []
             END       AS most_common_elem_freqs,
         CASE
           WHEN (s.stakind1 = 5) THEN s.stanumbers1
           WHEN (s.stakind2 = 5) THEN s.stanumbers2
           WHEN (s.stakind3 = 5) THEN s.stanumbers3
           WHEN (s.stakind4 = 5) THEN s.stanumbers4
           WHEN (s.stakind5 = 5) THEN s.stanumbers5
           ELSE NULL :: real []
             END       AS elem_count_histogram
  FROM (((pg_statistic s
      JOIN pg_class c ON ((c.oid = s.starelid)))
      JOIN pg_attribute a ON (((c.oid = a.attrelid) AND (a.attnum = s.staattnum))))
      LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
  WHERE ((NOT a.attisdropped) AND has_column_privilege(c.oid, a.attnum, 'select' :: text) AND
         ((c.relrowsecurity = false) OR (NOT row_security_active(c.oid))));

create view pg_catalog.pg_publication_tables as
  SELECT p.pubname, n.nspname AS schemaname, c.relname AS tablename
  FROM pg_publication p,
       (pg_class c
           JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
  WHERE (c.oid IN (SELECT pg_get_publication_tables.relid
                   FROM pg_get_publication_tables((p.pubname) :: text) pg_get_publication_tables (relid)));

create view pg_catalog.pg_locks as
  SELECT l.locktype,
         l.database,
         l.relation,
         l.page,
         l.tuple,
         l.virtualxid,
         l.transactionid,
         l.classid,
         l.objid,
         l.objsubid,
         l.virtualtransaction,
         l.pid,
         l.mode,
         l.granted,
         l.fastpath
  FROM pg_lock_status() l (locktype, database, relation, page, tuple, virtualxid, transactionid, classid, objid, objsubid, virtualtransaction, pid, mode, granted, fastpath);

create view pg_catalog.pg_cursors as
  SELECT c.name, c.statement, c.is_holdable, c.is_binary, c.is_scrollable, c.creation_time
  FROM pg_cursor() c (name, statement, is_holdable, is_binary, is_scrollable, creation_time);

create view pg_catalog.pg_available_extensions as
  SELECT e.name, e.default_version, x.extversion AS installed_version, e.comment
  FROM (pg_available_extensions() e(name, default_version, comment)
      LEFT JOIN pg_extension x ON ((e.name = x.extname)));

create view pg_catalog.pg_available_extension_versions as
  SELECT e.name,
         e.version,
         (x.extname IS NOT NULL) AS installed,
         e.superuser,
         e.relocatable,
         e.schema,
         e.requires,
         e.comment
  FROM (pg_available_extension_versions() e(name, version, superuser, relocatable, schema, requires, comment)
      LEFT JOIN pg_extension x ON (((e.name = x.extname) AND (e.version = x.extversion))));

create view pg_catalog.pg_prepared_xacts as
  SELECT p.transaction, p.gid, p.prepared, u.rolname AS owner, d.datname AS database
  FROM ((pg_prepared_xact() p(transaction, gid, prepared, ownerid, dbid)
      LEFT JOIN pg_authid u ON ((p.ownerid = u.oid)))
      LEFT JOIN pg_database d ON ((p.dbid = d.oid)));

create view pg_catalog.pg_prepared_statements as
  SELECT p.name, p.statement, p.prepare_time, p.parameter_types, p.from_sql
  FROM pg_prepared_statement() p (name, statement, prepare_time, parameter_types, from_sql);

create view pg_catalog.pg_seclabels as
  SELECT l.objoid,
         l.classoid,
         l.objsubid,
         CASE
           WHEN (rel.relkind = ANY (ARRAY['r'::"char", 'p'::"char"])) THEN 'table' :: text
           WHEN (rel.relkind = 'v' :: "char") THEN 'view' :: text
           WHEN (rel.relkind = 'm' :: "char") THEN 'materialized view' :: text
           WHEN (rel.relkind = 'S' :: "char") THEN 'sequence' :: text
           WHEN (rel.relkind = 'f' :: "char") THEN 'foreign table' :: text
           ELSE NULL :: text
             END          AS objtype,
         rel.relnamespace AS objnamespace,
         CASE
           WHEN pg_table_is_visible(rel.oid) THEN quote_ident((rel.relname) :: text)
           ELSE ((quote_ident((nsp.nspname) :: text) || '.' :: text) || quote_ident((rel.relname) :: text))
             END          AS objname,
         l.provider,
         l.label
  FROM ((pg_seclabel l
      JOIN pg_class rel ON (((l.classoid = rel.tableoid) AND (l.objoid = rel.oid))))
      JOIN pg_namespace nsp ON ((rel.relnamespace = nsp.oid)))
  WHERE (l.objsubid = 0)
  UNION ALL
  SELECT l.objoid,
         l.classoid,
         l.objsubid,
         'column' :: text                                       AS objtype,
         rel.relnamespace                                       AS objnamespace,
         ((
              CASE
                WHEN pg_table_is_visible(rel.oid) THEN quote_ident((rel.relname) :: text)
                ELSE ((quote_ident((nsp.nspname) :: text) || '.' :: text) || quote_ident((rel.relname) :: text))
                  END || '.' :: text) || (att.attname) :: text) AS objname,
         l.provider,
         l.label
  FROM (((pg_seclabel l
      JOIN pg_class rel ON (((l.classoid = rel.tableoid) AND (l.objoid = rel.oid))))
      JOIN pg_attribute att ON (((rel.oid = att.attrelid) AND (l.objsubid = att.attnum))))
      JOIN pg_namespace nsp ON ((rel.relnamespace = nsp.oid)))
  WHERE (l.objsubid <> 0)
  UNION ALL
  SELECT l.objoid,
         l.classoid,
         l.objsubid,
         CASE pro.prokind
           WHEN 'a' :: "char" THEN 'aggregate' :: text
           WHEN 'f' :: "char" THEN 'function' :: text
           WHEN 'p' :: "char" THEN 'procedure' :: text
           WHEN 'w' :: "char" THEN 'window' :: text
           ELSE NULL :: text
             END                                                                              AS objtype,
         pro.pronamespace                                                                     AS objnamespace,
         (((
               CASE
                 WHEN pg_function_is_visible(pro.oid) THEN quote_ident((pro.proname) :: text)
                 ELSE ((quote_ident((nsp.nspname) :: text) || '.' :: text) || quote_ident((pro.proname) :: text))
                   END || '(' :: text) || pg_get_function_arguments(pro.oid)) || ')' :: text) AS objname,
         l.provider,
         l.label
  FROM ((pg_seclabel l
      JOIN pg_proc pro ON (((l.classoid = pro.tableoid) AND (l.objoid = pro.oid))))
      JOIN pg_namespace nsp ON ((pro.pronamespace = nsp.oid)))
  WHERE (l.objsubid = 0)
  UNION ALL
  SELECT l.objoid,
         l.classoid,
         l.objsubid,
         CASE
           WHEN (typ.typtype = 'd' :: "char") THEN 'domain' :: text
           ELSE 'type' :: text
             END          AS objtype,
         typ.typnamespace AS objnamespace,
         CASE
           WHEN pg_type_is_visible(typ.oid) THEN quote_ident((typ.typname) :: text)
           ELSE ((quote_ident((nsp.nspname) :: text) || '.' :: text) || quote_ident((typ.typname) :: text))
             END          AS objname,
         l.provider,
         l.label
  FROM ((pg_seclabel l
      JOIN pg_type typ ON (((l.classoid = typ.tableoid) AND (l.objoid = typ.oid))))
      JOIN pg_namespace nsp ON ((typ.typnamespace = nsp.oid)))
  WHERE (l.objsubid = 0)
  UNION ALL
  SELECT l.objoid,
         l.classoid,
         l.objsubid,
         'large object' :: text AS objtype,
         NULL :: oid            AS objnamespace,
         (l.objoid) :: text     AS objname,
         l.provider,
         l.label
  FROM (pg_seclabel l
      JOIN pg_largeobject_metadata lom ON ((l.objoid = lom.oid)))
  WHERE ((l.classoid = ('pg_largeobject' :: regclass) :: oid) AND (l.objsubid = 0))
  UNION ALL
  SELECT l.objoid,
         l.classoid,
         l.objsubid,
         'language' :: text                 AS objtype,
         NULL :: oid                        AS objnamespace,
         quote_ident((lan.lanname) :: text) AS objname,
         l.provider,
         l.label
  FROM (pg_seclabel l
      JOIN pg_language lan ON (((l.classoid = lan.tableoid) AND (l.objoid = lan.oid))))
  WHERE (l.objsubid = 0)
  UNION ALL
  SELECT l.objoid,
         l.classoid,
         l.objsubid,
         'schema' :: text                   AS objtype,
         nsp.oid                            AS objnamespace,
         quote_ident((nsp.nspname) :: text) AS objname,
         l.provider,
         l.label
  FROM (pg_seclabel l
      JOIN pg_namespace nsp ON (((l.classoid = nsp.tableoid) AND (l.objoid = nsp.oid))))
  WHERE (l.objsubid = 0)
  UNION ALL
  SELECT l.objoid,
         l.classoid,
         l.objsubid,
         'event trigger' :: text            AS objtype,
         NULL :: oid                        AS objnamespace,
         quote_ident((evt.evtname) :: text) AS objname,
         l.provider,
         l.label
  FROM (pg_seclabel l
      JOIN pg_event_trigger evt ON (((l.classoid = evt.tableoid) AND (l.objoid = evt.oid))))
  WHERE (l.objsubid = 0)
  UNION ALL
  SELECT l.objoid,
         l.classoid,
         l.objsubid,
         'publication' :: text            AS objtype,
         NULL :: oid                      AS objnamespace,
         quote_ident((p.pubname) :: text) AS objname,
         l.provider,
         l.label
  FROM (pg_seclabel l
      JOIN pg_publication p ON (((l.classoid = p.tableoid) AND (l.objoid = p.oid))))
  WHERE (l.objsubid = 0)
  UNION ALL
  SELECT l.objoid,
         l.classoid,
         0                                AS objsubid,
         'subscription' :: text           AS objtype,
         NULL :: oid                      AS objnamespace,
         quote_ident((s.subname) :: text) AS objname,
         l.provider,
         l.label
  FROM (pg_shseclabel l
      JOIN pg_subscription s ON (((l.classoid = s.tableoid) AND (l.objoid = s.oid))))
  UNION ALL
  SELECT l.objoid,
         l.classoid,
         0                                  AS objsubid,
         'database' :: text                 AS objtype,
         NULL :: oid                        AS objnamespace,
         quote_ident((dat.datname) :: text) AS objname,
         l.provider,
         l.label
  FROM (pg_shseclabel l
      JOIN pg_database dat ON (((l.classoid = dat.tableoid) AND (l.objoid = dat.oid))))
  UNION ALL
  SELECT l.objoid,
         l.classoid,
         0                                  AS objsubid,
         'tablespace' :: text               AS objtype,
         NULL :: oid                        AS objnamespace,
         quote_ident((spc.spcname) :: text) AS objname,
         l.provider,
         l.label
  FROM (pg_shseclabel l
      JOIN pg_tablespace spc ON (((l.classoid = spc.tableoid) AND (l.objoid = spc.oid))))
  UNION ALL
  SELECT l.objoid,
         l.classoid,
         0                                  AS objsubid,
         'role' :: text                     AS objtype,
         NULL :: oid                        AS objnamespace,
         quote_ident((rol.rolname) :: text) AS objname,
         l.provider,
         l.label
  FROM (pg_shseclabel l
      JOIN pg_authid rol ON (((l.classoid = rol.tableoid) AND (l.objoid = rol.oid))));

create view pg_catalog.pg_settings as
  SELECT a.name,
         a.setting,
         a.unit,
         a.category,
         a.short_desc,
         a.extra_desc,
         a.context,
         a.vartype,
         a.source,
         a.min_val,
         a.max_val,
         a.enumvals,
         a.boot_val,
         a.reset_val,
         a.sourcefile,
         a.sourceline,
         a.pending_restart
  FROM pg_show_all_settings() a (name, setting, unit, category, short_desc, extra_desc, context, vartype, source, min_val, max_val, enumvals, boot_val, reset_val, sourcefile, sourceline, pending_restart);

CREATE RULE pg_settings_u AS
  ON UPDATE
  TO pg_catalog.pg_settings
  WHERE (new.name = old.name) DO SELECT set_config(old.name, new.setting, false) AS set_config;

CREATE RULE pg_settings_n AS
  ON UPDATE
  TO pg_catalog.pg_settings DO INSTEAD NOTHING;

create view pg_catalog.pg_file_settings as
  SELECT a.sourcefile, a.sourceline, a.seqno, a.name, a.setting, a.applied, a.error
  FROM pg_show_all_file_settings() a (sourcefile, sourceline, seqno, name, setting, applied, error);

create view pg_catalog.pg_hba_file_rules as
  SELECT a.line_number,
         a.type,
         a.database,
         a.user_name,
         a.address,
         a.netmask,
         a.auth_method,
         a.options,
         a.error
  FROM pg_hba_file_rules() a (line_number, type, database, user_name, address, netmask, auth_method, options, error);

create view pg_catalog.pg_timezone_abbrevs as
  SELECT pg_timezone_abbrevs.abbrev, pg_timezone_abbrevs.utc_offset, pg_timezone_abbrevs.is_dst
  FROM pg_timezone_abbrevs() pg_timezone_abbrevs (abbrev, utc_offset, is_dst);

create view pg_catalog.pg_timezone_names as
  SELECT pg_timezone_names.name, pg_timezone_names.abbrev, pg_timezone_names.utc_offset, pg_timezone_names.is_dst
  FROM pg_timezone_names() pg_timezone_names (name, abbrev, utc_offset, is_dst);

create view pg_catalog.pg_config as
  SELECT pg_config.name, pg_config.setting
  FROM pg_config() pg_config (name, setting);

create view pg_catalog.pg_stat_all_tables as
  SELECT c.oid                                               AS relid,
         n.nspname                                           AS schemaname,
         c.relname,
         pg_stat_get_numscans(c.oid)                         AS seq_scan,
         pg_stat_get_tuples_returned(c.oid)                  AS seq_tup_read,
         (sum(pg_stat_get_numscans(i.indexrelid))) :: bigint AS idx_scan,
         ((sum(pg_stat_get_tuples_fetched(i.indexrelid))) :: bigint +
          pg_stat_get_tuples_fetched(c.oid))                 AS idx_tup_fetch,
         pg_stat_get_tuples_inserted(c.oid)                  AS n_tup_ins,
         pg_stat_get_tuples_updated(c.oid)                   AS n_tup_upd,
         pg_stat_get_tuples_deleted(c.oid)                   AS n_tup_del,
         pg_stat_get_tuples_hot_updated(c.oid)               AS n_tup_hot_upd,
         pg_stat_get_live_tuples(c.oid)                      AS n_live_tup,
         pg_stat_get_dead_tuples(c.oid)                      AS n_dead_tup,
         pg_stat_get_mod_since_analyze(c.oid)                AS n_mod_since_analyze,
         pg_stat_get_last_vacuum_time(c.oid)                 AS last_vacuum,
         pg_stat_get_last_autovacuum_time(c.oid)             AS last_autovacuum,
         pg_stat_get_last_analyze_time(c.oid)                AS last_analyze,
         pg_stat_get_last_autoanalyze_time(c.oid)            AS last_autoanalyze,
         pg_stat_get_vacuum_count(c.oid)                     AS vacuum_count,
         pg_stat_get_autovacuum_count(c.oid)                 AS autovacuum_count,
         pg_stat_get_analyze_count(c.oid)                    AS analyze_count,
         pg_stat_get_autoanalyze_count(c.oid)                AS autoanalyze_count
  FROM ((pg_class c
      LEFT JOIN pg_index i ON ((c.oid = i.indrelid)))
      LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
  WHERE (c.relkind = ANY (ARRAY['r'::"char", 't'::"char", 'm'::"char"]))
  GROUP BY c.oid, n.nspname, c.relname;

create view pg_catalog.pg_stat_xact_all_tables as
  SELECT c.oid                                                    AS relid,
         n.nspname                                                AS schemaname,
         c.relname,
         pg_stat_get_xact_numscans(c.oid)                         AS seq_scan,
         pg_stat_get_xact_tuples_returned(c.oid)                  AS seq_tup_read,
         (sum(pg_stat_get_xact_numscans(i.indexrelid))) :: bigint AS idx_scan,
         ((sum(pg_stat_get_xact_tuples_fetched(i.indexrelid))) :: bigint +
          pg_stat_get_xact_tuples_fetched(c.oid))                 AS idx_tup_fetch,
         pg_stat_get_xact_tuples_inserted(c.oid)                  AS n_tup_ins,
         pg_stat_get_xact_tuples_updated(c.oid)                   AS n_tup_upd,
         pg_stat_get_xact_tuples_deleted(c.oid)                   AS n_tup_del,
         pg_stat_get_xact_tuples_hot_updated(c.oid)               AS n_tup_hot_upd
  FROM ((pg_class c
      LEFT JOIN pg_index i ON ((c.oid = i.indrelid)))
      LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
  WHERE (c.relkind = ANY (ARRAY['r'::"char", 't'::"char", 'm'::"char"]))
  GROUP BY c.oid, n.nspname, c.relname;

create view pg_catalog.pg_stat_sys_tables as
  SELECT pg_stat_all_tables.relid,
         pg_stat_all_tables.schemaname,
         pg_stat_all_tables.relname,
         pg_stat_all_tables.seq_scan,
         pg_stat_all_tables.seq_tup_read,
         pg_stat_all_tables.idx_scan,
         pg_stat_all_tables.idx_tup_fetch,
         pg_stat_all_tables.n_tup_ins,
         pg_stat_all_tables.n_tup_upd,
         pg_stat_all_tables.n_tup_del,
         pg_stat_all_tables.n_tup_hot_upd,
         pg_stat_all_tables.n_live_tup,
         pg_stat_all_tables.n_dead_tup,
         pg_stat_all_tables.n_mod_since_analyze,
         pg_stat_all_tables.last_vacuum,
         pg_stat_all_tables.last_autovacuum,
         pg_stat_all_tables.last_analyze,
         pg_stat_all_tables.last_autoanalyze,
         pg_stat_all_tables.vacuum_count,
         pg_stat_all_tables.autovacuum_count,
         pg_stat_all_tables.analyze_count,
         pg_stat_all_tables.autoanalyze_count
  FROM pg_stat_all_tables
  WHERE ((pg_stat_all_tables.schemaname = ANY (ARRAY['pg_catalog'::name, 'information_schema'::name])) OR
         (pg_stat_all_tables.schemaname ~ '^pg_toast' :: text));

create view pg_catalog.pg_stat_xact_sys_tables as
  SELECT pg_stat_xact_all_tables.relid,
         pg_stat_xact_all_tables.schemaname,
         pg_stat_xact_all_tables.relname,
         pg_stat_xact_all_tables.seq_scan,
         pg_stat_xact_all_tables.seq_tup_read,
         pg_stat_xact_all_tables.idx_scan,
         pg_stat_xact_all_tables.idx_tup_fetch,
         pg_stat_xact_all_tables.n_tup_ins,
         pg_stat_xact_all_tables.n_tup_upd,
         pg_stat_xact_all_tables.n_tup_del,
         pg_stat_xact_all_tables.n_tup_hot_upd
  FROM pg_stat_xact_all_tables
  WHERE ((pg_stat_xact_all_tables.schemaname = ANY (ARRAY['pg_catalog'::name, 'information_schema'::name])) OR
         (pg_stat_xact_all_tables.schemaname ~ '^pg_toast' :: text));

create view pg_catalog.pg_stat_user_tables as
  SELECT pg_stat_all_tables.relid,
         pg_stat_all_tables.schemaname,
         pg_stat_all_tables.relname,
         pg_stat_all_tables.seq_scan,
         pg_stat_all_tables.seq_tup_read,
         pg_stat_all_tables.idx_scan,
         pg_stat_all_tables.idx_tup_fetch,
         pg_stat_all_tables.n_tup_ins,
         pg_stat_all_tables.n_tup_upd,
         pg_stat_all_tables.n_tup_del,
         pg_stat_all_tables.n_tup_hot_upd,
         pg_stat_all_tables.n_live_tup,
         pg_stat_all_tables.n_dead_tup,
         pg_stat_all_tables.n_mod_since_analyze,
         pg_stat_all_tables.last_vacuum,
         pg_stat_all_tables.last_autovacuum,
         pg_stat_all_tables.last_analyze,
         pg_stat_all_tables.last_autoanalyze,
         pg_stat_all_tables.vacuum_count,
         pg_stat_all_tables.autovacuum_count,
         pg_stat_all_tables.analyze_count,
         pg_stat_all_tables.autoanalyze_count
  FROM pg_stat_all_tables
  WHERE ((pg_stat_all_tables.schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name])) AND
         (pg_stat_all_tables.schemaname !~ '^pg_toast' :: text));

create view pg_catalog.pg_stat_xact_user_tables as
  SELECT pg_stat_xact_all_tables.relid,
         pg_stat_xact_all_tables.schemaname,
         pg_stat_xact_all_tables.relname,
         pg_stat_xact_all_tables.seq_scan,
         pg_stat_xact_all_tables.seq_tup_read,
         pg_stat_xact_all_tables.idx_scan,
         pg_stat_xact_all_tables.idx_tup_fetch,
         pg_stat_xact_all_tables.n_tup_ins,
         pg_stat_xact_all_tables.n_tup_upd,
         pg_stat_xact_all_tables.n_tup_del,
         pg_stat_xact_all_tables.n_tup_hot_upd
  FROM pg_stat_xact_all_tables
  WHERE ((pg_stat_xact_all_tables.schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name])) AND
         (pg_stat_xact_all_tables.schemaname !~ '^pg_toast' :: text));

create view pg_catalog.pg_statio_all_tables as
  SELECT c.oid                                                               AS relid,
         n.nspname                                                           AS schemaname,
         c.relname,
         (pg_stat_get_blocks_fetched(c.oid) - pg_stat_get_blocks_hit(c.oid)) AS heap_blks_read,
         pg_stat_get_blocks_hit(c.oid)                                       AS heap_blks_hit,
         (sum((pg_stat_get_blocks_fetched(i.indexrelid) -
               pg_stat_get_blocks_hit(i.indexrelid)))) :: bigint             AS idx_blks_read,
         (sum(pg_stat_get_blocks_hit(i.indexrelid))) :: bigint               AS idx_blks_hit,
         (pg_stat_get_blocks_fetched(t.oid) - pg_stat_get_blocks_hit(t.oid)) AS toast_blks_read,
         pg_stat_get_blocks_hit(t.oid)                                       AS toast_blks_hit,
         (sum((pg_stat_get_blocks_fetched(x.indexrelid) -
               pg_stat_get_blocks_hit(x.indexrelid)))) :: bigint             AS tidx_blks_read,
         (sum(pg_stat_get_blocks_hit(x.indexrelid))) :: bigint               AS tidx_blks_hit
  FROM ((((pg_class c
      LEFT JOIN pg_index i ON ((c.oid = i.indrelid)))
      LEFT JOIN pg_class t ON ((c.reltoastrelid = t.oid)))
      LEFT JOIN pg_index x ON ((t.oid = x.indrelid)))
      LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
  WHERE (c.relkind = ANY (ARRAY['r'::"char", 't'::"char", 'm'::"char"]))
  GROUP BY c.oid, n.nspname, c.relname, t.oid, x.indrelid;

create view pg_catalog.pg_statio_sys_tables as
  SELECT pg_statio_all_tables.relid,
         pg_statio_all_tables.schemaname,
         pg_statio_all_tables.relname,
         pg_statio_all_tables.heap_blks_read,
         pg_statio_all_tables.heap_blks_hit,
         pg_statio_all_tables.idx_blks_read,
         pg_statio_all_tables.idx_blks_hit,
         pg_statio_all_tables.toast_blks_read,
         pg_statio_all_tables.toast_blks_hit,
         pg_statio_all_tables.tidx_blks_read,
         pg_statio_all_tables.tidx_blks_hit
  FROM pg_statio_all_tables
  WHERE ((pg_statio_all_tables.schemaname = ANY (ARRAY['pg_catalog'::name, 'information_schema'::name])) OR
         (pg_statio_all_tables.schemaname ~ '^pg_toast' :: text));

create view pg_catalog.pg_statio_user_tables as
  SELECT pg_statio_all_tables.relid,
         pg_statio_all_tables.schemaname,
         pg_statio_all_tables.relname,
         pg_statio_all_tables.heap_blks_read,
         pg_statio_all_tables.heap_blks_hit,
         pg_statio_all_tables.idx_blks_read,
         pg_statio_all_tables.idx_blks_hit,
         pg_statio_all_tables.toast_blks_read,
         pg_statio_all_tables.toast_blks_hit,
         pg_statio_all_tables.tidx_blks_read,
         pg_statio_all_tables.tidx_blks_hit
  FROM pg_statio_all_tables
  WHERE ((pg_statio_all_tables.schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name])) AND
         (pg_statio_all_tables.schemaname !~ '^pg_toast' :: text));

create view pg_catalog.pg_stat_all_indexes as
  SELECT c.oid                              AS relid,
         i.oid                              AS indexrelid,
         n.nspname                          AS schemaname,
         c.relname,
         i.relname                          AS indexrelname,
         pg_stat_get_numscans(i.oid)        AS idx_scan,
         pg_stat_get_tuples_returned(i.oid) AS idx_tup_read,
         pg_stat_get_tuples_fetched(i.oid)  AS idx_tup_fetch
  FROM (((pg_class c
      JOIN pg_index x ON ((c.oid = x.indrelid)))
      JOIN pg_class i ON ((i.oid = x.indexrelid)))
      LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
  WHERE (c.relkind = ANY (ARRAY['r'::"char", 't'::"char", 'm'::"char"]));

create view pg_catalog.pg_stat_sys_indexes as
  SELECT pg_stat_all_indexes.relid,
         pg_stat_all_indexes.indexrelid,
         pg_stat_all_indexes.schemaname,
         pg_stat_all_indexes.relname,
         pg_stat_all_indexes.indexrelname,
         pg_stat_all_indexes.idx_scan,
         pg_stat_all_indexes.idx_tup_read,
         pg_stat_all_indexes.idx_tup_fetch
  FROM pg_stat_all_indexes
  WHERE ((pg_stat_all_indexes.schemaname = ANY (ARRAY['pg_catalog'::name, 'information_schema'::name])) OR
         (pg_stat_all_indexes.schemaname ~ '^pg_toast' :: text));

create view pg_catalog.pg_stat_user_indexes as
  SELECT pg_stat_all_indexes.relid,
         pg_stat_all_indexes.indexrelid,
         pg_stat_all_indexes.schemaname,
         pg_stat_all_indexes.relname,
         pg_stat_all_indexes.indexrelname,
         pg_stat_all_indexes.idx_scan,
         pg_stat_all_indexes.idx_tup_read,
         pg_stat_all_indexes.idx_tup_fetch
  FROM pg_stat_all_indexes
  WHERE ((pg_stat_all_indexes.schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name])) AND
         (pg_stat_all_indexes.schemaname !~ '^pg_toast' :: text));

create view pg_catalog.pg_statio_all_indexes as
  SELECT c.oid                                                               AS relid,
         i.oid                                                               AS indexrelid,
         n.nspname                                                           AS schemaname,
         c.relname,
         i.relname                                                           AS indexrelname,
         (pg_stat_get_blocks_fetched(i.oid) - pg_stat_get_blocks_hit(i.oid)) AS idx_blks_read,
         pg_stat_get_blocks_hit(i.oid)                                       AS idx_blks_hit
  FROM (((pg_class c
      JOIN pg_index x ON ((c.oid = x.indrelid)))
      JOIN pg_class i ON ((i.oid = x.indexrelid)))
      LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
  WHERE (c.relkind = ANY (ARRAY['r'::"char", 't'::"char", 'm'::"char"]));

create view pg_catalog.pg_statio_sys_indexes as
  SELECT pg_statio_all_indexes.relid,
         pg_statio_all_indexes.indexrelid,
         pg_statio_all_indexes.schemaname,
         pg_statio_all_indexes.relname,
         pg_statio_all_indexes.indexrelname,
         pg_statio_all_indexes.idx_blks_read,
         pg_statio_all_indexes.idx_blks_hit
  FROM pg_statio_all_indexes
  WHERE ((pg_statio_all_indexes.schemaname = ANY (ARRAY['pg_catalog'::name, 'information_schema'::name])) OR
         (pg_statio_all_indexes.schemaname ~ '^pg_toast' :: text));

create view pg_catalog.pg_statio_user_indexes as
  SELECT pg_statio_all_indexes.relid,
         pg_statio_all_indexes.indexrelid,
         pg_statio_all_indexes.schemaname,
         pg_statio_all_indexes.relname,
         pg_statio_all_indexes.indexrelname,
         pg_statio_all_indexes.idx_blks_read,
         pg_statio_all_indexes.idx_blks_hit
  FROM pg_statio_all_indexes
  WHERE ((pg_statio_all_indexes.schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name])) AND
         (pg_statio_all_indexes.schemaname !~ '^pg_toast' :: text));

create view pg_catalog.pg_statio_all_sequences as
  SELECT c.oid                                                               AS relid,
         n.nspname                                                           AS schemaname,
         c.relname,
         (pg_stat_get_blocks_fetched(c.oid) - pg_stat_get_blocks_hit(c.oid)) AS blks_read,
         pg_stat_get_blocks_hit(c.oid)                                       AS blks_hit
  FROM (pg_class c
      LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
  WHERE (c.relkind = 'S' :: "char");

create view pg_catalog.pg_statio_sys_sequences as
  SELECT pg_statio_all_sequences.relid,
         pg_statio_all_sequences.schemaname,
         pg_statio_all_sequences.relname,
         pg_statio_all_sequences.blks_read,
         pg_statio_all_sequences.blks_hit
  FROM pg_statio_all_sequences
  WHERE ((pg_statio_all_sequences.schemaname = ANY (ARRAY['pg_catalog'::name, 'information_schema'::name])) OR
         (pg_statio_all_sequences.schemaname ~ '^pg_toast' :: text));

create view pg_catalog.pg_statio_user_sequences as
  SELECT pg_statio_all_sequences.relid,
         pg_statio_all_sequences.schemaname,
         pg_statio_all_sequences.relname,
         pg_statio_all_sequences.blks_read,
         pg_statio_all_sequences.blks_hit
  FROM pg_statio_all_sequences
  WHERE ((pg_statio_all_sequences.schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name])) AND
         (pg_statio_all_sequences.schemaname !~ '^pg_toast' :: text));

create view pg_catalog.pg_stat_activity as
  SELECT s.datid,
         d.datname,
         s.pid,
         s.usesysid,
         u.rolname AS usename,
         s.application_name,
         s.client_addr,
         s.client_hostname,
         s.client_port,
         s.backend_start,
         s.xact_start,
         s.query_start,
         s.state_change,
         s.wait_event_type,
         s.wait_event,
         s.state,
         s.backend_xid,
         s.backend_xmin,
         s.query,
         s.backend_type
  FROM ((pg_stat_get_activity(NULL :: integer) s(datid, pid, usesysid, application_name, state, query, wait_event_type, wait_event, xact_start, query_start, backend_start, state_change, client_addr, client_hostname, client_port, backend_xid, backend_xmin, backend_type, ssl, sslversion, sslcipher, sslbits, sslcompression, sslclientdn)
      LEFT JOIN pg_database d ON ((s.datid = d.oid)))
      LEFT JOIN pg_authid u ON ((s.usesysid = u.oid)));

create view pg_catalog.pg_stat_replication as
  SELECT s.pid,
         s.usesysid,
         u.rolname AS usename,
         s.application_name,
         s.client_addr,
         s.client_hostname,
         s.client_port,
         s.backend_start,
         s.backend_xmin,
         w.state,
         w.sent_lsn,
         w.write_lsn,
         w.flush_lsn,
         w.replay_lsn,
         w.write_lag,
         w.flush_lag,
         w.replay_lag,
         w.sync_priority,
         w.sync_state
  FROM ((pg_stat_get_activity(NULL :: integer) s(datid, pid, usesysid, application_name, state, query, wait_event_type, wait_event, xact_start, query_start, backend_start, state_change, client_addr, client_hostname, client_port, backend_xid, backend_xmin, backend_type, ssl, sslversion, sslcipher, sslbits, sslcompression, sslclientdn)
      JOIN pg_stat_get_wal_senders() w(pid, state, sent_lsn, write_lsn, flush_lsn, replay_lsn, write_lag, flush_lag, replay_lag, sync_priority, sync_state) ON ((
    s.pid = w.pid)))
      LEFT JOIN pg_authid u ON ((s.usesysid = u.oid)));

create view pg_catalog.pg_stat_wal_receiver as
  SELECT s.pid,
         s.status,
         s.receive_start_lsn,
         s.receive_start_tli,
         s.received_lsn,
         s.received_tli,
         s.last_msg_send_time,
         s.last_msg_receipt_time,
         s.latest_end_lsn,
         s.latest_end_time,
         s.slot_name,
         s.sender_host,
         s.sender_port,
         s.conninfo
  FROM pg_stat_get_wal_receiver() s (pid, status, receive_start_lsn, receive_start_tli, received_lsn, received_tli, last_msg_send_time, last_msg_receipt_time, latest_end_lsn, latest_end_time, slot_name, sender_host, sender_port, conninfo)
  WHERE (s.pid IS NOT NULL);

create view pg_catalog.pg_stat_subscription as
  SELECT su.oid AS subid,
         su.subname,
         st.pid,
         st.relid,
         st.received_lsn,
         st.last_msg_send_time,
         st.last_msg_receipt_time,
         st.latest_end_lsn,
         st.latest_end_time
  FROM (pg_subscription su
      LEFT JOIN pg_stat_get_subscription(NULL :: oid) st(subid, relid, pid, received_lsn, last_msg_send_time, last_msg_receipt_time, latest_end_lsn, latest_end_time) ON ((
    st.subid = su.oid)));

create view pg_catalog.pg_stat_ssl as
  SELECT s.pid,
         s.ssl,
         s.sslversion     AS version,
         s.sslcipher      AS cipher,
         s.sslbits        AS bits,
         s.sslcompression AS compression,
         s.sslclientdn    AS clientdn
  FROM pg_stat_get_activity(NULL :: integer) s (datid, pid, usesysid, application_name, state, query, wait_event_type, wait_event, xact_start, query_start, backend_start, state_change, client_addr, client_hostname, client_port, backend_xid, backend_xmin, backend_type, ssl, sslversion, sslcipher, sslbits, sslcompression, sslclientdn);

create view pg_catalog.pg_replication_slots as
  SELECT l.slot_name,
         l.plugin,
         l.slot_type,
         l.datoid,
         d.datname AS database,
         l.temporary,
         l.active,
         l.active_pid,
         l.xmin,
         l.catalog_xmin,
         l.restart_lsn,
         l.confirmed_flush_lsn
  FROM (pg_get_replication_slots() l(slot_name, plugin, slot_type, datoid, temporary, active, active_pid, xmin, catalog_xmin, restart_lsn, confirmed_flush_lsn)
      LEFT JOIN pg_database d ON ((l.datoid = d.oid)));

create view pg_catalog.pg_stat_database as
  SELECT d.oid                                                                     AS datid,
         d.datname,
         pg_stat_get_db_numbackends(d.oid)                                         AS numbackends,
         pg_stat_get_db_xact_commit(d.oid)                                         AS xact_commit,
         pg_stat_get_db_xact_rollback(d.oid)                                       AS xact_rollback,
         (pg_stat_get_db_blocks_fetched(d.oid) - pg_stat_get_db_blocks_hit(d.oid)) AS blks_read,
         pg_stat_get_db_blocks_hit(d.oid)                                          AS blks_hit,
         pg_stat_get_db_tuples_returned(d.oid)                                     AS tup_returned,
         pg_stat_get_db_tuples_fetched(d.oid)                                      AS tup_fetched,
         pg_stat_get_db_tuples_inserted(d.oid)                                     AS tup_inserted,
         pg_stat_get_db_tuples_updated(d.oid)                                      AS tup_updated,
         pg_stat_get_db_tuples_deleted(d.oid)                                      AS tup_deleted,
         pg_stat_get_db_conflict_all(d.oid)                                        AS conflicts,
         pg_stat_get_db_temp_files(d.oid)                                          AS temp_files,
         pg_stat_get_db_temp_bytes(d.oid)                                          AS temp_bytes,
         pg_stat_get_db_deadlocks(d.oid)                                           AS deadlocks,
         pg_stat_get_db_blk_read_time(d.oid)                                       AS blk_read_time,
         pg_stat_get_db_blk_write_time(d.oid)                                      AS blk_write_time,
         pg_stat_get_db_stat_reset_time(d.oid)                                     AS stats_reset
  FROM pg_database d;

create view pg_catalog.pg_stat_database_conflicts as
  SELECT d.oid                                           AS datid,
         d.datname,
         pg_stat_get_db_conflict_tablespace(d.oid)       AS confl_tablespace,
         pg_stat_get_db_conflict_lock(d.oid)             AS confl_lock,
         pg_stat_get_db_conflict_snapshot(d.oid)         AS confl_snapshot,
         pg_stat_get_db_conflict_bufferpin(d.oid)        AS confl_bufferpin,
         pg_stat_get_db_conflict_startup_deadlock(d.oid) AS confl_deadlock
  FROM pg_database d;

create view pg_catalog.pg_stat_user_functions as
  SELECT p.oid                                  AS funcid,
         n.nspname                              AS schemaname,
         p.proname                              AS funcname,
         pg_stat_get_function_calls(p.oid)      AS calls,
         pg_stat_get_function_total_time(p.oid) AS total_time,
         pg_stat_get_function_self_time(p.oid)  AS self_time
  FROM (pg_proc p
      LEFT JOIN pg_namespace n ON ((n.oid = p.pronamespace)))
  WHERE ((p.prolang <> (12) :: oid) AND (pg_stat_get_function_calls(p.oid) IS NOT NULL));

create view pg_catalog.pg_stat_xact_user_functions as
  SELECT p.oid                                       AS funcid,
         n.nspname                                   AS schemaname,
         p.proname                                   AS funcname,
         pg_stat_get_xact_function_calls(p.oid)      AS calls,
         pg_stat_get_xact_function_total_time(p.oid) AS total_time,
         pg_stat_get_xact_function_self_time(p.oid)  AS self_time
  FROM (pg_proc p
      LEFT JOIN pg_namespace n ON ((n.oid = p.pronamespace)))
  WHERE ((p.prolang <> (12) :: oid) AND (pg_stat_get_xact_function_calls(p.oid) IS NOT NULL));

create view pg_catalog.pg_stat_archiver as
  SELECT s.archived_count,
         s.last_archived_wal,
         s.last_archived_time,
         s.failed_count,
         s.last_failed_wal,
         s.last_failed_time,
         s.stats_reset
  FROM pg_stat_get_archiver() s (archived_count, last_archived_wal, last_archived_time, failed_count, last_failed_wal, last_failed_time, stats_reset);

create view pg_catalog.pg_stat_bgwriter as
  SELECT pg_stat_get_bgwriter_timed_checkpoints()       AS checkpoints_timed,
         pg_stat_get_bgwriter_requested_checkpoints()   AS checkpoints_req,
         pg_stat_get_checkpoint_write_time()            AS checkpoint_write_time,
         pg_stat_get_checkpoint_sync_time()             AS checkpoint_sync_time,
         pg_stat_get_bgwriter_buf_written_checkpoints() AS buffers_checkpoint,
         pg_stat_get_bgwriter_buf_written_clean()       AS buffers_clean,
         pg_stat_get_bgwriter_maxwritten_clean()        AS maxwritten_clean,
         pg_stat_get_buf_written_backend()              AS buffers_backend,
         pg_stat_get_buf_fsync_backend()                AS buffers_backend_fsync,
         pg_stat_get_buf_alloc()                        AS buffers_alloc,
         pg_stat_get_bgwriter_stat_reset_time()         AS stats_reset;

create view pg_catalog.pg_stat_progress_vacuum as
  SELECT s.pid,
         s.datid,
         d.datname,
         s.relid,
         CASE s.param1
           WHEN 0 THEN 'initializing' :: text
           WHEN 1 THEN 'scanning heap' :: text
           WHEN 2 THEN 'vacuuming indexes' :: text
           WHEN 3 THEN 'vacuuming heap' :: text
           WHEN 4 THEN 'cleaning up indexes' :: text
           WHEN 5 THEN 'truncating heap' :: text
           WHEN 6 THEN 'performing final cleanup' :: text
           ELSE NULL :: text
             END  AS phase,
         s.param2 AS heap_blks_total,
         s.param3 AS heap_blks_scanned,
         s.param4 AS heap_blks_vacuumed,
         s.param5 AS index_vacuum_count,
         s.param6 AS max_dead_tuples,
         s.param7 AS num_dead_tuples
  FROM (pg_stat_get_progress_info('VACUUM' :: text) s(pid, datid, relid, param1, param2, param3, param4, param5, param6, param7, param8, param9, param10)
      LEFT JOIN pg_database d ON ((s.datid = d.oid)));

create view pg_catalog.pg_user_mappings as
  SELECT u.oid   AS umid,
         s.oid   AS srvid,
         s.srvname,
         u.umuser,
         CASE
           WHEN (u.umuser = (0) :: oid) THEN 'public' :: name
           ELSE a.rolname
             END AS usename,
         CASE
           WHEN (((u.umuser <> (0) :: oid) AND (a.rolname = CURRENT_USER) AND
                  (pg_has_role(s.srvowner, 'USAGE' :: text) OR has_server_privilege(s.oid, 'USAGE' :: text))) OR
                 ((u.umuser = (0) :: oid) AND pg_has_role(s.srvowner, 'USAGE' :: text)) OR
                 (SELECT pg_authid.rolsuper FROM pg_authid WHERE (pg_authid.rolname = CURRENT_USER))) THEN u.umoptions
           ELSE NULL :: text []
             END AS umoptions
  FROM ((pg_user_mapping u
      JOIN pg_foreign_server s ON ((u.umserver = s.oid)))
      LEFT JOIN pg_authid a ON ((a.oid = u.umuser)));

create view pg_catalog.pg_replication_origin_status as
  SELECT pg_show_replication_origin_status.local_id,
         pg_show_replication_origin_status.external_id,
         pg_show_replication_origin_status.remote_lsn,
         pg_show_replication_origin_status.local_lsn
  FROM pg_show_replication_origin_status() pg_show_replication_origin_status (local_id, external_id, remote_lsn, local_lsn);

create view information_schema.information_schema_catalog_name as
  SELECT (current_database()) :: information_schema.sql_identifier AS catalog_name;

create view information_schema.applicable_roles as
  SELECT (a.rolname) :: information_schema.sql_identifier AS grantee,
         (b.rolname) :: information_schema.sql_identifier AS role_name,
         (
             CASE
               WHEN m.admin_option THEN 'YES' :: text
               ELSE 'NO' :: text
                 END) :: information_schema.yes_or_no     AS is_grantable
  FROM ((pg_auth_members m
      JOIN pg_authid a ON ((m.member = a.oid)))
      JOIN pg_authid b ON ((m.roleid = b.oid)))
  WHERE pg_has_role(a.oid, 'USAGE' :: text);

create view information_schema.administrable_role_authorizations as
  SELECT applicable_roles.grantee, applicable_roles.role_name, applicable_roles.is_grantable
  FROM information_schema.applicable_roles
  WHERE ((applicable_roles.is_grantable) :: text = 'YES' :: text);

create view information_schema.attributes as
  SELECT (current_database()) :: information_schema.sql_identifier                                                                           AS udt_catalog,
         (nc.nspname) :: information_schema.sql_identifier                                                                                   AS udt_schema,
         (c.relname) :: information_schema.sql_identifier                                                                                    AS udt_name,
         (a.attname) :: information_schema.sql_identifier                                                                                    AS attribute_name,
         (a.attnum) :: information_schema.cardinal_number                                                                                    AS ordinal_position,
         (pg_get_expr(ad.adbin, ad.adrelid)) :: information_schema.character_data                                                            AS attribute_default,
         (
             CASE
               WHEN (a.attnotnull OR ((t.typtype = 'd' :: "char") AND t.typnotnull)) THEN 'NO' :: text
               ELSE 'YES' :: text
                 END) :: information_schema.yes_or_no                                                                                        AS is_nullable,
         (
             CASE
               WHEN ((t.typelem <> (0) :: oid) AND (t.typlen = '-1' :: integer)) THEN 'ARRAY' :: text
               WHEN (nt.nspname = 'pg_catalog' :: name) THEN format_type(a.atttypid, NULL :: integer)
               ELSE 'USER-DEFINED' :: text
                 END) :: information_schema.character_data                                                                                   AS data_type,
         (information_schema._pg_char_max_length(information_schema._pg_truetypid(a.*, t.*),
                                                 information_schema._pg_truetypmod(a.*, t.*))) :: information_schema.cardinal_number         AS character_maximum_length,
         (information_schema._pg_char_octet_length(information_schema._pg_truetypid(a.*, t.*),
                                                   information_schema._pg_truetypmod(a.*, t.*))) :: information_schema.cardinal_number       AS character_octet_length,
         (NULL :: character varying) :: information_schema.sql_identifier                                                                    AS character_set_catalog,
         (NULL :: character varying) :: information_schema.sql_identifier                                                                    AS character_set_schema,
         (NULL :: character varying) :: information_schema.sql_identifier                                                                    AS character_set_name,
         (
             CASE
               WHEN (nco.nspname IS NOT NULL) THEN current_database()
               ELSE NULL :: name
                 END) :: information_schema.sql_identifier                                                                                   AS collation_catalog,
         (nco.nspname) :: information_schema.sql_identifier                                                                                  AS collation_schema,
         (co.collname) :: information_schema.sql_identifier                                                                                  AS collation_name,
         (information_schema._pg_numeric_precision(information_schema._pg_truetypid(a.*, t.*),
                                                   information_schema._pg_truetypmod(a.*, t.*))) :: information_schema.cardinal_number       AS numeric_precision,
         (information_schema._pg_numeric_precision_radix(information_schema._pg_truetypid(a.*, t.*),
                                                         information_schema._pg_truetypmod(a.*, t.*))) :: information_schema.cardinal_number AS numeric_precision_radix,
         (information_schema._pg_numeric_scale(information_schema._pg_truetypid(a.*, t.*),
                                               information_schema._pg_truetypmod(a.*, t.*))) :: information_schema.cardinal_number           AS numeric_scale,
         (information_schema._pg_datetime_precision(information_schema._pg_truetypid(a.*, t.*),
                                                    information_schema._pg_truetypmod(a.*, t.*))) :: information_schema.cardinal_number      AS datetime_precision,
         (information_schema._pg_interval_type(information_schema._pg_truetypid(a.*, t.*),
                                               information_schema._pg_truetypmod(a.*, t.*))) :: information_schema.character_data            AS interval_type,
         (NULL :: integer) :: information_schema.cardinal_number                                                                             AS interval_precision,
         (current_database()) :: information_schema.sql_identifier                                                                           AS attribute_udt_catalog,
         (nt.nspname) :: information_schema.sql_identifier                                                                                   AS attribute_udt_schema,
         (t.typname) :: information_schema.sql_identifier                                                                                    AS attribute_udt_name,
         (NULL :: character varying) :: information_schema.sql_identifier                                                                    AS scope_catalog,
         (NULL :: character varying) :: information_schema.sql_identifier                                                                    AS scope_schema,
         (NULL :: character varying) :: information_schema.sql_identifier                                                                    AS scope_name,
         (NULL :: integer) :: information_schema.cardinal_number                                                                             AS maximum_cardinality,
         (a.attnum) :: information_schema.sql_identifier                                                                                     AS dtd_identifier,
         ('NO' :: character varying) :: information_schema.yes_or_no                                                                         AS is_derived_reference_attribute
  FROM ((((pg_attribute a
      LEFT JOIN pg_attrdef ad ON (((a.attrelid = ad.adrelid) AND (a.attnum = ad.adnum))))
      JOIN (pg_class c
      JOIN pg_namespace nc ON ((c.relnamespace = nc.oid))) ON ((a.attrelid = c.oid)))
      JOIN (pg_type t
      JOIN pg_namespace nt ON ((t.typnamespace = nt.oid))) ON ((a.atttypid = t.oid)))
      LEFT JOIN (pg_collation co
      JOIN pg_namespace nco ON ((co.collnamespace = nco.oid))) ON (((a.attcollation = co.oid) AND
                                                                    ((nco.nspname <> 'pg_catalog' :: name) OR
                                                                     (co.collname <> 'default' :: name)))))
  WHERE ((a.attnum > 0) AND (NOT a.attisdropped) AND (c.relkind = 'c' :: "char") AND
         (pg_has_role(c.relowner, 'USAGE' :: text) OR has_type_privilege(c.reltype, 'USAGE' :: text)));

create view information_schema.character_sets as
  SELECT (NULL :: character varying) :: information_schema.sql_identifier AS character_set_catalog,
         (NULL :: character varying) :: information_schema.sql_identifier AS character_set_schema,
         (getdatabaseencoding()) :: information_schema.sql_identifier     AS character_set_name,
         (
             CASE
               WHEN (getdatabaseencoding() = 'UTF8' :: name) THEN 'UCS' :: name
               ELSE getdatabaseencoding()
                 END) :: information_schema.sql_identifier                AS character_repertoire,
         (getdatabaseencoding()) :: information_schema.sql_identifier     AS form_of_use,
         (current_database()) :: information_schema.sql_identifier        AS default_collate_catalog,
         (nc.nspname) :: information_schema.sql_identifier                AS default_collate_schema,
         (c.collname) :: information_schema.sql_identifier                AS default_collate_name
  FROM (pg_database d
      LEFT JOIN (pg_collation c
      JOIN pg_namespace nc ON ((c.collnamespace = nc.oid))) ON (((d.datcollate = c.collcollate) AND
                                                                 (d.datctype = c.collctype))))
  WHERE (d.datname = current_database())
  ORDER BY (char_length((c.collname) :: text)) DESC, c.collname
  LIMIT 1;

create view information_schema.check_constraint_routine_usage as
  SELECT (current_database()) :: information_schema.sql_identifier                                        AS constraint_catalog,
         (nc.nspname) :: information_schema.sql_identifier                                                AS constraint_schema,
         (c.conname) :: information_schema.sql_identifier                                                 AS constraint_name,
         (current_database()) :: information_schema.sql_identifier                                        AS specific_catalog,
         (np.nspname) :: information_schema.sql_identifier                                                AS specific_schema,
         ((((p.proname) :: text || '_' :: text) || (p.oid) :: text)) :: information_schema.sql_identifier AS specific_name
  FROM pg_namespace nc,
       pg_constraint c,
       pg_depend d,
       pg_proc p,
       pg_namespace np
  WHERE ((nc.oid = c.connamespace) AND (c.contype = 'c' :: "char") AND (c.oid = d.objid) AND
         (d.classid = ('pg_constraint' :: regclass) :: oid) AND (d.refobjid = p.oid) AND
         (d.refclassid = ('pg_proc' :: regclass) :: oid) AND (p.pronamespace = np.oid) AND
         pg_has_role(p.proowner, 'USAGE' :: text));

create view information_schema.check_constraints as
  SELECT (current_database()) :: information_schema.sql_identifier                            AS constraint_catalog,
         (rs.nspname) :: information_schema.sql_identifier                                    AS constraint_schema,
         (con.conname) :: information_schema.sql_identifier                                   AS constraint_name,
         ("substring"(pg_get_constraintdef(con.oid), 7)) :: information_schema.character_data AS check_clause
  FROM (((pg_constraint con
      LEFT JOIN pg_namespace rs ON ((rs.oid = con.connamespace)))
      LEFT JOIN pg_class c ON ((c.oid = con.conrelid)))
      LEFT JOIN pg_type t ON ((t.oid = con.contypid)))
  WHERE (pg_has_role(COALESCE(c.relowner, t.typowner), 'USAGE' :: text) AND (con.contype = 'c' :: "char"))
  UNION
  SELECT (current_database()) :: information_schema.sql_identifier                              AS constraint_catalog,
         (n.nspname) :: information_schema.sql_identifier                                       AS constraint_schema,
         (((((((n.oid) :: text || '_' :: text) || (r.oid) :: text) || '_' :: text) || (a.attnum) :: text) ||
           '_not_null' :: text)) :: information_schema.sql_identifier                           AS constraint_name,
         (((a.attname) :: text || ' IS NOT NULL' :: text)) :: information_schema.character_data AS check_clause
  FROM pg_namespace n,
       pg_class r,
       pg_attribute a
  WHERE ((n.oid = r.relnamespace) AND (r.oid = a.attrelid) AND (a.attnum > 0) AND (NOT a.attisdropped) AND
         a.attnotnull AND (r.relkind = ANY (ARRAY['r'::"char", 'p'::"char"])) AND
         pg_has_role(r.relowner, 'USAGE' :: text));

create view information_schema.collations as
  SELECT (current_database()) :: information_schema.sql_identifier            AS collation_catalog,
         (nc.nspname) :: information_schema.sql_identifier                    AS collation_schema,
         (c.collname) :: information_schema.sql_identifier                    AS collation_name,
         ('NO PAD' :: character varying) :: information_schema.character_data AS pad_attribute
  FROM pg_collation c,
       pg_namespace nc
  WHERE ((c.collnamespace = nc.oid) AND (c.collencoding = ANY (ARRAY['-1'::integer, ( SELECT pg_database.encoding
           FROM pg_database
          WHERE (pg_database.datname = current_database()))])));

create view information_schema.collation_character_set_applicability as
  SELECT (current_database()) :: information_schema.sql_identifier        AS collation_catalog,
         (nc.nspname) :: information_schema.sql_identifier                AS collation_schema,
         (c.collname) :: information_schema.sql_identifier                AS collation_name,
         (NULL :: character varying) :: information_schema.sql_identifier AS character_set_catalog,
         (NULL :: character varying) :: information_schema.sql_identifier AS character_set_schema,
         (getdatabaseencoding()) :: information_schema.sql_identifier     AS character_set_name
  FROM pg_collation c,
       pg_namespace nc
  WHERE ((c.collnamespace = nc.oid) AND (c.collencoding = ANY (ARRAY['-1'::integer, ( SELECT pg_database.encoding
           FROM pg_database
          WHERE (pg_database.datname = current_database()))])));

create view information_schema.column_domain_usage as
  SELECT (current_database()) :: information_schema.sql_identifier AS domain_catalog,
         (nt.nspname) :: information_schema.sql_identifier         AS domain_schema,
         (t.typname) :: information_schema.sql_identifier          AS domain_name,
         (current_database()) :: information_schema.sql_identifier AS table_catalog,
         (nc.nspname) :: information_schema.sql_identifier         AS table_schema,
         (c.relname) :: information_schema.sql_identifier          AS table_name,
         (a.attname) :: information_schema.sql_identifier          AS column_name
  FROM pg_type t,
       pg_namespace nt,
       pg_class c,
       pg_namespace nc,
       pg_attribute a
  WHERE ((t.typnamespace = nt.oid) AND (c.relnamespace = nc.oid) AND (a.attrelid = c.oid) AND (a.atttypid = t.oid) AND
         (t.typtype = 'd' :: "char") AND
         (c.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"])) AND (a.attnum > 0) AND
         (NOT a.attisdropped) AND pg_has_role(t.typowner, 'USAGE' :: text));

create view information_schema.column_privileges as
  SELECT (u_grantor.rolname) :: information_schema.sql_identifier  AS grantor,
         (grantee.rolname) :: information_schema.sql_identifier    AS grantee,
         (current_database()) :: information_schema.sql_identifier AS table_catalog,
         (nc.nspname) :: information_schema.sql_identifier         AS table_schema,
         (x.relname) :: information_schema.sql_identifier          AS table_name,
         (x.attname) :: information_schema.sql_identifier          AS column_name,
         (x.prtype) :: information_schema.character_data           AS privilege_type,
         (
             CASE
               WHEN (pg_has_role(x.grantee, x.relowner, 'USAGE' :: text) OR x.grantable) THEN 'YES' :: text
               ELSE 'NO' :: text
                 END) :: information_schema.yes_or_no              AS is_grantable
  FROM (SELECT pr_c.grantor,
               pr_c.grantee,
               a.attname,
               pr_c.relname,
               pr_c.relnamespace,
               pr_c.prtype,
               pr_c.grantable,
               pr_c.relowner
        FROM (SELECT pg_class.oid,
                     pg_class.relname,
                     pg_class.relnamespace,
                     pg_class.relowner,
                     (aclexplode(
                        COALESCE(pg_class.relacl, acldefault('r' :: "char", pg_class.relowner)))).grantor        AS grantor,
                     (aclexplode(
                        COALESCE(pg_class.relacl, acldefault('r' :: "char", pg_class.relowner)))).grantee        AS grantee,
                     (aclexplode(
                        COALESCE(pg_class.relacl, acldefault('r' :: "char", pg_class.relowner)))).privilege_type AS privilege_type,
                     (aclexplode(
                        COALESCE(pg_class.relacl, acldefault('r' :: "char", pg_class.relowner)))).is_grantable   AS is_grantable
              FROM pg_class
              WHERE (pg_class.relkind = ANY
                     (ARRAY['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"]))) pr_c (oid, relname, relnamespace, relowner, grantor, grantee, prtype, grantable),
             pg_attribute a
        WHERE ((a.attrelid = pr_c.oid) AND (a.attnum > 0) AND (NOT a.attisdropped))
        UNION
        SELECT pr_a.grantor,
               pr_a.grantee,
               pr_a.attname,
               c.relname,
               c.relnamespace,
               pr_a.prtype,
               pr_a.grantable,
               c.relowner
        FROM (SELECT a.attrelid,
                     a.attname,
                     (aclexplode(COALESCE(a.attacl, acldefault('c' :: "char", cc.relowner)))).grantor        AS grantor,
                     (aclexplode(COALESCE(a.attacl, acldefault('c' :: "char", cc.relowner)))).grantee        AS grantee,
                     (aclexplode(COALESCE(a.attacl, acldefault('c' :: "char", cc.relowner)))).privilege_type AS privilege_type,
                     (aclexplode(COALESCE(a.attacl, acldefault('c' :: "char", cc.relowner)))).is_grantable   AS is_grantable
              FROM (pg_attribute a
                  JOIN pg_class cc ON ((a.attrelid = cc.oid)))
              WHERE ((a.attnum > 0) AND (NOT a.attisdropped))) pr_a (attrelid, attname, grantor, grantee, prtype, grantable),
             pg_class c
        WHERE ((pr_a.attrelid = c.oid) AND
               (c.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"])))) x,
       pg_namespace nc,
       pg_authid u_grantor,
       (SELECT pg_authid.oid, pg_authid.rolname FROM pg_authid
        UNION ALL
        SELECT (0) :: oid AS oid, 'PUBLIC' :: name) grantee (oid, rolname)
  WHERE ((x.relnamespace = nc.oid) AND (x.grantee = grantee.oid) AND (x.grantor = u_grantor.oid) AND
         (x.prtype = ANY (ARRAY['INSERT'::text, 'SELECT'::text, 'UPDATE'::text, 'REFERENCES'::text])) AND
         (pg_has_role(u_grantor.oid, 'USAGE' :: text) OR pg_has_role(grantee.oid, 'USAGE' :: text) OR
          (grantee.rolname = 'PUBLIC' :: name)));

create view information_schema.column_udt_usage as
  SELECT (current_database()) :: information_schema.sql_identifier                AS udt_catalog,
         (COALESCE(nbt.nspname, nt.nspname)) :: information_schema.sql_identifier AS udt_schema,
         (COALESCE(bt.typname, t.typname)) :: information_schema.sql_identifier   AS udt_name,
         (current_database()) :: information_schema.sql_identifier                AS table_catalog,
         (nc.nspname) :: information_schema.sql_identifier                        AS table_schema,
         (c.relname) :: information_schema.sql_identifier                         AS table_name,
         (a.attname) :: information_schema.sql_identifier                         AS column_name
  FROM pg_attribute a,
       pg_class c,
       pg_namespace nc,
       ((pg_type t
           JOIN pg_namespace nt ON ((t.typnamespace = nt.oid)))
           LEFT JOIN (pg_type bt
           JOIN pg_namespace nbt ON ((bt.typnamespace = nbt.oid))) ON (((t.typtype = 'd' :: "char") AND
                                                                        (t.typbasetype = bt.oid))))
  WHERE ((a.attrelid = c.oid) AND (a.atttypid = t.oid) AND (nc.oid = c.relnamespace) AND (a.attnum > 0) AND
         (NOT a.attisdropped) AND (c.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"])) AND
         pg_has_role(COALESCE(bt.typowner, t.typowner), 'USAGE' :: text));

create view information_schema.columns as
  SELECT (current_database()) :: information_schema.sql_identifier                                                                           AS table_catalog,
         (nc.nspname) :: information_schema.sql_identifier                                                                                   AS table_schema,
         (c.relname) :: information_schema.sql_identifier                                                                                    AS table_name,
         (a.attname) :: information_schema.sql_identifier                                                                                    AS column_name,
         (a.attnum) :: information_schema.cardinal_number                                                                                    AS ordinal_position,
         (pg_get_expr(ad.adbin, ad.adrelid)) :: information_schema.character_data                                                            AS column_default,
         (
             CASE
               WHEN (a.attnotnull OR ((t.typtype = 'd' :: "char") AND t.typnotnull)) THEN 'NO' :: text
               ELSE 'YES' :: text
                 END) :: information_schema.yes_or_no                                                                                        AS is_nullable,
         (
             CASE
               WHEN (t.typtype = 'd' :: "char") THEN CASE
                                                       WHEN ((bt.typelem <> (0) :: oid) AND (bt.typlen = '-1' :: integer))
                                                               THEN 'ARRAY' :: text
                                                       WHEN (nbt.nspname = 'pg_catalog' :: name)
                                                               THEN format_type(t.typbasetype, NULL :: integer)
                                                       ELSE 'USER-DEFINED' :: text
                 END
               ELSE CASE
                      WHEN ((t.typelem <> (0) :: oid) AND (t.typlen = '-1' :: integer)) THEN 'ARRAY' :: text
                      WHEN (nt.nspname = 'pg_catalog' :: name) THEN format_type(a.atttypid, NULL :: integer)
                      ELSE 'USER-DEFINED' :: text
                 END
                 END) :: information_schema.character_data                                                                                   AS data_type,
         (information_schema._pg_char_max_length(information_schema._pg_truetypid(a.*, t.*),
                                                 information_schema._pg_truetypmod(a.*, t.*))) :: information_schema.cardinal_number         AS character_maximum_length,
         (information_schema._pg_char_octet_length(information_schema._pg_truetypid(a.*, t.*),
                                                   information_schema._pg_truetypmod(a.*, t.*))) :: information_schema.cardinal_number       AS character_octet_length,
         (information_schema._pg_numeric_precision(information_schema._pg_truetypid(a.*, t.*),
                                                   information_schema._pg_truetypmod(a.*, t.*))) :: information_schema.cardinal_number       AS numeric_precision,
         (information_schema._pg_numeric_precision_radix(information_schema._pg_truetypid(a.*, t.*),
                                                         information_schema._pg_truetypmod(a.*, t.*))) :: information_schema.cardinal_number AS numeric_precision_radix,
         (information_schema._pg_numeric_scale(information_schema._pg_truetypid(a.*, t.*),
                                               information_schema._pg_truetypmod(a.*, t.*))) :: information_schema.cardinal_number           AS numeric_scale,
         (information_schema._pg_datetime_precision(information_schema._pg_truetypid(a.*, t.*),
                                                    information_schema._pg_truetypmod(a.*, t.*))) :: information_schema.cardinal_number      AS datetime_precision,
         (information_schema._pg_interval_type(information_schema._pg_truetypid(a.*, t.*),
                                               information_schema._pg_truetypmod(a.*, t.*))) :: information_schema.character_data            AS interval_type,
         (NULL :: integer) :: information_schema.cardinal_number                                                                             AS interval_precision,
         (NULL :: character varying) :: information_schema.sql_identifier                                                                    AS character_set_catalog,
         (NULL :: character varying) :: information_schema.sql_identifier                                                                    AS character_set_schema,
         (NULL :: character varying) :: information_schema.sql_identifier                                                                    AS character_set_name,
         (
             CASE
               WHEN (nco.nspname IS NOT NULL) THEN current_database()
               ELSE NULL :: name
                 END) :: information_schema.sql_identifier                                                                                   AS collation_catalog,
         (nco.nspname) :: information_schema.sql_identifier                                                                                  AS collation_schema,
         (co.collname) :: information_schema.sql_identifier                                                                                  AS collation_name,
         (
             CASE
               WHEN (t.typtype = 'd' :: "char") THEN current_database()
               ELSE NULL :: name
                 END) :: information_schema.sql_identifier                                                                                   AS domain_catalog,
         (
             CASE
               WHEN (t.typtype = 'd' :: "char") THEN nt.nspname
               ELSE NULL :: name
                 END) :: information_schema.sql_identifier                                                                                   AS domain_schema,
         (
             CASE
               WHEN (t.typtype = 'd' :: "char") THEN t.typname
               ELSE NULL :: name
                 END) :: information_schema.sql_identifier                                                                                   AS domain_name,
         (current_database()) :: information_schema.sql_identifier                                                                           AS udt_catalog,
         (COALESCE(nbt.nspname, nt.nspname)) :: information_schema.sql_identifier                                                            AS udt_schema,
         (COALESCE(bt.typname, t.typname)) :: information_schema.sql_identifier                                                              AS udt_name,
         (NULL :: character varying) :: information_schema.sql_identifier                                                                    AS scope_catalog,
         (NULL :: character varying) :: information_schema.sql_identifier                                                                    AS scope_schema,
         (NULL :: character varying) :: information_schema.sql_identifier                                                                    AS scope_name,
         (NULL :: integer) :: information_schema.cardinal_number                                                                             AS maximum_cardinality,
         (a.attnum) :: information_schema.sql_identifier                                                                                     AS dtd_identifier,
         ('NO' :: character varying) :: information_schema.yes_or_no                                                                         AS is_self_referencing,
         (
             CASE
               WHEN (a.attidentity = ANY (ARRAY['a'::"char", 'd'::"char"])) THEN 'YES' :: text
               ELSE 'NO' :: text
                 END) :: information_schema.yes_or_no                                                                                        AS is_identity,
         (
             CASE a.attidentity
               WHEN 'a' :: "char" THEN 'ALWAYS' :: text
               WHEN 'd' :: "char" THEN 'BY DEFAULT' :: text
               ELSE NULL :: text
                 END) :: information_schema.character_data                                                                                   AS identity_generation,
         (seq.seqstart) :: information_schema.character_data                                                                                 AS identity_start,
         (seq.seqincrement) :: information_schema.character_data                                                                             AS identity_increment,
         (seq.seqmax) :: information_schema.character_data                                                                                   AS identity_maximum,
         (seq.seqmin) :: information_schema.character_data                                                                                   AS identity_minimum,
         (
             CASE
               WHEN seq.seqcycle THEN 'YES' :: text
               ELSE 'NO' :: text
                 END) :: information_schema.yes_or_no                                                                                        AS identity_cycle,
         ('NEVER' :: character varying) :: information_schema.character_data                                                                 AS is_generated,
         (NULL :: character varying) :: information_schema.character_data                                                                    AS generation_expression,
         (
             CASE
               WHEN ((c.relkind = ANY (ARRAY['r'::"char", 'p'::"char"])) OR
                     ((c.relkind = ANY (ARRAY['v'::"char", 'f'::"char"])) AND
                      pg_column_is_updatable((c.oid) :: regclass, a.attnum, false))) THEN 'YES' :: text
               ELSE 'NO' :: text
                 END) :: information_schema.yes_or_no                                                                                        AS is_updatable
  FROM ((((((pg_attribute a
      LEFT JOIN pg_attrdef ad ON (((a.attrelid = ad.adrelid) AND (a.attnum = ad.adnum))))
      JOIN (pg_class c
      JOIN pg_namespace nc ON ((c.relnamespace = nc.oid))) ON ((a.attrelid = c.oid)))
      JOIN (pg_type t
      JOIN pg_namespace nt ON ((t.typnamespace = nt.oid))) ON ((a.atttypid = t.oid)))
      LEFT JOIN (pg_type bt
      JOIN pg_namespace nbt ON ((bt.typnamespace = nbt.oid))) ON (((t.typtype = 'd' :: "char") AND
                                                                   (t.typbasetype = bt.oid))))
      LEFT JOIN (pg_collation co
      JOIN pg_namespace nco ON ((co.collnamespace = nco.oid))) ON (((a.attcollation = co.oid) AND
                                                                    ((nco.nspname <> 'pg_catalog' :: name) OR
                                                                     (co.collname <> 'default' :: name)))))
      LEFT JOIN (pg_depend dep
      JOIN pg_sequence seq ON (((dep.classid = ('pg_class' :: regclass) :: oid) AND (dep.objid = seq.seqrelid) AND
                                (dep.deptype = 'i' :: "char")))) ON ((
    (dep.refclassid = ('pg_class' :: regclass) :: oid) AND (dep.refobjid = c.oid) AND (dep.refobjsubid = a.attnum))))
  WHERE ((NOT pg_is_other_temp_schema(nc.oid)) AND (a.attnum > 0) AND (NOT a.attisdropped) AND
         (c.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"])) AND
         (pg_has_role(c.relowner, 'USAGE' :: text) OR
          has_column_privilege(c.oid, a.attnum, 'SELECT, INSERT, UPDATE, REFERENCES' :: text)));

create view information_schema.constraint_column_usage as
  SELECT (current_database()) :: information_schema.sql_identifier AS table_catalog,
         (x.tblschema) :: information_schema.sql_identifier        AS table_schema,
         (x.tblname) :: information_schema.sql_identifier          AS table_name,
         (x.colname) :: information_schema.sql_identifier          AS column_name,
         (current_database()) :: information_schema.sql_identifier AS constraint_catalog,
         (x.cstrschema) :: information_schema.sql_identifier       AS constraint_schema,
         (x.cstrname) :: information_schema.sql_identifier         AS constraint_name
  FROM (SELECT DISTINCT nr.nspname, r.relname, r.relowner, a.attname, nc.nspname, c.conname
        FROM pg_namespace nr,
             pg_class r,
             pg_attribute a,
             pg_depend d,
             pg_namespace nc,
             pg_constraint c
        WHERE ((nr.oid = r.relnamespace) AND (r.oid = a.attrelid) AND
               (d.refclassid = ('pg_class' :: regclass) :: oid) AND (d.refobjid = r.oid) AND
               (d.refobjsubid = a.attnum) AND (d.classid = ('pg_constraint' :: regclass) :: oid) AND
               (d.objid = c.oid) AND (c.connamespace = nc.oid) AND (c.contype = 'c' :: "char") AND
               (r.relkind = ANY (ARRAY['r'::"char", 'p'::"char"])) AND (NOT a.attisdropped))
        UNION ALL
        SELECT nr.nspname, r.relname, r.relowner, a.attname, nc.nspname, c.conname
        FROM pg_namespace nr,
             pg_class r,
             pg_attribute a,
             pg_namespace nc,
             pg_constraint c
        WHERE ((nr.oid = r.relnamespace) AND (r.oid = a.attrelid) AND (nc.oid = c.connamespace) AND (r.oid =
                                                                                                     CASE c.contype
                                                                                                       WHEN 'f' :: "char"
                                                                                                               THEN c.confrelid
                                                                                                       ELSE c.conrelid
                                                                                                         END) AND
               (a.attnum = ANY (
                   CASE c.contype
                     WHEN 'f' :: "char" THEN c.confkey
                     ELSE c.conkey
                       END)) AND (NOT a.attisdropped) AND
               (c.contype = ANY (ARRAY['p'::"char", 'u'::"char", 'f'::"char"])) AND
               (r.relkind = ANY (ARRAY['r'::"char", 'p'::"char"])))) x (tblschema, tblname, tblowner, colname, cstrschema, cstrname)
  WHERE pg_has_role(x.tblowner, 'USAGE' :: text);

create view information_schema.constraint_table_usage as
  SELECT (current_database()) :: information_schema.sql_identifier AS table_catalog,
         (nr.nspname) :: information_schema.sql_identifier         AS table_schema,
         (r.relname) :: information_schema.sql_identifier          AS table_name,
         (current_database()) :: information_schema.sql_identifier AS constraint_catalog,
         (nc.nspname) :: information_schema.sql_identifier         AS constraint_schema,
         (c.conname) :: information_schema.sql_identifier          AS constraint_name
  FROM pg_constraint c,
       pg_namespace nc,
       pg_class r,
       pg_namespace nr
  WHERE ((c.connamespace = nc.oid) AND (r.relnamespace = nr.oid) AND
         (((c.contype = 'f' :: "char") AND (c.confrelid = r.oid)) OR
          ((c.contype = ANY (ARRAY['p'::"char", 'u'::"char"])) AND (c.conrelid = r.oid))) AND
         (r.relkind = ANY (ARRAY['r'::"char", 'p'::"char"])) AND pg_has_role(r.relowner, 'USAGE' :: text));

create view information_schema.domain_constraints as
  SELECT (current_database()) :: information_schema.sql_identifier AS constraint_catalog,
         (rs.nspname) :: information_schema.sql_identifier         AS constraint_schema,
         (con.conname) :: information_schema.sql_identifier        AS constraint_name,
         (current_database()) :: information_schema.sql_identifier AS domain_catalog,
         (n.nspname) :: information_schema.sql_identifier          AS domain_schema,
         (t.typname) :: information_schema.sql_identifier          AS domain_name,
         (
             CASE
               WHEN con.condeferrable THEN 'YES' :: text
               ELSE 'NO' :: text
                 END) :: information_schema.yes_or_no              AS is_deferrable,
         (
             CASE
               WHEN con.condeferred THEN 'YES' :: text
               ELSE 'NO' :: text
                 END) :: information_schema.yes_or_no              AS initially_deferred
  FROM pg_namespace rs,
       pg_namespace n,
       pg_constraint con,
       pg_type t
  WHERE ((rs.oid = con.connamespace) AND (n.oid = t.typnamespace) AND (t.oid = con.contypid) AND
         (pg_has_role(t.typowner, 'USAGE' :: text) OR has_type_privilege(t.oid, 'USAGE' :: text)));

create view information_schema.domain_udt_usage as
  SELECT (current_database()) :: information_schema.sql_identifier AS udt_catalog,
         (nbt.nspname) :: information_schema.sql_identifier        AS udt_schema,
         (bt.typname) :: information_schema.sql_identifier         AS udt_name,
         (current_database()) :: information_schema.sql_identifier AS domain_catalog,
         (nt.nspname) :: information_schema.sql_identifier         AS domain_schema,
         (t.typname) :: information_schema.sql_identifier          AS domain_name
  FROM pg_type t,
       pg_namespace nt,
       pg_type bt,
       pg_namespace nbt
  WHERE ((t.typnamespace = nt.oid) AND (t.typbasetype = bt.oid) AND (bt.typnamespace = nbt.oid) AND
         (t.typtype = 'd' :: "char") AND pg_has_role(bt.typowner, 'USAGE' :: text));

create view information_schema.domains as
  SELECT (current_database()) :: information_schema.sql_identifier                                                     AS domain_catalog,
         (nt.nspname) :: information_schema.sql_identifier                                                             AS domain_schema,
         (t.typname) :: information_schema.sql_identifier                                                              AS domain_name,
         (
             CASE
               WHEN ((t.typelem <> (0) :: oid) AND (t.typlen = '-1' :: integer)) THEN 'ARRAY' :: text
               WHEN (nbt.nspname = 'pg_catalog' :: name) THEN format_type(t.typbasetype, NULL :: integer)
               ELSE 'USER-DEFINED' :: text
                 END) :: information_schema.character_data                                                             AS data_type,
         (information_schema._pg_char_max_length(t.typbasetype, t.typtypmod)) :: information_schema.cardinal_number    AS character_maximum_length,
         (information_schema._pg_char_octet_length(t.typbasetype, t.typtypmod)) :: information_schema.cardinal_number  AS character_octet_length,
         (NULL :: character varying) :: information_schema.sql_identifier                                              AS character_set_catalog,
         (NULL :: character varying) :: information_schema.sql_identifier                                              AS character_set_schema,
         (NULL :: character varying) :: information_schema.sql_identifier                                              AS character_set_name,
         (
             CASE
               WHEN (nco.nspname IS NOT NULL) THEN current_database()
               ELSE NULL :: name
                 END) :: information_schema.sql_identifier                                                             AS collation_catalog,
         (nco.nspname) :: information_schema.sql_identifier                                                            AS collation_schema,
         (co.collname) :: information_schema.sql_identifier                                                            AS collation_name,
         (information_schema._pg_numeric_precision(t.typbasetype, t.typtypmod)) :: information_schema.cardinal_number  AS numeric_precision,
         (information_schema._pg_numeric_precision_radix(t.typbasetype,
                                                         t.typtypmod)) :: information_schema.cardinal_number           AS numeric_precision_radix,
         (information_schema._pg_numeric_scale(t.typbasetype, t.typtypmod)) :: information_schema.cardinal_number      AS numeric_scale,
         (information_schema._pg_datetime_precision(t.typbasetype, t.typtypmod)) :: information_schema.cardinal_number AS datetime_precision,
         (information_schema._pg_interval_type(t.typbasetype, t.typtypmod)) :: information_schema.character_data       AS interval_type,
         (NULL :: integer) :: information_schema.cardinal_number                                                       AS interval_precision,
         (t.typdefault) :: information_schema.character_data                                                           AS domain_default,
         (current_database()) :: information_schema.sql_identifier                                                     AS udt_catalog,
         (nbt.nspname) :: information_schema.sql_identifier                                                            AS udt_schema,
         (bt.typname) :: information_schema.sql_identifier                                                             AS udt_name,
         (NULL :: character varying) :: information_schema.sql_identifier                                              AS scope_catalog,
         (NULL :: character varying) :: information_schema.sql_identifier                                              AS scope_schema,
         (NULL :: character varying) :: information_schema.sql_identifier                                              AS scope_name,
         (NULL :: integer) :: information_schema.cardinal_number                                                       AS maximum_cardinality,
         (1) :: information_schema.sql_identifier                                                                      AS dtd_identifier
  FROM (((pg_type t
      JOIN pg_namespace nt ON ((t.typnamespace = nt.oid)))
      JOIN (pg_type bt
      JOIN pg_namespace nbt ON ((bt.typnamespace = nbt.oid))) ON (((t.typbasetype = bt.oid) AND
                                                                   (t.typtype = 'd' :: "char"))))
      LEFT JOIN (pg_collation co
      JOIN pg_namespace nco ON ((co.collnamespace = nco.oid))) ON (((t.typcollation = co.oid) AND
                                                                    ((nco.nspname <> 'pg_catalog' :: name) OR
                                                                     (co.collname <> 'default' :: name)))))
  WHERE (pg_has_role(t.typowner, 'USAGE' :: text) OR has_type_privilege(t.oid, 'USAGE' :: text));

create view information_schema.enabled_roles as
  SELECT (a.rolname) :: information_schema.sql_identifier AS role_name
  FROM pg_authid a
  WHERE pg_has_role(a.oid, 'USAGE' :: text);

create view information_schema.key_column_usage as
  SELECT (current_database()) :: information_schema.sql_identifier AS constraint_catalog,
         (ss.nc_nspname) :: information_schema.sql_identifier      AS constraint_schema,
         (ss.conname) :: information_schema.sql_identifier         AS constraint_name,
         (current_database()) :: information_schema.sql_identifier AS table_catalog,
         (ss.nr_nspname) :: information_schema.sql_identifier      AS table_schema,
         (ss.relname) :: information_schema.sql_identifier         AS table_name,
         (a.attname) :: information_schema.sql_identifier          AS column_name,
         ((ss.x).n) :: information_schema.cardinal_number          AS ordinal_position,
         (
             CASE
               WHEN (ss.contype = 'f' :: "char")
                       THEN information_schema._pg_index_position(ss.conindid, ss.confkey [ (ss.x).n ])
               ELSE NULL :: integer
                 END) :: information_schema.cardinal_number        AS position_in_unique_constraint
  FROM pg_attribute a,
       (SELECT r.oid                                        AS roid,
               r.relname,
               r.relowner,
               nc.nspname                                   AS nc_nspname,
               nr.nspname                                   AS nr_nspname,
               c.oid                                        AS coid,
               c.conname,
               c.contype,
               c.conindid,
               c.confkey,
               c.confrelid,
               information_schema._pg_expandarray(c.conkey) AS x
        FROM pg_namespace nr,
             pg_class r,
             pg_namespace nc,
             pg_constraint c
        WHERE ((nr.oid = r.relnamespace) AND (r.oid = c.conrelid) AND (nc.oid = c.connamespace) AND
               (c.contype = ANY (ARRAY['p'::"char", 'u'::"char", 'f'::"char"])) AND
               (r.relkind = ANY (ARRAY['r'::"char", 'p'::"char"])) AND (NOT pg_is_other_temp_schema(nr.oid)))) ss
  WHERE ((ss.roid = a.attrelid) AND (a.attnum = (ss.x).x) AND (NOT a.attisdropped) AND
         (pg_has_role(ss.relowner, 'USAGE' :: text) OR
          has_column_privilege(ss.roid, a.attnum, 'SELECT, INSERT, UPDATE, REFERENCES' :: text)));

create view information_schema.parameters as
  SELECT (current_database()) :: information_schema.sql_identifier                                            AS specific_catalog,
         (ss.n_nspname) :: information_schema.sql_identifier                                                  AS specific_schema,
         ((((ss.proname) :: text || '_' :: text) || (ss.p_oid) :: text)) :: information_schema.sql_identifier AS specific_name,
         ((ss.x).n) :: information_schema.cardinal_number                                                     AS ordinal_position,
         (
             CASE
               WHEN (ss.proargmodes IS NULL) THEN 'IN' :: text
               WHEN (ss.proargmodes [ (ss.x).n ] = 'i' :: "char") THEN 'IN' :: text
               WHEN (ss.proargmodes [ (ss.x).n ] = 'o' :: "char") THEN 'OUT' :: text
               WHEN (ss.proargmodes [ (ss.x).n ] = 'b' :: "char") THEN 'INOUT' :: text
               WHEN (ss.proargmodes [ (ss.x).n ] = 'v' :: "char") THEN 'IN' :: text
               WHEN (ss.proargmodes [ (ss.x).n ] = 't' :: "char") THEN 'OUT' :: text
               ELSE NULL :: text
                 END) :: information_schema.character_data                                                    AS parameter_mode,
         ('NO' :: character varying) :: information_schema.yes_or_no                                          AS is_result,
         ('NO' :: character varying) :: information_schema.yes_or_no                                          AS as_locator,
         (NULLIF(ss.proargnames [ (ss.x).n ], '' :: text)) :: information_schema.sql_identifier               AS parameter_name,
         (
             CASE
               WHEN ((t.typelem <> (0) :: oid) AND (t.typlen = '-1' :: integer)) THEN 'ARRAY' :: text
               WHEN (nt.nspname = 'pg_catalog' :: name) THEN format_type(t.oid, NULL :: integer)
               ELSE 'USER-DEFINED' :: text
                 END) :: information_schema.character_data                                                    AS data_type,
         (NULL :: integer) :: information_schema.cardinal_number                                              AS character_maximum_length,
         (NULL :: integer) :: information_schema.cardinal_number                                              AS character_octet_length,
         (NULL :: character varying) :: information_schema.sql_identifier                                     AS character_set_catalog,
         (NULL :: character varying) :: information_schema.sql_identifier                                     AS character_set_schema,
         (NULL :: character varying) :: information_schema.sql_identifier                                     AS character_set_name,
         (NULL :: character varying) :: information_schema.sql_identifier                                     AS collation_catalog,
         (NULL :: character varying) :: information_schema.sql_identifier                                     AS collation_schema,
         (NULL :: character varying) :: information_schema.sql_identifier                                     AS collation_name,
         (NULL :: integer) :: information_schema.cardinal_number                                              AS numeric_precision,
         (NULL :: integer) :: information_schema.cardinal_number                                              AS numeric_precision_radix,
         (NULL :: integer) :: information_schema.cardinal_number                                              AS numeric_scale,
         (NULL :: integer) :: information_schema.cardinal_number                                              AS datetime_precision,
         (NULL :: character varying) :: information_schema.character_data                                     AS interval_type,
         (NULL :: integer) :: information_schema.cardinal_number                                              AS interval_precision,
         (current_database()) :: information_schema.sql_identifier                                            AS udt_catalog,
         (nt.nspname) :: information_schema.sql_identifier                                                    AS udt_schema,
         (t.typname) :: information_schema.sql_identifier                                                     AS udt_name,
         (NULL :: character varying) :: information_schema.sql_identifier                                     AS scope_catalog,
         (NULL :: character varying) :: information_schema.sql_identifier                                     AS scope_schema,
         (NULL :: character varying) :: information_schema.sql_identifier                                     AS scope_name,
         (NULL :: integer) :: information_schema.cardinal_number                                              AS maximum_cardinality,
         ((ss.x).n) :: information_schema.sql_identifier                                                      AS dtd_identifier,
         (
             CASE
               WHEN pg_has_role(ss.proowner, 'USAGE' :: text) THEN pg_get_function_arg_default(ss.p_oid, (ss.x).n)
               ELSE NULL :: text
                 END) :: information_schema.character_data                                                    AS parameter_default
  FROM pg_type t,
       pg_namespace nt,
       (SELECT n.nspname                                                                                 AS n_nspname,
               p.proname,
               p.oid                                                                                     AS p_oid,
               p.proowner,
               p.proargnames,
               p.proargmodes,
               information_schema._pg_expandarray(COALESCE(p.proallargtypes, (p.proargtypes) :: oid [])) AS x
        FROM pg_namespace n,
             pg_proc p
        WHERE ((n.oid = p.pronamespace) AND
               (pg_has_role(p.proowner, 'USAGE' :: text) OR has_function_privilege(p.oid, 'EXECUTE' :: text)))) ss
  WHERE ((t.oid = (ss.x).x) AND (t.typnamespace = nt.oid));

create view information_schema.referential_constraints as
  SELECT (current_database()) :: information_schema.sql_identifier AS constraint_catalog,
         (ncon.nspname) :: information_schema.sql_identifier       AS constraint_schema,
         (con.conname) :: information_schema.sql_identifier        AS constraint_name,
         (
             CASE
               WHEN (npkc.nspname IS NULL) THEN NULL :: name
               ELSE current_database()
                 END) :: information_schema.sql_identifier         AS unique_constraint_catalog,
         (npkc.nspname) :: information_schema.sql_identifier       AS unique_constraint_schema,
         (pkc.conname) :: information_schema.sql_identifier        AS unique_constraint_name,
         (
             CASE con.confmatchtype
               WHEN 'f' :: "char" THEN 'FULL' :: text
               WHEN 'p' :: "char" THEN 'PARTIAL' :: text
               WHEN 's' :: "char" THEN 'NONE' :: text
               ELSE NULL :: text
                 END) :: information_schema.character_data         AS match_option,
         (
             CASE con.confupdtype
               WHEN 'c' :: "char" THEN 'CASCADE' :: text
               WHEN 'n' :: "char" THEN 'SET NULL' :: text
               WHEN 'd' :: "char" THEN 'SET DEFAULT' :: text
               WHEN 'r' :: "char" THEN 'RESTRICT' :: text
               WHEN 'a' :: "char" THEN 'NO ACTION' :: text
               ELSE NULL :: text
                 END) :: information_schema.character_data         AS update_rule,
         (
             CASE con.confdeltype
               WHEN 'c' :: "char" THEN 'CASCADE' :: text
               WHEN 'n' :: "char" THEN 'SET NULL' :: text
               WHEN 'd' :: "char" THEN 'SET DEFAULT' :: text
               WHEN 'r' :: "char" THEN 'RESTRICT' :: text
               WHEN 'a' :: "char" THEN 'NO ACTION' :: text
               ELSE NULL :: text
                 END) :: information_schema.character_data         AS delete_rule
  FROM ((((((pg_namespace ncon
      JOIN pg_constraint con ON ((ncon.oid = con.connamespace)))
      JOIN pg_class c ON (((con.conrelid = c.oid) AND (con.contype = 'f' :: "char"))))
      LEFT JOIN pg_depend d1 ON (((d1.objid = con.oid) AND (d1.classid = ('pg_constraint' :: regclass) :: oid) AND
                                  (d1.refclassid = ('pg_class' :: regclass) :: oid) AND (d1.refobjsubid = 0))))
      LEFT JOIN pg_depend d2 ON ((
    (d2.refclassid = ('pg_constraint' :: regclass) :: oid) AND (d2.classid = ('pg_class' :: regclass) :: oid) AND
    (d2.objid = d1.refobjid) AND (d2.objsubid = 0) AND (d2.deptype = 'i' :: "char"))))
      LEFT JOIN pg_constraint pkc ON ((
    (pkc.oid = d2.refobjid) AND (pkc.contype = ANY (ARRAY ['p' :: "char", 'u' :: "char"])) AND
    (pkc.conrelid = con.confrelid))))
      LEFT JOIN pg_namespace npkc ON ((pkc.connamespace = npkc.oid)))
  WHERE (pg_has_role(c.relowner, 'USAGE' :: text) OR
         has_table_privilege(c.oid, 'INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER' :: text) OR
         has_any_column_privilege(c.oid, 'INSERT, UPDATE, REFERENCES' :: text));

create view information_schema.role_column_grants as
  SELECT column_privileges.grantor,
         column_privileges.grantee,
         column_privileges.table_catalog,
         column_privileges.table_schema,
         column_privileges.table_name,
         column_privileges.column_name,
         column_privileges.privilege_type,
         column_privileges.is_grantable
  FROM information_schema.column_privileges
  WHERE (((column_privileges.grantor) :: text IN
          (SELECT enabled_roles.role_name FROM information_schema.enabled_roles)) OR
         ((column_privileges.grantee) :: text IN
          (SELECT enabled_roles.role_name FROM information_schema.enabled_roles)));

create view information_schema.routine_privileges as
  SELECT (u_grantor.rolname) :: information_schema.sql_identifier                                         AS grantor,
         (grantee.rolname) :: information_schema.sql_identifier                                           AS grantee,
         (current_database()) :: information_schema.sql_identifier                                        AS specific_catalog,
         (n.nspname) :: information_schema.sql_identifier                                                 AS specific_schema,
         ((((p.proname) :: text || '_' :: text) || (p.oid) :: text)) :: information_schema.sql_identifier AS specific_name,
         (current_database()) :: information_schema.sql_identifier                                        AS routine_catalog,
         (n.nspname) :: information_schema.sql_identifier                                                 AS routine_schema,
         (p.proname) :: information_schema.sql_identifier                                                 AS routine_name,
         ('EXECUTE' :: character varying) :: information_schema.character_data                            AS privilege_type,
         (
             CASE
               WHEN (pg_has_role(grantee.oid, p.proowner, 'USAGE' :: text) OR p.grantable) THEN 'YES' :: text
               ELSE 'NO' :: text
                 END) :: information_schema.yes_or_no                                                     AS is_grantable
  FROM (SELECT pg_proc.oid,
               pg_proc.proname,
               pg_proc.proowner,
               pg_proc.pronamespace,
               (aclexplode(COALESCE(pg_proc.proacl, acldefault('f' :: "char", pg_proc.proowner)))).grantor AS grantor,
               (aclexplode(
                  COALESCE(pg_proc.proacl, acldefault('f' :: "char", pg_proc.proowner)))).grantee          AS grantee,
               (aclexplode(
                  COALESCE(pg_proc.proacl, acldefault('f' :: "char", pg_proc.proowner)))).privilege_type   AS privilege_type,
               (aclexplode(
                  COALESCE(pg_proc.proacl, acldefault('f' :: "char", pg_proc.proowner)))).is_grantable     AS is_grantable
        FROM pg_proc) p (oid, proname, proowner, pronamespace, grantor, grantee, prtype, grantable),
       pg_namespace n,
       pg_authid u_grantor,
       (SELECT pg_authid.oid, pg_authid.rolname FROM pg_authid
        UNION ALL
        SELECT (0) :: oid AS oid, 'PUBLIC' :: name) grantee (oid, rolname)
  WHERE ((p.pronamespace = n.oid) AND (grantee.oid = p.grantee) AND (u_grantor.oid = p.grantor) AND
         (p.prtype = 'EXECUTE' :: text) AND
         (pg_has_role(u_grantor.oid, 'USAGE' :: text) OR pg_has_role(grantee.oid, 'USAGE' :: text) OR
          (grantee.rolname = 'PUBLIC' :: name)));

create view information_schema.role_routine_grants as
  SELECT routine_privileges.grantor,
         routine_privileges.grantee,
         routine_privileges.specific_catalog,
         routine_privileges.specific_schema,
         routine_privileges.specific_name,
         routine_privileges.routine_catalog,
         routine_privileges.routine_schema,
         routine_privileges.routine_name,
         routine_privileges.privilege_type,
         routine_privileges.is_grantable
  FROM information_schema.routine_privileges
  WHERE (((routine_privileges.grantor) :: text IN
          (SELECT enabled_roles.role_name FROM information_schema.enabled_roles)) OR
         ((routine_privileges.grantee) :: text IN
          (SELECT enabled_roles.role_name FROM information_schema.enabled_roles)));

create view information_schema.routines as
  SELECT (current_database()) :: information_schema.sql_identifier                                        AS specific_catalog,
         (n.nspname) :: information_schema.sql_identifier                                                 AS specific_schema,
         ((((p.proname) :: text || '_' :: text) || (p.oid) :: text)) :: information_schema.sql_identifier AS specific_name,
         (current_database()) :: information_schema.sql_identifier                                        AS routine_catalog,
         (n.nspname) :: information_schema.sql_identifier                                                 AS routine_schema,
         (p.proname) :: information_schema.sql_identifier                                                 AS routine_name,
         (
             CASE p.prokind
               WHEN 'f' :: "char" THEN 'FUNCTION' :: text
               WHEN 'p' :: "char" THEN 'PROCEDURE' :: text
               ELSE NULL :: text
                 END) :: information_schema.character_data                                                AS routine_type,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS module_catalog,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS module_schema,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS module_name,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS udt_catalog,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS udt_schema,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS udt_name,
         (
             CASE
               WHEN (p.prokind = 'p' :: "char") THEN NULL :: text
               WHEN ((t.typelem <> (0) :: oid) AND (t.typlen = '-1' :: integer)) THEN 'ARRAY' :: text
               WHEN (nt.nspname = 'pg_catalog' :: name) THEN format_type(t.oid, NULL :: integer)
               ELSE 'USER-DEFINED' :: text
                 END) :: information_schema.character_data                                                AS data_type,
         (NULL :: integer) :: information_schema.cardinal_number                                          AS character_maximum_length,
         (NULL :: integer) :: information_schema.cardinal_number                                          AS character_octet_length,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS character_set_catalog,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS character_set_schema,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS character_set_name,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS collation_catalog,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS collation_schema,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS collation_name,
         (NULL :: integer) :: information_schema.cardinal_number                                          AS numeric_precision,
         (NULL :: integer) :: information_schema.cardinal_number                                          AS numeric_precision_radix,
         (NULL :: integer) :: information_schema.cardinal_number                                          AS numeric_scale,
         (NULL :: integer) :: information_schema.cardinal_number                                          AS datetime_precision,
         (NULL :: character varying) :: information_schema.character_data                                 AS interval_type,
         (NULL :: integer) :: information_schema.cardinal_number                                          AS interval_precision,
         (
             CASE
               WHEN (nt.nspname IS NOT NULL) THEN current_database()
               ELSE NULL :: name
                 END) :: information_schema.sql_identifier                                                AS type_udt_catalog,
         (nt.nspname) :: information_schema.sql_identifier                                                AS type_udt_schema,
         (t.typname) :: information_schema.sql_identifier                                                 AS type_udt_name,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS scope_catalog,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS scope_schema,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS scope_name,
         (NULL :: integer) :: information_schema.cardinal_number                                          AS maximum_cardinality,
         (
             CASE
               WHEN (p.prokind <> 'p' :: "char") THEN 0
               ELSE NULL :: integer
                 END) :: information_schema.sql_identifier                                                AS dtd_identifier,
         (
             CASE
               WHEN (l.lanname = 'sql' :: name) THEN 'SQL' :: text
               ELSE 'EXTERNAL' :: text
                 END) :: information_schema.character_data                                                AS routine_body,
         (
             CASE
               WHEN pg_has_role(p.proowner, 'USAGE' :: text) THEN p.prosrc
               ELSE NULL :: text
                 END) :: information_schema.character_data                                                AS routine_definition,
         (
             CASE
               WHEN (l.lanname = 'c' :: name) THEN p.prosrc
               ELSE NULL :: text
                 END) :: information_schema.character_data                                                AS external_name,
         (upper((l.lanname) :: text)) :: information_schema.character_data                                AS external_language,
         ('GENERAL' :: character varying) :: information_schema.character_data                            AS parameter_style,
         (
             CASE
               WHEN (p.provolatile = 'i' :: "char") THEN 'YES' :: text
               ELSE 'NO' :: text
                 END) :: information_schema.yes_or_no                                                     AS is_deterministic,
         ('MODIFIES' :: character varying) :: information_schema.character_data                           AS sql_data_access,
         (
             CASE
               WHEN (p.prokind <> 'p' :: "char") THEN CASE
                                                        WHEN p.proisstrict THEN 'YES' :: text
                                                        ELSE 'NO' :: text
                 END
               ELSE NULL :: text
                 END) :: information_schema.yes_or_no                                                     AS is_null_call,
         (NULL :: character varying) :: information_schema.character_data                                 AS sql_path,
         ('YES' :: character varying) :: information_schema.yes_or_no                                     AS schema_level_routine,
         (0) :: information_schema.cardinal_number                                                        AS max_dynamic_result_sets,
         (NULL :: character varying) :: information_schema.yes_or_no                                      AS is_user_defined_cast,
         (NULL :: character varying) :: information_schema.yes_or_no                                      AS is_implicitly_invocable,
         (
             CASE
               WHEN p.prosecdef THEN 'DEFINER' :: text
               ELSE 'INVOKER' :: text
                 END) :: information_schema.character_data                                                AS security_type,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS to_sql_specific_catalog,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS to_sql_specific_schema,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS to_sql_specific_name,
         ('NO' :: character varying) :: information_schema.yes_or_no                                      AS as_locator,
         (NULL :: timestamp with time zone) :: information_schema.time_stamp                              AS created,
         (NULL :: timestamp with time zone) :: information_schema.time_stamp                              AS last_altered,
         (NULL :: character varying) :: information_schema.yes_or_no                                      AS new_savepoint_level,
         ('NO' :: character varying) :: information_schema.yes_or_no                                      AS is_udt_dependent,
         (NULL :: character varying) :: information_schema.character_data                                 AS result_cast_from_data_type,
         (NULL :: character varying) :: information_schema.yes_or_no                                      AS result_cast_as_locator,
         (NULL :: integer) :: information_schema.cardinal_number                                          AS result_cast_char_max_length,
         (NULL :: integer) :: information_schema.cardinal_number                                          AS result_cast_char_octet_length,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS result_cast_char_set_catalog,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS result_cast_char_set_schema,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS result_cast_char_set_name,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS result_cast_collation_catalog,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS result_cast_collation_schema,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS result_cast_collation_name,
         (NULL :: integer) :: information_schema.cardinal_number                                          AS result_cast_numeric_precision,
         (NULL :: integer) :: information_schema.cardinal_number                                          AS result_cast_numeric_precision_radix,
         (NULL :: integer) :: information_schema.cardinal_number                                          AS result_cast_numeric_scale,
         (NULL :: integer) :: information_schema.cardinal_number                                          AS result_cast_datetime_precision,
         (NULL :: character varying) :: information_schema.character_data                                 AS result_cast_interval_type,
         (NULL :: integer) :: information_schema.cardinal_number                                          AS result_cast_interval_precision,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS result_cast_type_udt_catalog,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS result_cast_type_udt_schema,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS result_cast_type_udt_name,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS result_cast_scope_catalog,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS result_cast_scope_schema,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS result_cast_scope_name,
         (NULL :: integer) :: information_schema.cardinal_number                                          AS result_cast_maximum_cardinality,
         (NULL :: character varying) :: information_schema.sql_identifier                                 AS result_cast_dtd_identifier
  FROM (((pg_namespace n
      JOIN pg_proc p ON ((n.oid = p.pronamespace)))
      JOIN pg_language l ON ((p.prolang = l.oid)))
      LEFT JOIN (pg_type t
      JOIN pg_namespace nt ON ((t.typnamespace = nt.oid))) ON (((p.prorettype = t.oid) AND
                                                                (p.prokind <> 'p' :: "char"))))
  WHERE (pg_has_role(p.proowner, 'USAGE' :: text) OR has_function_privilege(p.oid, 'EXECUTE' :: text));

create view information_schema.schemata as
  SELECT (current_database()) :: information_schema.sql_identifier        AS catalog_name,
         (n.nspname) :: information_schema.sql_identifier                 AS schema_name,
         (u.rolname) :: information_schema.sql_identifier                 AS schema_owner,
         (NULL :: character varying) :: information_schema.sql_identifier AS default_character_set_catalog,
         (NULL :: character varying) :: information_schema.sql_identifier AS default_character_set_schema,
         (NULL :: character varying) :: information_schema.sql_identifier AS default_character_set_name,
         (NULL :: character varying) :: information_schema.character_data AS sql_path
  FROM pg_namespace n,
       pg_authid u
  WHERE ((n.nspowner = u.oid) AND
         (pg_has_role(n.nspowner, 'USAGE' :: text) OR has_schema_privilege(n.oid, 'CREATE, USAGE' :: text)));

create view information_schema.sequences as
  SELECT (current_database()) :: information_schema.sql_identifier                                                     AS sequence_catalog,
         (nc.nspname) :: information_schema.sql_identifier                                                             AS sequence_schema,
         (c.relname) :: information_schema.sql_identifier                                                              AS sequence_name,
         (format_type(s.seqtypid, NULL :: integer)) :: information_schema.character_data                               AS data_type,
         (information_schema._pg_numeric_precision(s.seqtypid, '-1' :: integer)) :: information_schema.cardinal_number AS numeric_precision,
         (2) :: information_schema.cardinal_number                                                                     AS numeric_precision_radix,
         (0) :: information_schema.cardinal_number                                                                     AS numeric_scale,
         (s.seqstart) :: information_schema.character_data                                                             AS start_value,
         (s.seqmin) :: information_schema.character_data                                                               AS minimum_value,
         (s.seqmax) :: information_schema.character_data                                                               AS maximum_value,
         (s.seqincrement) :: information_schema.character_data                                                         AS increment,
         (
             CASE
               WHEN s.seqcycle THEN 'YES' :: text
               ELSE 'NO' :: text
                 END) :: information_schema.yes_or_no                                                                  AS cycle_option
  FROM pg_namespace nc,
       pg_class c,
       pg_sequence s
  WHERE ((c.relnamespace = nc.oid) AND (c.relkind = 'S' :: "char") AND (NOT (EXISTS(SELECT 1
                                                                                    FROM pg_depend
                                                                                    WHERE ((pg_depend.classid = ('pg_class' :: regclass) :: oid) AND
                                                                                           (pg_depend.objid = c.oid) AND
                                                                                           (pg_depend.deptype = 'i' :: "char"))))) AND
         (NOT pg_is_other_temp_schema(nc.oid)) AND (c.oid = s.seqrelid) AND
         (pg_has_role(c.relowner, 'USAGE' :: text) OR has_sequence_privilege(c.oid, 'SELECT, UPDATE, USAGE' :: text)));

create view information_schema.table_constraints as
  SELECT (current_database()) :: information_schema.sql_identifier    AS constraint_catalog,
         (nc.nspname) :: information_schema.sql_identifier            AS constraint_schema,
         (c.conname) :: information_schema.sql_identifier             AS constraint_name,
         (current_database()) :: information_schema.sql_identifier    AS table_catalog,
         (nr.nspname) :: information_schema.sql_identifier            AS table_schema,
         (r.relname) :: information_schema.sql_identifier             AS table_name,
         (
             CASE c.contype
               WHEN 'c' :: "char" THEN 'CHECK' :: text
               WHEN 'f' :: "char" THEN 'FOREIGN KEY' :: text
               WHEN 'p' :: "char" THEN 'PRIMARY KEY' :: text
               WHEN 'u' :: "char" THEN 'UNIQUE' :: text
               ELSE NULL :: text
                 END) :: information_schema.character_data            AS constraint_type,
         (
             CASE
               WHEN c.condeferrable THEN 'YES' :: text
               ELSE 'NO' :: text
                 END) :: information_schema.yes_or_no                 AS is_deferrable,
         (
             CASE
               WHEN c.condeferred THEN 'YES' :: text
               ELSE 'NO' :: text
                 END) :: information_schema.yes_or_no                 AS initially_deferred,
         ('YES' :: character varying) :: information_schema.yes_or_no AS enforced
  FROM pg_namespace nc,
       pg_namespace nr,
       pg_constraint c,
       pg_class r
  WHERE ((nc.oid = c.connamespace) AND (nr.oid = r.relnamespace) AND (c.conrelid = r.oid) AND
         (c.contype <> ALL (ARRAY['t'::"char", 'x'::"char"])) AND
         (r.relkind = ANY (ARRAY['r'::"char", 'p'::"char"])) AND (NOT pg_is_other_temp_schema(nr.oid)) AND
         (pg_has_role(r.relowner, 'USAGE' :: text) OR
          has_table_privilege(r.oid, 'INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER' :: text) OR
          has_any_column_privilege(r.oid, 'INSERT, UPDATE, REFERENCES' :: text)))
  UNION ALL
  SELECT (current_database()) :: information_schema.sql_identifier           AS constraint_catalog,
         (nr.nspname) :: information_schema.sql_identifier                   AS constraint_schema,
         (((((((nr.oid) :: text || '_' :: text) || (r.oid) :: text) || '_' :: text) || (a.attnum) :: text) ||
           '_not_null' :: text)) :: information_schema.sql_identifier        AS constraint_name,
         (current_database()) :: information_schema.sql_identifier           AS table_catalog,
         (nr.nspname) :: information_schema.sql_identifier                   AS table_schema,
         (r.relname) :: information_schema.sql_identifier                    AS table_name,
         ('CHECK' :: character varying) :: information_schema.character_data AS constraint_type,
         ('NO' :: character varying) :: information_schema.yes_or_no         AS is_deferrable,
         ('NO' :: character varying) :: information_schema.yes_or_no         AS initially_deferred,
         ('YES' :: character varying) :: information_schema.yes_or_no        AS enforced
  FROM pg_namespace nr,
       pg_class r,
       pg_attribute a
  WHERE ((nr.oid = r.relnamespace) AND (r.oid = a.attrelid) AND a.attnotnull AND (a.attnum > 0) AND
         (NOT a.attisdropped) AND (r.relkind = ANY (ARRAY['r'::"char", 'p'::"char"])) AND
         (NOT pg_is_other_temp_schema(nr.oid)) AND (pg_has_role(r.relowner, 'USAGE' :: text) OR
                                                    has_table_privilege(r.oid,
                                                                        'INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER' :: text) OR
                                                    has_any_column_privilege(r.oid, 'INSERT, UPDATE, REFERENCES' :: text)));

create view information_schema.table_privileges as
  SELECT (u_grantor.rolname) :: information_schema.sql_identifier  AS grantor,
         (grantee.rolname) :: information_schema.sql_identifier    AS grantee,
         (current_database()) :: information_schema.sql_identifier AS table_catalog,
         (nc.nspname) :: information_schema.sql_identifier         AS table_schema,
         (c.relname) :: information_schema.sql_identifier          AS table_name,
         (c.prtype) :: information_schema.character_data           AS privilege_type,
         (
             CASE
               WHEN (pg_has_role(grantee.oid, c.relowner, 'USAGE' :: text) OR c.grantable) THEN 'YES' :: text
               ELSE 'NO' :: text
                 END) :: information_schema.yes_or_no              AS is_grantable,
         (
             CASE
               WHEN (c.prtype = 'SELECT' :: text) THEN 'YES' :: text
               ELSE 'NO' :: text
                 END) :: information_schema.yes_or_no              AS with_hierarchy
  FROM (SELECT pg_class.oid,
               pg_class.relname,
               pg_class.relnamespace,
               pg_class.relkind,
               pg_class.relowner,
               (aclexplode(COALESCE(pg_class.relacl, acldefault('r' :: "char", pg_class.relowner)))).grantor AS grantor,
               (aclexplode(
                  COALESCE(pg_class.relacl, acldefault('r' :: "char", pg_class.relowner)))).grantee          AS grantee,
               (aclexplode(
                  COALESCE(pg_class.relacl, acldefault('r' :: "char", pg_class.relowner)))).privilege_type   AS privilege_type,
               (aclexplode(
                  COALESCE(pg_class.relacl, acldefault('r' :: "char", pg_class.relowner)))).is_grantable     AS is_grantable
        FROM pg_class) c (oid, relname, relnamespace, relkind, relowner, grantor, grantee, prtype, grantable),
       pg_namespace nc,
       pg_authid u_grantor,
       (SELECT pg_authid.oid, pg_authid.rolname FROM pg_authid
        UNION ALL
        SELECT (0) :: oid AS oid, 'PUBLIC' :: name) grantee (oid, rolname)
  WHERE ((c.relnamespace = nc.oid) AND (c.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"])) AND
         (c.grantee = grantee.oid) AND (c.grantor = u_grantor.oid) AND (c.prtype = ANY
                                                                        (ARRAY['INSERT'::text, 'SELECT'::text, 'UPDATE'::text, 'DELETE'::text, 'TRUNCATE'::text, 'REFERENCES'::text, 'TRIGGER'::text])) AND
         (pg_has_role(u_grantor.oid, 'USAGE' :: text) OR pg_has_role(grantee.oid, 'USAGE' :: text) OR
          (grantee.rolname = 'PUBLIC' :: name)));

create view information_schema.role_table_grants as
  SELECT table_privileges.grantor,
         table_privileges.grantee,
         table_privileges.table_catalog,
         table_privileges.table_schema,
         table_privileges.table_name,
         table_privileges.privilege_type,
         table_privileges.is_grantable,
         table_privileges.with_hierarchy
  FROM information_schema.table_privileges
  WHERE (((table_privileges.grantor) :: text IN
          (SELECT enabled_roles.role_name FROM information_schema.enabled_roles)) OR
         ((table_privileges.grantee) :: text IN
          (SELECT enabled_roles.role_name FROM information_schema.enabled_roles)));

create view information_schema.tables as
  SELECT (current_database()) :: information_schema.sql_identifier        AS table_catalog,
         (nc.nspname) :: information_schema.sql_identifier                AS table_schema,
         (c.relname) :: information_schema.sql_identifier                 AS table_name,
         (
             CASE
               WHEN (nc.oid = pg_my_temp_schema()) THEN 'LOCAL TEMPORARY' :: text
               WHEN (c.relkind = ANY (ARRAY['r'::"char", 'p'::"char"])) THEN 'BASE TABLE' :: text
               WHEN (c.relkind = 'v' :: "char") THEN 'VIEW' :: text
               WHEN (c.relkind = 'f' :: "char") THEN 'FOREIGN' :: text
               ELSE NULL :: text
                 END) :: information_schema.character_data                AS table_type,
         (NULL :: character varying) :: information_schema.sql_identifier AS self_referencing_column_name,
         (NULL :: character varying) :: information_schema.character_data AS reference_generation,
         (
             CASE
               WHEN (t.typname IS NOT NULL) THEN current_database()
               ELSE NULL :: name
                 END) :: information_schema.sql_identifier                AS user_defined_type_catalog,
         (nt.nspname) :: information_schema.sql_identifier                AS user_defined_type_schema,
         (t.typname) :: information_schema.sql_identifier                 AS user_defined_type_name,
         (
             CASE
               WHEN ((c.relkind = ANY (ARRAY['r'::"char", 'p'::"char"])) OR
                     ((c.relkind = ANY (ARRAY['v'::"char", 'f'::"char"])) AND
                      ((pg_relation_is_updatable((c.oid) :: regclass, false) & 8) = 8))) THEN 'YES' :: text
               ELSE 'NO' :: text
                 END) :: information_schema.yes_or_no                     AS is_insertable_into,
         (
             CASE
               WHEN (t.typname IS NOT NULL) THEN 'YES' :: text
               ELSE 'NO' :: text
                 END) :: information_schema.yes_or_no                     AS is_typed,
         (NULL :: character varying) :: information_schema.character_data AS commit_action
  FROM ((pg_namespace nc
      JOIN pg_class c ON ((nc.oid = c.relnamespace)))
      LEFT JOIN (pg_type t
      JOIN pg_namespace nt ON ((t.typnamespace = nt.oid))) ON ((c.reloftype = t.oid)))
  WHERE ((c.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"])) AND
         (NOT pg_is_other_temp_schema(nc.oid)) AND (pg_has_role(c.relowner, 'USAGE' :: text) OR
                                                    has_table_privilege(c.oid,
                                                                        'SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER' :: text) OR
                                                    has_any_column_privilege(c.oid,
                                                                             'SELECT, INSERT, UPDATE, REFERENCES' :: text)));

create view information_schema.transforms as
  SELECT (current_database()) :: information_schema.sql_identifier                                        AS udt_catalog,
         (nt.nspname) :: information_schema.sql_identifier                                                AS udt_schema,
         (t.typname) :: information_schema.sql_identifier                                                 AS udt_name,
         (current_database()) :: information_schema.sql_identifier                                        AS specific_catalog,
         (np.nspname) :: information_schema.sql_identifier                                                AS specific_schema,
         ((((p.proname) :: text || '_' :: text) || (p.oid) :: text)) :: information_schema.sql_identifier AS specific_name,
         (l.lanname) :: information_schema.sql_identifier                                                 AS group_name,
         ('FROM SQL' :: character varying) :: information_schema.character_data                           AS transform_type
  FROM (((((pg_type t
      JOIN pg_transform x ON ((t.oid = x.trftype)))
      JOIN pg_language l ON ((x.trflang = l.oid)))
      JOIN pg_proc p ON (((x.trffromsql) :: oid = p.oid)))
      JOIN pg_namespace nt ON ((t.typnamespace = nt.oid)))
      JOIN pg_namespace np ON ((p.pronamespace = np.oid)))
  UNION
  SELECT (current_database()) :: information_schema.sql_identifier                                        AS udt_catalog,
         (nt.nspname) :: information_schema.sql_identifier                                                AS udt_schema,
         (t.typname) :: information_schema.sql_identifier                                                 AS udt_name,
         (current_database()) :: information_schema.sql_identifier                                        AS specific_catalog,
         (np.nspname) :: information_schema.sql_identifier                                                AS specific_schema,
         ((((p.proname) :: text || '_' :: text) || (p.oid) :: text)) :: information_schema.sql_identifier AS specific_name,
         (l.lanname) :: information_schema.sql_identifier                                                 AS group_name,
         ('TO SQL' :: character varying) :: information_schema.character_data                             AS transform_type
  FROM (((((pg_type t
      JOIN pg_transform x ON ((t.oid = x.trftype)))
      JOIN pg_language l ON ((x.trflang = l.oid)))
      JOIN pg_proc p ON (((x.trftosql) :: oid = p.oid)))
      JOIN pg_namespace nt ON ((t.typnamespace = nt.oid)))
      JOIN pg_namespace np ON ((p.pronamespace = np.oid)))
  ORDER BY 1, 2, 3, 7, 8;

create view information_schema.triggered_update_columns as
  SELECT (current_database()) :: information_schema.sql_identifier AS trigger_catalog,
         (n.nspname) :: information_schema.sql_identifier          AS trigger_schema,
         (t.tgname) :: information_schema.sql_identifier           AS trigger_name,
         (current_database()) :: information_schema.sql_identifier AS event_object_catalog,
         (n.nspname) :: information_schema.sql_identifier          AS event_object_schema,
         (c.relname) :: information_schema.sql_identifier          AS event_object_table,
         (a.attname) :: information_schema.sql_identifier          AS event_object_column
  FROM pg_namespace n,
       pg_class c,
       pg_trigger t,
       (SELECT ta0.tgoid, (ta0.tgat).x AS tgattnum, (ta0.tgat).n AS tgattpos
        FROM (SELECT pg_trigger.oid AS tgoid, information_schema._pg_expandarray(pg_trigger.tgattr) AS tgat
              FROM pg_trigger) ta0) ta,
       pg_attribute a
  WHERE ((n.oid = c.relnamespace) AND (c.oid = t.tgrelid) AND (t.oid = ta.tgoid) AND
         ((a.attrelid = t.tgrelid) AND (a.attnum = ta.tgattnum)) AND (NOT t.tgisinternal) AND
         (NOT pg_is_other_temp_schema(n.oid)) AND (pg_has_role(c.relowner, 'USAGE' :: text) OR
                                                   has_column_privilege(c.oid, a.attnum,
                                                                        'INSERT, UPDATE, REFERENCES' :: text)));

create view information_schema.triggers as
  SELECT (current_database()) :: information_schema.sql_identifier                                                                                    AS trigger_catalog,
         (n.nspname) :: information_schema.sql_identifier                                                                                             AS trigger_schema,
         (t.tgname) :: information_schema.sql_identifier                                                                                              AS trigger_name,
         (em.text) :: information_schema.character_data                                                                                               AS event_manipulation,
         (current_database()) :: information_schema.sql_identifier                                                                                    AS event_object_catalog,
         (n.nspname) :: information_schema.sql_identifier                                                                                             AS event_object_schema,
         (c.relname) :: information_schema.sql_identifier                                                                                             AS event_object_table,
         (rank() OVER (PARTITION BY n.oid, c.oid, em.num, ((t.tgtype) :: integer & 1), ((t.tgtype) :: integer &
                                                                                        66) ORDER BY t.tgname)) :: information_schema.cardinal_number AS action_order,
         (
             CASE
               WHEN pg_has_role(c.relowner, 'USAGE' :: text) THEN
                 (regexp_match(pg_get_triggerdef(t.oid), '.{35,} WHEN \((.+)\) EXECUTE PROCEDURE' :: text)) [ 1 ]
               ELSE NULL :: text
                 END) :: information_schema.character_data                                                                                            AS action_condition,
         ("substring"(pg_get_triggerdef(t.oid),
                      ("position"("substring"(pg_get_triggerdef(t.oid), 48), 'EXECUTE PROCEDURE' :: text) +
                       47))) :: information_schema.character_data                                                                                     AS action_statement,
         (
             CASE ((t.tgtype) :: integer & 1)
               WHEN 1 THEN 'ROW' :: text
               ELSE 'STATEMENT' :: text
                 END) :: information_schema.character_data                                                                                            AS action_orientation,
         (
             CASE ((t.tgtype) :: integer & 66)
               WHEN 2 THEN 'BEFORE' :: text
               WHEN 64 THEN 'INSTEAD OF' :: text
               ELSE 'AFTER' :: text
                 END) :: information_schema.character_data                                                                                            AS action_timing,
         (t.tgoldtable) :: information_schema.sql_identifier                                                                                          AS action_reference_old_table,
         (t.tgnewtable) :: information_schema.sql_identifier                                                                                          AS action_reference_new_table,
         (NULL :: character varying) :: information_schema.sql_identifier                                                                             AS action_reference_old_row,
         (NULL :: character varying) :: information_schema.sql_identifier                                                                             AS action_reference_new_row,
         (NULL :: timestamp with time zone) :: information_schema.time_stamp                                                                          AS created
  FROM pg_namespace n,
       pg_class c,
       pg_trigger t,
       (VALUES (4, 'INSERT' :: text),
               (8, 'DELETE' :: text),
               (16, 'UPDATE' :: text)) em (num, text)
  WHERE ((n.oid = c.relnamespace) AND (c.oid = t.tgrelid) AND (((t.tgtype) :: integer & em.num) <> 0) AND
         (NOT t.tgisinternal) AND (NOT pg_is_other_temp_schema(n.oid)) AND (pg_has_role(c.relowner, 'USAGE' :: text) OR
                                                                            has_table_privilege(c.oid,
                                                                                                'INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER' :: text) OR
                                                                            has_any_column_privilege(c.oid, 'INSERT, UPDATE, REFERENCES' :: text)));

create view information_schema.udt_privileges as
  SELECT (u_grantor.rolname) :: information_schema.sql_identifier                 AS grantor,
         (grantee.rolname) :: information_schema.sql_identifier                   AS grantee,
         (current_database()) :: information_schema.sql_identifier                AS udt_catalog,
         (n.nspname) :: information_schema.sql_identifier                         AS udt_schema,
         (t.typname) :: information_schema.sql_identifier                         AS udt_name,
         ('TYPE USAGE' :: character varying) :: information_schema.character_data AS privilege_type,
         (
             CASE
               WHEN (pg_has_role(grantee.oid, t.typowner, 'USAGE' :: text) OR t.grantable) THEN 'YES' :: text
               ELSE 'NO' :: text
                 END) :: information_schema.yes_or_no                             AS is_grantable
  FROM (SELECT pg_type.oid,
               pg_type.typname,
               pg_type.typnamespace,
               pg_type.typtype,
               pg_type.typowner,
               (aclexplode(COALESCE(pg_type.typacl, acldefault('T' :: "char", pg_type.typowner)))).grantor AS grantor,
               (aclexplode(
                  COALESCE(pg_type.typacl, acldefault('T' :: "char", pg_type.typowner)))).grantee          AS grantee,
               (aclexplode(
                  COALESCE(pg_type.typacl, acldefault('T' :: "char", pg_type.typowner)))).privilege_type   AS privilege_type,
               (aclexplode(
                  COALESCE(pg_type.typacl, acldefault('T' :: "char", pg_type.typowner)))).is_grantable     AS is_grantable
        FROM pg_type) t (oid, typname, typnamespace, typtype, typowner, grantor, grantee, prtype, grantable),
       pg_namespace n,
       pg_authid u_grantor,
       (SELECT pg_authid.oid, pg_authid.rolname FROM pg_authid
        UNION ALL
        SELECT (0) :: oid AS oid, 'PUBLIC' :: name) grantee (oid, rolname)
  WHERE ((t.typnamespace = n.oid) AND (t.typtype = 'c' :: "char") AND (t.grantee = grantee.oid) AND
         (t.grantor = u_grantor.oid) AND (t.prtype = 'USAGE' :: text) AND
         (pg_has_role(u_grantor.oid, 'USAGE' :: text) OR pg_has_role(grantee.oid, 'USAGE' :: text) OR
          (grantee.rolname = 'PUBLIC' :: name)));

create view information_schema.role_udt_grants as
  SELECT udt_privileges.grantor,
         udt_privileges.grantee,
         udt_privileges.udt_catalog,
         udt_privileges.udt_schema,
         udt_privileges.udt_name,
         udt_privileges.privilege_type,
         udt_privileges.is_grantable
  FROM information_schema.udt_privileges
  WHERE (((udt_privileges.grantor) :: text IN (SELECT enabled_roles.role_name FROM information_schema.enabled_roles)) OR
         ((udt_privileges.grantee) :: text IN (SELECT enabled_roles.role_name FROM information_schema.enabled_roles)));

create view information_schema.usage_privileges as
  SELECT (u.rolname) :: information_schema.sql_identifier                        AS grantor,
         ('PUBLIC' :: character varying) :: information_schema.sql_identifier    AS grantee,
         (current_database()) :: information_schema.sql_identifier               AS object_catalog,
         (n.nspname) :: information_schema.sql_identifier                        AS object_schema,
         (c.collname) :: information_schema.sql_identifier                       AS object_name,
         ('COLLATION' :: character varying) :: information_schema.character_data AS object_type,
         ('USAGE' :: character varying) :: information_schema.character_data     AS privilege_type,
         ('NO' :: character varying) :: information_schema.yes_or_no             AS is_grantable
  FROM pg_authid u,
       pg_namespace n,
       pg_collation c
  WHERE ((u.oid = c.collowner) AND (c.collnamespace = n.oid) AND (c.collencoding = ANY (ARRAY['-1'::integer, ( SELECT pg_database.encoding
           FROM pg_database
          WHERE (pg_database.datname = current_database()))])))
  UNION ALL
  SELECT (u_grantor.rolname) :: information_schema.sql_identifier             AS grantor,
         (grantee.rolname) :: information_schema.sql_identifier               AS grantee,
         (current_database()) :: information_schema.sql_identifier            AS object_catalog,
         (n.nspname) :: information_schema.sql_identifier                     AS object_schema,
         (t.typname) :: information_schema.sql_identifier                     AS object_name,
         ('DOMAIN' :: character varying) :: information_schema.character_data AS object_type,
         ('USAGE' :: character varying) :: information_schema.character_data  AS privilege_type,
         (
             CASE
               WHEN (pg_has_role(grantee.oid, t.typowner, 'USAGE' :: text) OR t.grantable) THEN 'YES' :: text
               ELSE 'NO' :: text
                 END) :: information_schema.yes_or_no                         AS is_grantable
  FROM (SELECT pg_type.oid,
               pg_type.typname,
               pg_type.typnamespace,
               pg_type.typtype,
               pg_type.typowner,
               (aclexplode(COALESCE(pg_type.typacl, acldefault('T' :: "char", pg_type.typowner)))).grantor AS grantor,
               (aclexplode(
                  COALESCE(pg_type.typacl, acldefault('T' :: "char", pg_type.typowner)))).grantee          AS grantee,
               (aclexplode(
                  COALESCE(pg_type.typacl, acldefault('T' :: "char", pg_type.typowner)))).privilege_type   AS privilege_type,
               (aclexplode(
                  COALESCE(pg_type.typacl, acldefault('T' :: "char", pg_type.typowner)))).is_grantable     AS is_grantable
        FROM pg_type) t (oid, typname, typnamespace, typtype, typowner, grantor, grantee, prtype, grantable),
       pg_namespace n,
       pg_authid u_grantor,
       (SELECT pg_authid.oid, pg_authid.rolname FROM pg_authid
        UNION ALL
        SELECT (0) :: oid AS oid, 'PUBLIC' :: name) grantee (oid, rolname)
  WHERE ((t.typnamespace = n.oid) AND (t.typtype = 'd' :: "char") AND (t.grantee = grantee.oid) AND
         (t.grantor = u_grantor.oid) AND (t.prtype = 'USAGE' :: text) AND
         (pg_has_role(u_grantor.oid, 'USAGE' :: text) OR pg_has_role(grantee.oid, 'USAGE' :: text) OR
          (grantee.rolname = 'PUBLIC' :: name)))
  UNION ALL
  SELECT (u_grantor.rolname) :: information_schema.sql_identifier                           AS grantor,
         (grantee.rolname) :: information_schema.sql_identifier                             AS grantee,
         (current_database()) :: information_schema.sql_identifier                          AS object_catalog,
         ('' :: character varying) :: information_schema.sql_identifier                     AS object_schema,
         (fdw.fdwname) :: information_schema.sql_identifier                                 AS object_name,
         ('FOREIGN DATA WRAPPER' :: character varying) :: information_schema.character_data AS object_type,
         ('USAGE' :: character varying) :: information_schema.character_data                AS privilege_type,
         (
             CASE
               WHEN (pg_has_role(grantee.oid, fdw.fdwowner, 'USAGE' :: text) OR fdw.grantable) THEN 'YES' :: text
               ELSE 'NO' :: text
                 END) :: information_schema.yes_or_no                                       AS is_grantable
  FROM (SELECT pg_foreign_data_wrapper.fdwname,
               pg_foreign_data_wrapper.fdwowner,
               (aclexplode(COALESCE(pg_foreign_data_wrapper.fdwacl,
                                    acldefault('F' :: "char", pg_foreign_data_wrapper.fdwowner)))).grantor        AS grantor,
               (aclexplode(COALESCE(pg_foreign_data_wrapper.fdwacl,
                                    acldefault('F' :: "char", pg_foreign_data_wrapper.fdwowner)))).grantee        AS grantee,
               (aclexplode(COALESCE(pg_foreign_data_wrapper.fdwacl,
                                    acldefault('F' :: "char", pg_foreign_data_wrapper.fdwowner)))).privilege_type AS privilege_type,
               (aclexplode(COALESCE(pg_foreign_data_wrapper.fdwacl,
                                    acldefault('F' :: "char", pg_foreign_data_wrapper.fdwowner)))).is_grantable   AS is_grantable
        FROM pg_foreign_data_wrapper) fdw (fdwname, fdwowner, grantor, grantee, prtype, grantable),
       pg_authid u_grantor,
       (SELECT pg_authid.oid, pg_authid.rolname FROM pg_authid
        UNION ALL
        SELECT (0) :: oid AS oid, 'PUBLIC' :: name) grantee (oid, rolname)
  WHERE ((u_grantor.oid = fdw.grantor) AND (grantee.oid = fdw.grantee) AND (fdw.prtype = 'USAGE' :: text) AND
         (pg_has_role(u_grantor.oid, 'USAGE' :: text) OR pg_has_role(grantee.oid, 'USAGE' :: text) OR
          (grantee.rolname = 'PUBLIC' :: name)))
  UNION ALL
  SELECT (u_grantor.rolname) :: information_schema.sql_identifier                     AS grantor,
         (grantee.rolname) :: information_schema.sql_identifier                       AS grantee,
         (current_database()) :: information_schema.sql_identifier                    AS object_catalog,
         ('' :: character varying) :: information_schema.sql_identifier               AS object_schema,
         (srv.srvname) :: information_schema.sql_identifier                           AS object_name,
         ('FOREIGN SERVER' :: character varying) :: information_schema.character_data AS object_type,
         ('USAGE' :: character varying) :: information_schema.character_data          AS privilege_type,
         (
             CASE
               WHEN (pg_has_role(grantee.oid, srv.srvowner, 'USAGE' :: text) OR srv.grantable) THEN 'YES' :: text
               ELSE 'NO' :: text
                 END) :: information_schema.yes_or_no                                 AS is_grantable
  FROM (SELECT pg_foreign_server.srvname,
               pg_foreign_server.srvowner,
               (aclexplode(COALESCE(pg_foreign_server.srvacl,
                                    acldefault('S' :: "char", pg_foreign_server.srvowner)))).grantor        AS grantor,
               (aclexplode(COALESCE(pg_foreign_server.srvacl,
                                    acldefault('S' :: "char", pg_foreign_server.srvowner)))).grantee        AS grantee,
               (aclexplode(COALESCE(pg_foreign_server.srvacl,
                                    acldefault('S' :: "char", pg_foreign_server.srvowner)))).privilege_type AS privilege_type,
               (aclexplode(COALESCE(pg_foreign_server.srvacl,
                                    acldefault('S' :: "char", pg_foreign_server.srvowner)))).is_grantable   AS is_grantable
        FROM pg_foreign_server) srv (srvname, srvowner, grantor, grantee, prtype, grantable),
       pg_authid u_grantor,
       (SELECT pg_authid.oid, pg_authid.rolname FROM pg_authid
        UNION ALL
        SELECT (0) :: oid AS oid, 'PUBLIC' :: name) grantee (oid, rolname)
  WHERE ((u_grantor.oid = srv.grantor) AND (grantee.oid = srv.grantee) AND (srv.prtype = 'USAGE' :: text) AND
         (pg_has_role(u_grantor.oid, 'USAGE' :: text) OR pg_has_role(grantee.oid, 'USAGE' :: text) OR
          (grantee.rolname = 'PUBLIC' :: name)))
  UNION ALL
  SELECT (u_grantor.rolname) :: information_schema.sql_identifier               AS grantor,
         (grantee.rolname) :: information_schema.sql_identifier                 AS grantee,
         (current_database()) :: information_schema.sql_identifier              AS object_catalog,
         (n.nspname) :: information_schema.sql_identifier                       AS object_schema,
         (c.relname) :: information_schema.sql_identifier                       AS object_name,
         ('SEQUENCE' :: character varying) :: information_schema.character_data AS object_type,
         ('USAGE' :: character varying) :: information_schema.character_data    AS privilege_type,
         (
             CASE
               WHEN (pg_has_role(grantee.oid, c.relowner, 'USAGE' :: text) OR c.grantable) THEN 'YES' :: text
               ELSE 'NO' :: text
                 END) :: information_schema.yes_or_no                           AS is_grantable
  FROM (SELECT pg_class.oid,
               pg_class.relname,
               pg_class.relnamespace,
               pg_class.relkind,
               pg_class.relowner,
               (aclexplode(COALESCE(pg_class.relacl, acldefault('r' :: "char", pg_class.relowner)))).grantor AS grantor,
               (aclexplode(
                  COALESCE(pg_class.relacl, acldefault('r' :: "char", pg_class.relowner)))).grantee          AS grantee,
               (aclexplode(
                  COALESCE(pg_class.relacl, acldefault('r' :: "char", pg_class.relowner)))).privilege_type   AS privilege_type,
               (aclexplode(
                  COALESCE(pg_class.relacl, acldefault('r' :: "char", pg_class.relowner)))).is_grantable     AS is_grantable
        FROM pg_class) c (oid, relname, relnamespace, relkind, relowner, grantor, grantee, prtype, grantable),
       pg_namespace n,
       pg_authid u_grantor,
       (SELECT pg_authid.oid, pg_authid.rolname FROM pg_authid
        UNION ALL
        SELECT (0) :: oid AS oid, 'PUBLIC' :: name) grantee (oid, rolname)
  WHERE ((c.relnamespace = n.oid) AND (c.relkind = 'S' :: "char") AND (c.grantee = grantee.oid) AND
         (c.grantor = u_grantor.oid) AND (c.prtype = 'USAGE' :: text) AND
         (pg_has_role(u_grantor.oid, 'USAGE' :: text) OR pg_has_role(grantee.oid, 'USAGE' :: text) OR
          (grantee.rolname = 'PUBLIC' :: name)));

create view information_schema.role_usage_grants as
  SELECT usage_privileges.grantor,
         usage_privileges.grantee,
         usage_privileges.object_catalog,
         usage_privileges.object_schema,
         usage_privileges.object_name,
         usage_privileges.object_type,
         usage_privileges.privilege_type,
         usage_privileges.is_grantable
  FROM information_schema.usage_privileges
  WHERE (((usage_privileges.grantor) :: text IN
          (SELECT enabled_roles.role_name FROM information_schema.enabled_roles)) OR
         ((usage_privileges.grantee) :: text IN
          (SELECT enabled_roles.role_name FROM information_schema.enabled_roles)));

create view information_schema.user_defined_types as
  SELECT (current_database()) :: information_schema.sql_identifier                AS user_defined_type_catalog,
         (n.nspname) :: information_schema.sql_identifier                         AS user_defined_type_schema,
         (c.relname) :: information_schema.sql_identifier                         AS user_defined_type_name,
         ('STRUCTURED' :: character varying) :: information_schema.character_data AS user_defined_type_category,
         ('YES' :: character varying) :: information_schema.yes_or_no             AS is_instantiable,
         (NULL :: character varying) :: information_schema.yes_or_no              AS is_final,
         (NULL :: character varying) :: information_schema.character_data         AS ordering_form,
         (NULL :: character varying) :: information_schema.character_data         AS ordering_category,
         (NULL :: character varying) :: information_schema.sql_identifier         AS ordering_routine_catalog,
         (NULL :: character varying) :: information_schema.sql_identifier         AS ordering_routine_schema,
         (NULL :: character varying) :: information_schema.sql_identifier         AS ordering_routine_name,
         (NULL :: character varying) :: information_schema.character_data         AS reference_type,
         (NULL :: character varying) :: information_schema.character_data         AS data_type,
         (NULL :: integer) :: information_schema.cardinal_number                  AS character_maximum_length,
         (NULL :: integer) :: information_schema.cardinal_number                  AS character_octet_length,
         (NULL :: character varying) :: information_schema.sql_identifier         AS character_set_catalog,
         (NULL :: character varying) :: information_schema.sql_identifier         AS character_set_schema,
         (NULL :: character varying) :: information_schema.sql_identifier         AS character_set_name,
         (NULL :: character varying) :: information_schema.sql_identifier         AS collation_catalog,
         (NULL :: character varying) :: information_schema.sql_identifier         AS collation_schema,
         (NULL :: character varying) :: information_schema.sql_identifier         AS collation_name,
         (NULL :: integer) :: information_schema.cardinal_number                  AS numeric_precision,
         (NULL :: integer) :: information_schema.cardinal_number                  AS numeric_precision_radix,
         (NULL :: integer) :: information_schema.cardinal_number                  AS numeric_scale,
         (NULL :: integer) :: information_schema.cardinal_number                  AS datetime_precision,
         (NULL :: character varying) :: information_schema.character_data         AS interval_type,
         (NULL :: integer) :: information_schema.cardinal_number                  AS interval_precision,
         (NULL :: character varying) :: information_schema.sql_identifier         AS source_dtd_identifier,
         (NULL :: character varying) :: information_schema.sql_identifier         AS ref_dtd_identifier
  FROM pg_namespace n,
       pg_class c,
       pg_type t
  WHERE ((n.oid = c.relnamespace) AND (t.typrelid = c.oid) AND (c.relkind = 'c' :: "char") AND
         (pg_has_role(t.typowner, 'USAGE' :: text) OR has_type_privilege(t.oid, 'USAGE' :: text)));

create view information_schema.view_column_usage as
  SELECT DISTINCT (current_database()) :: information_schema.sql_identifier AS view_catalog,
                  (nv.nspname) :: information_schema.sql_identifier         AS view_schema,
                  (v.relname) :: information_schema.sql_identifier          AS view_name,
                  (current_database()) :: information_schema.sql_identifier AS table_catalog,
                  (nt.nspname) :: information_schema.sql_identifier         AS table_schema,
                  (t.relname) :: information_schema.sql_identifier          AS table_name,
                  (a.attname) :: information_schema.sql_identifier          AS column_name
  FROM pg_namespace nv,
       pg_class v,
       pg_depend dv,
       pg_depend dt,
       pg_class t,
       pg_namespace nt,
       pg_attribute a
  WHERE ((nv.oid = v.relnamespace) AND (v.relkind = 'v' :: "char") AND (v.oid = dv.refobjid) AND
         (dv.refclassid = ('pg_class' :: regclass) :: oid) AND (dv.classid = ('pg_rewrite' :: regclass) :: oid) AND
         (dv.deptype = 'i' :: "char") AND (dv.objid = dt.objid) AND (dv.refobjid <> dt.refobjid) AND
         (dt.classid = ('pg_rewrite' :: regclass) :: oid) AND (dt.refclassid = ('pg_class' :: regclass) :: oid) AND
         (dt.refobjid = t.oid) AND (t.relnamespace = nt.oid) AND
         (t.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"])) AND (t.oid = a.attrelid) AND
         (dt.refobjsubid = a.attnum) AND pg_has_role(t.relowner, 'USAGE' :: text));

create view information_schema.view_routine_usage as
  SELECT DISTINCT (current_database()) :: information_schema.sql_identifier                                        AS table_catalog,
                  (nv.nspname) :: information_schema.sql_identifier                                                AS table_schema,
                  (v.relname) :: information_schema.sql_identifier                                                 AS table_name,
                  (current_database()) :: information_schema.sql_identifier                                        AS specific_catalog,
                  (np.nspname) :: information_schema.sql_identifier                                                AS specific_schema,
                  ((((p.proname) :: text || '_' :: text) || (p.oid) :: text)) :: information_schema.sql_identifier AS specific_name
  FROM pg_namespace nv,
       pg_class v,
       pg_depend dv,
       pg_depend dp,
       pg_proc p,
       pg_namespace np
  WHERE ((nv.oid = v.relnamespace) AND (v.relkind = 'v' :: "char") AND (v.oid = dv.refobjid) AND
         (dv.refclassid = ('pg_class' :: regclass) :: oid) AND (dv.classid = ('pg_rewrite' :: regclass) :: oid) AND
         (dv.deptype = 'i' :: "char") AND (dv.objid = dp.objid) AND (dp.classid = ('pg_rewrite' :: regclass) :: oid) AND
         (dp.refclassid = ('pg_proc' :: regclass) :: oid) AND (dp.refobjid = p.oid) AND (p.pronamespace = np.oid) AND
         pg_has_role(p.proowner, 'USAGE' :: text));

create view information_schema.view_table_usage as
  SELECT DISTINCT (current_database()) :: information_schema.sql_identifier AS view_catalog,
                  (nv.nspname) :: information_schema.sql_identifier         AS view_schema,
                  (v.relname) :: information_schema.sql_identifier          AS view_name,
                  (current_database()) :: information_schema.sql_identifier AS table_catalog,
                  (nt.nspname) :: information_schema.sql_identifier         AS table_schema,
                  (t.relname) :: information_schema.sql_identifier          AS table_name
  FROM pg_namespace nv,
       pg_class v,
       pg_depend dv,
       pg_depend dt,
       pg_class t,
       pg_namespace nt
  WHERE ((nv.oid = v.relnamespace) AND (v.relkind = 'v' :: "char") AND (v.oid = dv.refobjid) AND
         (dv.refclassid = ('pg_class' :: regclass) :: oid) AND (dv.classid = ('pg_rewrite' :: regclass) :: oid) AND
         (dv.deptype = 'i' :: "char") AND (dv.objid = dt.objid) AND (dv.refobjid <> dt.refobjid) AND
         (dt.classid = ('pg_rewrite' :: regclass) :: oid) AND (dt.refclassid = ('pg_class' :: regclass) :: oid) AND
         (dt.refobjid = t.oid) AND (t.relnamespace = nt.oid) AND
         (t.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"])) AND
         pg_has_role(t.relowner, 'USAGE' :: text));

create view information_schema.views as
  SELECT (current_database()) :: information_schema.sql_identifier AS table_catalog,
         (nc.nspname) :: information_schema.sql_identifier         AS table_schema,
         (c.relname) :: information_schema.sql_identifier          AS table_name,
         (
             CASE
               WHEN pg_has_role(c.relowner, 'USAGE' :: text) THEN pg_get_viewdef(c.oid)
               ELSE NULL :: text
                 END) :: information_schema.character_data         AS view_definition,
         (
             CASE
               WHEN ('check_option=cascaded' :: text = ANY (c.reloptions)) THEN 'CASCADED' :: text
               WHEN ('check_option=local' :: text = ANY (c.reloptions)) THEN 'LOCAL' :: text
               ELSE 'NONE' :: text
                 END) :: information_schema.character_data         AS check_option,
         (
             CASE
               WHEN ((pg_relation_is_updatable((c.oid) :: regclass, false) & 20) = 20) THEN 'YES' :: text
               ELSE 'NO' :: text
                 END) :: information_schema.yes_or_no              AS is_updatable,
         (
             CASE
               WHEN ((pg_relation_is_updatable((c.oid) :: regclass, false) & 8) = 8) THEN 'YES' :: text
               ELSE 'NO' :: text
                 END) :: information_schema.yes_or_no              AS is_insertable_into,
         (
             CASE
               WHEN (EXISTS(SELECT 1
                            FROM pg_trigger
                            WHERE ((pg_trigger.tgrelid = c.oid) AND (((pg_trigger.tgtype) :: integer & 81) = 81))))
                       THEN 'YES' :: text
               ELSE 'NO' :: text
                 END) :: information_schema.yes_or_no              AS is_trigger_updatable,
         (
             CASE
               WHEN (EXISTS(SELECT 1
                            FROM pg_trigger
                            WHERE ((pg_trigger.tgrelid = c.oid) AND (((pg_trigger.tgtype) :: integer & 73) = 73))))
                       THEN 'YES' :: text
               ELSE 'NO' :: text
                 END) :: information_schema.yes_or_no              AS is_trigger_deletable,
         (
             CASE
               WHEN (EXISTS(SELECT 1
                            FROM pg_trigger
                            WHERE ((pg_trigger.tgrelid = c.oid) AND (((pg_trigger.tgtype) :: integer & 69) = 69))))
                       THEN 'YES' :: text
               ELSE 'NO' :: text
                 END) :: information_schema.yes_or_no              AS is_trigger_insertable_into
  FROM pg_namespace nc,
       pg_class c
  WHERE ((c.relnamespace = nc.oid) AND (c.relkind = 'v' :: "char") AND (NOT pg_is_other_temp_schema(nc.oid)) AND
         (pg_has_role(c.relowner, 'USAGE' :: text) OR
          has_table_privilege(c.oid, 'SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER' :: text) OR
          has_any_column_privilege(c.oid, 'SELECT, INSERT, UPDATE, REFERENCES' :: text)));

create view information_schema.data_type_privileges as
  SELECT (current_database()) :: information_schema.sql_identifier AS object_catalog,
         x.objschema                                               AS object_schema,
         x.objname                                                 AS object_name,
         (x.objtype) :: information_schema.character_data          AS object_type,
         x.objdtdid                                                AS dtd_identifier
  FROM (SELECT attributes.udt_schema,
               attributes.udt_name,
               'USER-DEFINED TYPE' :: text AS text,
               attributes.dtd_identifier
        FROM information_schema.attributes
        UNION ALL
        SELECT columns.table_schema, columns.table_name, 'TABLE' :: text AS text, columns.dtd_identifier
        FROM information_schema.columns
        UNION ALL
        SELECT domains.domain_schema, domains.domain_name, 'DOMAIN' :: text AS text, domains.dtd_identifier
        FROM information_schema.domains
        UNION ALL
        SELECT parameters.specific_schema,
               parameters.specific_name,
               'ROUTINE' :: text AS text,
               parameters.dtd_identifier
        FROM information_schema.parameters
        UNION ALL
        SELECT routines.specific_schema, routines.specific_name, 'ROUTINE' :: text AS text, routines.dtd_identifier
        FROM information_schema.routines) x (objschema, objname, objtype, objdtdid);

create view information_schema.element_types as
  SELECT (current_database()) :: information_schema.sql_identifier                    AS object_catalog,
         (n.nspname) :: information_schema.sql_identifier                             AS object_schema,
         x.objname                                                                    AS object_name,
         (x.objtype) :: information_schema.character_data                             AS object_type,
         (x.objdtdid) :: information_schema.sql_identifier                            AS collection_type_identifier,
         (
             CASE
               WHEN (nbt.nspname = 'pg_catalog' :: name) THEN format_type(bt.oid, NULL :: integer)
               ELSE 'USER-DEFINED' :: text
                 END) :: information_schema.character_data                            AS data_type,
         (NULL :: integer) :: information_schema.cardinal_number                      AS character_maximum_length,
         (NULL :: integer) :: information_schema.cardinal_number                      AS character_octet_length,
         (NULL :: character varying) :: information_schema.sql_identifier             AS character_set_catalog,
         (NULL :: character varying) :: information_schema.sql_identifier             AS character_set_schema,
         (NULL :: character varying) :: information_schema.sql_identifier             AS character_set_name,
         (
             CASE
               WHEN (nco.nspname IS NOT NULL) THEN current_database()
               ELSE NULL :: name
                 END) :: information_schema.sql_identifier                            AS collation_catalog,
         (nco.nspname) :: information_schema.sql_identifier                           AS collation_schema,
         (co.collname) :: information_schema.sql_identifier                           AS collation_name,
         (NULL :: integer) :: information_schema.cardinal_number                      AS numeric_precision,
         (NULL :: integer) :: information_schema.cardinal_number                      AS numeric_precision_radix,
         (NULL :: integer) :: information_schema.cardinal_number                      AS numeric_scale,
         (NULL :: integer) :: information_schema.cardinal_number                      AS datetime_precision,
         (NULL :: character varying) :: information_schema.character_data             AS interval_type,
         (NULL :: integer) :: information_schema.cardinal_number                      AS interval_precision,
         (NULL :: character varying) :: information_schema.character_data             AS domain_default,
         (current_database()) :: information_schema.sql_identifier                    AS udt_catalog,
         (nbt.nspname) :: information_schema.sql_identifier                           AS udt_schema,
         (bt.typname) :: information_schema.sql_identifier                            AS udt_name,
         (NULL :: character varying) :: information_schema.sql_identifier             AS scope_catalog,
         (NULL :: character varying) :: information_schema.sql_identifier             AS scope_schema,
         (NULL :: character varying) :: information_schema.sql_identifier             AS scope_name,
         (NULL :: integer) :: information_schema.cardinal_number                      AS maximum_cardinality,
         (('a' :: text || (x.objdtdid) :: text)) :: information_schema.sql_identifier AS dtd_identifier
  FROM pg_namespace n,
       pg_type at,
       pg_namespace nbt,
       pg_type bt,
       ((SELECT c.relnamespace,
                (c.relname) :: information_schema.sql_identifier AS relname,
                CASE
                  WHEN (c.relkind = 'c' :: "char") THEN 'USER-DEFINED TYPE' :: text
                  ELSE 'TABLE' :: text
                    END                                          AS "case",
                a.attnum,
                a.atttypid,
                a.attcollation
         FROM pg_class c,
              pg_attribute a
         WHERE ((c.oid = a.attrelid) AND
                (c.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'f'::"char", 'c'::"char", 'p'::"char"])) AND
                (a.attnum > 0) AND (NOT a.attisdropped))
         UNION ALL
         SELECT t.typnamespace,
                (t.typname) :: information_schema.sql_identifier AS typname,
                'DOMAIN' :: text                                 AS text,
                1,
                t.typbasetype,
                t.typcollation
         FROM pg_type t
         WHERE (t.typtype = 'd' :: "char")
         UNION ALL
         SELECT ss.pronamespace,
                ((((ss.proname) :: text || '_' :: text) || (ss.oid) :: text)) :: information_schema.sql_identifier AS sql_identifier,
                'ROUTINE' :: text                                                                                  AS text,
                (ss.x).n                                                                                           AS n,
                (ss.x).x                                                                                           AS x,
                0
         FROM (SELECT p.pronamespace,
                      p.proname,
                      p.oid,
                      information_schema._pg_expandarray(COALESCE(p.proallargtypes, (p.proargtypes) :: oid [])) AS x
               FROM pg_proc p) ss
         UNION ALL
         SELECT p.pronamespace,
                ((((p.proname) :: text || '_' :: text) || (p.oid) :: text)) :: information_schema.sql_identifier AS sql_identifier,
                'ROUTINE' :: text                                                                                AS text,
                0,
                p.prorettype,
                0
         FROM pg_proc p) x(objschema, objname, objtype, objdtdid, objtypeid, objcollation)
           LEFT JOIN (pg_collation co
           JOIN pg_namespace nco ON ((co.collnamespace = nco.oid))) ON (((x.objcollation = co.oid) AND
                                                                         ((nco.nspname <> 'pg_catalog' :: name) OR
                                                                          (co.collname <> 'default' :: name)))))
  WHERE ((n.oid = x.objschema) AND (at.oid = x.objtypeid) AND
         ((at.typelem <> (0) :: oid) AND (at.typlen = '-1' :: integer)) AND (at.typelem = bt.oid) AND
         (nbt.oid = bt.typnamespace) AND
         ((n.nspname, (x.objname) :: text, x.objtype, ((x.objdtdid) :: information_schema.sql_identifier) :: text) IN
          (SELECT data_type_privileges.object_schema,
                  data_type_privileges.object_name,
                  data_type_privileges.object_type,
                  data_type_privileges.dtd_identifier
           FROM information_schema.data_type_privileges)));

create view information_schema."_pg_foreign_table_columns" as
  SELECT n.nspname, c.relname, a.attname, a.attfdwoptions
  FROM pg_foreign_table t,
       pg_authid u,
       pg_namespace n,
       pg_class c,
       pg_attribute a
  WHERE ((u.oid = c.relowner) AND (pg_has_role(c.relowner, 'USAGE' :: text) OR has_column_privilege(c.oid, a.attnum,
                                                                                                    'SELECT, INSERT, UPDATE, REFERENCES' :: text)) AND
         (n.oid = c.relnamespace) AND (c.oid = t.ftrelid) AND (c.relkind = 'f' :: "char") AND (a.attrelid = c.oid) AND
         (a.attnum > 0));

create view information_schema.column_options as
  SELECT (current_database()) :: information_schema.sql_identifier                                  AS table_catalog,
         (c.nspname) :: information_schema.sql_identifier                                           AS table_schema,
         (c.relname) :: information_schema.sql_identifier                                           AS table_name,
         (c.attname) :: information_schema.sql_identifier                                           AS column_name,
         ((pg_options_to_table(c.attfdwoptions)).option_name) :: information_schema.sql_identifier  AS option_name,
         ((pg_options_to_table(c.attfdwoptions)).option_value) :: information_schema.character_data AS option_value
  FROM information_schema._pg_foreign_table_columns c;

create view information_schema."_pg_foreign_data_wrappers" as
  SELECT w.oid,
         w.fdwowner,
         w.fdwoptions,
         (current_database()) :: information_schema.sql_identifier       AS foreign_data_wrapper_catalog,
         (w.fdwname) :: information_schema.sql_identifier                AS foreign_data_wrapper_name,
         (u.rolname) :: information_schema.sql_identifier                AS authorization_identifier,
         ('c' :: character varying) :: information_schema.character_data AS foreign_data_wrapper_language
  FROM pg_foreign_data_wrapper w,
       pg_authid u
  WHERE ((u.oid = w.fdwowner) AND
         (pg_has_role(w.fdwowner, 'USAGE' :: text) OR has_foreign_data_wrapper_privilege(w.oid, 'USAGE' :: text)));

create view information_schema.foreign_data_wrapper_options as
  SELECT w.foreign_data_wrapper_catalog,
         w.foreign_data_wrapper_name,
         ((pg_options_to_table(w.fdwoptions)).option_name) :: information_schema.sql_identifier  AS option_name,
         ((pg_options_to_table(w.fdwoptions)).option_value) :: information_schema.character_data AS option_value
  FROM information_schema._pg_foreign_data_wrappers w;

create view information_schema.foreign_data_wrappers as
  SELECT w.foreign_data_wrapper_catalog,
         w.foreign_data_wrapper_name,
         w.authorization_identifier,
         (NULL :: character varying) :: information_schema.character_data AS library_name,
         w.foreign_data_wrapper_language
  FROM information_schema._pg_foreign_data_wrappers w;

create view information_schema."_pg_foreign_servers" as
  SELECT s.oid,
         s.srvoptions,
         (current_database()) :: information_schema.sql_identifier AS foreign_server_catalog,
         (s.srvname) :: information_schema.sql_identifier          AS foreign_server_name,
         (current_database()) :: information_schema.sql_identifier AS foreign_data_wrapper_catalog,
         (w.fdwname) :: information_schema.sql_identifier          AS foreign_data_wrapper_name,
         (s.srvtype) :: information_schema.character_data          AS foreign_server_type,
         (s.srvversion) :: information_schema.character_data       AS foreign_server_version,
         (u.rolname) :: information_schema.sql_identifier          AS authorization_identifier
  FROM pg_foreign_server s,
       pg_foreign_data_wrapper w,
       pg_authid u
  WHERE ((w.oid = s.srvfdw) AND (u.oid = s.srvowner) AND
         (pg_has_role(s.srvowner, 'USAGE' :: text) OR has_server_privilege(s.oid, 'USAGE' :: text)));

create view information_schema.foreign_server_options as
  SELECT s.foreign_server_catalog,
         s.foreign_server_name,
         ((pg_options_to_table(s.srvoptions)).option_name) :: information_schema.sql_identifier  AS option_name,
         ((pg_options_to_table(s.srvoptions)).option_value) :: information_schema.character_data AS option_value
  FROM information_schema._pg_foreign_servers s;

create view information_schema.foreign_servers as
  SELECT _pg_foreign_servers.foreign_server_catalog,
         _pg_foreign_servers.foreign_server_name,
         _pg_foreign_servers.foreign_data_wrapper_catalog,
         _pg_foreign_servers.foreign_data_wrapper_name,
         _pg_foreign_servers.foreign_server_type,
         _pg_foreign_servers.foreign_server_version,
         _pg_foreign_servers.authorization_identifier
  FROM information_schema._pg_foreign_servers;

create view information_schema."_pg_foreign_tables" as
  SELECT (current_database()) :: information_schema.sql_identifier AS foreign_table_catalog,
         (n.nspname) :: information_schema.sql_identifier          AS foreign_table_schema,
         (c.relname) :: information_schema.sql_identifier          AS foreign_table_name,
         t.ftoptions,
         (current_database()) :: information_schema.sql_identifier AS foreign_server_catalog,
         (s.srvname) :: information_schema.sql_identifier          AS foreign_server_name,
         (u.rolname) :: information_schema.sql_identifier          AS authorization_identifier
  FROM pg_foreign_table t,
       pg_foreign_server s,
       pg_foreign_data_wrapper w,
       pg_authid u,
       pg_namespace n,
       pg_class c
  WHERE ((w.oid = s.srvfdw) AND (u.oid = c.relowner) AND (pg_has_role(c.relowner, 'USAGE' :: text) OR
                                                          has_table_privilege(c.oid,
                                                                              'SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER' :: text) OR
                                                          has_any_column_privilege(c.oid,
                                                                                   'SELECT, INSERT, UPDATE, REFERENCES' :: text)) AND
         (n.oid = c.relnamespace) AND (c.oid = t.ftrelid) AND (c.relkind = 'f' :: "char") AND (s.oid = t.ftserver));

create view information_schema.foreign_table_options as
  SELECT t.foreign_table_catalog,
         t.foreign_table_schema,
         t.foreign_table_name,
         ((pg_options_to_table(t.ftoptions)).option_name) :: information_schema.sql_identifier  AS option_name,
         ((pg_options_to_table(t.ftoptions)).option_value) :: information_schema.character_data AS option_value
  FROM information_schema._pg_foreign_tables t;

create view information_schema.foreign_tables as
  SELECT _pg_foreign_tables.foreign_table_catalog,
         _pg_foreign_tables.foreign_table_schema,
         _pg_foreign_tables.foreign_table_name,
         _pg_foreign_tables.foreign_server_catalog,
         _pg_foreign_tables.foreign_server_name
  FROM information_schema._pg_foreign_tables;

create view information_schema."_pg_user_mappings" as
  SELECT um.oid,
         um.umoptions,
         um.umuser,
         (COALESCE(u.rolname, 'PUBLIC' :: name)) :: information_schema.sql_identifier AS authorization_identifier,
         s.foreign_server_catalog,
         s.foreign_server_name,
         s.authorization_identifier                                                   AS srvowner
  FROM (pg_user_mapping um
      LEFT JOIN pg_authid u ON ((u.oid = um.umuser))),
       information_schema._pg_foreign_servers s
  WHERE (s.oid = um.umserver);

create view information_schema.user_mapping_options as
  SELECT um.authorization_identifier,
         um.foreign_server_catalog,
         um.foreign_server_name,
         (opts.option_name) :: information_schema.sql_identifier AS option_name,
         (
             CASE
               WHEN (((um.umuser <> (0) :: oid) AND ((um.authorization_identifier) :: name = CURRENT_USER)) OR
                     ((um.umuser = (0) :: oid) AND pg_has_role((um.srvowner) :: name, 'USAGE' :: text)) OR
                     (SELECT pg_authid.rolsuper FROM pg_authid WHERE (pg_authid.rolname = CURRENT_USER)))
                       THEN opts.option_value
               ELSE NULL :: text
                 END) :: information_schema.character_data       AS option_value
  FROM information_schema._pg_user_mappings um,
       LATERAL pg_options_to_table(um.umoptions) opts (option_name, option_value);

create view information_schema.user_mappings as
  SELECT _pg_user_mappings.authorization_identifier,
         _pg_user_mappings.foreign_server_catalog,
         _pg_user_mappings.foreign_server_name
  FROM information_schema._pg_user_mappings;

create function pg_catalog.byteaout(bytea)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.byteaout
;

comment on function pg_catalog.byteaout(bytea)
is 'I/O';

create function pg_catalog.charout("char")
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.charout
;

comment on function pg_catalog.charout("char")
is 'I/O';

create function pg_catalog.namein(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.namein
;

comment on function pg_catalog.namein(cstring)
is 'I/O';

create function pg_catalog.nameout(name)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.nameout
;

comment on function pg_catalog.nameout(name)
is 'I/O';

create function pg_catalog.int2in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2in
;

comment on function pg_catalog.int2in(cstring)
is 'I/O';

create function pg_catalog.int2out(smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2out
;

comment on function pg_catalog.int2out(smallint)
is 'I/O';

create function pg_catalog.int2vectorin(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2vectorin
;

comment on function pg_catalog.int2vectorin(cstring)
is 'I/O';

create function pg_catalog.int2vectorout(int2vector)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2vectorout
;

comment on function pg_catalog.int2vectorout(int2vector)
is 'I/O';

create function pg_catalog.int4in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4in
;

comment on function pg_catalog.int4in(cstring)
is 'I/O';

create function pg_catalog.int4out(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4out
;

comment on function pg_catalog.int4out(integer)
is 'I/O';

create function pg_catalog.regprocin(cstring)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regprocin
;

comment on function pg_catalog.regprocin(cstring)
is 'I/O';

create function pg_catalog.regprocout(regproc)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regprocout
;

comment on function pg_catalog.regprocout(regproc)
is 'I/O';

create function pg_catalog.textin(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.textin
;

comment on function pg_catalog.textin(cstring)
is 'I/O';

create function pg_catalog.textout(text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.textout
;

comment on function pg_catalog.textout(text)
is 'I/O';

create function pg_catalog.tidin(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tidin
;

comment on function pg_catalog.tidin(cstring)
is 'I/O';

create function pg_catalog.tidout(tid)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tidout
;

comment on function pg_catalog.tidout(tid)
is 'I/O';

create function pg_catalog.xidin(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.xidin
;

comment on function pg_catalog.xidin(cstring)
is 'I/O';

create function pg_catalog.xidout(xid)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.xidout
;

comment on function pg_catalog.xidout(xid)
is 'I/O';

create function pg_catalog.cidin(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cidin
;

comment on function pg_catalog.cidin(cstring)
is 'I/O';

create function pg_catalog.cidout(cid)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cidout
;

comment on function pg_catalog.cidout(cid)
is 'I/O';

create function pg_catalog.oidvectorin(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.oidvectorin
;

comment on function pg_catalog.oidvectorin(cstring)
is 'I/O';

create function pg_catalog.oidvectorout(oidvector)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.oidvectorout
;

comment on function pg_catalog.oidvectorout(oidvector)
is 'I/O';

create function pg_catalog.boollt(boolean, boolean)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.boollt
;

comment on function pg_catalog.boollt(boolean, boolean)
is 'implementation of < operator';

create function pg_catalog.boolgt(boolean, boolean)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.boolgt
;

comment on function pg_catalog.boolgt(boolean, boolean)
is 'implementation of > operator';

create function pg_catalog.booleq(boolean, boolean)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.booleq
;

comment on function pg_catalog.booleq(boolean, boolean)
is 'implementation of = operator';

create function pg_catalog.chareq("char", "char")
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.chareq
;

comment on function pg_catalog.chareq("char", "char")
is 'implementation of = operator';

create function pg_catalog.nameeq(name, name)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.nameeq
;

comment on function pg_catalog.nameeq(name, name)
is 'implementation of = operator';

create function pg_catalog.int2eq(smallint, smallint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2eq
;

comment on function pg_catalog.int2eq(smallint, smallint)
is 'implementation of = operator';

create function pg_catalog.int2lt(smallint, smallint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2lt
;

comment on function pg_catalog.int2lt(smallint, smallint)
is 'implementation of < operator';

create function pg_catalog.int4eq(integer, integer)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4eq
;

comment on function pg_catalog.int4eq(integer, integer)
is 'implementation of = operator';

create function pg_catalog.int4lt(integer, integer)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4lt
;

comment on function pg_catalog.int4lt(integer, integer)
is 'implementation of < operator';

create function pg_catalog.texteq(text, text)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.texteq
;

comment on function pg_catalog.texteq(text, text)
is 'implementation of = operator';

create function pg_catalog.xideq(xid, xid)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.xideq
;

comment on function pg_catalog.xideq(xid, xid)
is 'implementation of = operator';

create function pg_catalog.cideq(cid, cid)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cideq
;

comment on function pg_catalog.cideq(cid, cid)
is 'implementation of = operator';

create function pg_catalog.charne("char", "char")
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.charne
;

comment on function pg_catalog.charne("char", "char")
is 'implementation of <> operator';

create function pg_catalog.charle("char", "char")
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.charle
;

comment on function pg_catalog.charle("char", "char")
is 'implementation of <= operator';

create function pg_catalog.chargt("char", "char")
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.chargt
;

comment on function pg_catalog.chargt("char", "char")
is 'implementation of > operator';

create function pg_catalog.charge("char", "char")
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.charge
;

comment on function pg_catalog.charge("char", "char")
is 'implementation of >= operator';

create function pg_catalog.int4("char")
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4
;

comment on function pg_catalog.int4("char")
is 'convert char to int4';

create function pg_catalog.char(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.char
;

comment on function pg_catalog.char(integer)
is 'convert int4 to char';

create function pg_catalog.nameregexeq(name, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.nameregexeq
;

comment on function pg_catalog.nameregexeq(name, text)
is 'implementation of ~ operator';

create function pg_catalog.boolne(boolean, boolean)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.boolne
;

comment on function pg_catalog.boolne(boolean, boolean)
is 'implementation of <> operator';

create function pg_catalog.pg_ddl_command_in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_ddl_command_in
;

comment on function pg_catalog.pg_ddl_command_in(cstring)
is 'I/O';

create function pg_catalog.pg_ddl_command_out(pg_ddl_command)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_ddl_command_out
;

comment on function pg_catalog.pg_ddl_command_out(pg_ddl_command)
is 'I/O';

create function pg_catalog.pg_ddl_command_recv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_ddl_command_recv
;

comment on function pg_catalog.pg_ddl_command_recv(internal)
is 'I/O';

create function pg_catalog.version()
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.version
;

comment on function pg_catalog.version()
is 'PostgreSQL version string';

create function pg_catalog.pg_ddl_command_send(pg_ddl_command)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_ddl_command_send
;

comment on function pg_catalog.pg_ddl_command_send(pg_ddl_command)
is 'I/O';

create function pg_catalog.eqsel(internal, oid, internal, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.eqsel
;

comment on function pg_catalog.eqsel(internal, oid, internal, integer)
is 'restriction selectivity of = and related operators';

create function pg_catalog.neqsel(internal, oid, internal, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.neqsel
;

comment on function pg_catalog.neqsel(internal, oid, internal, integer)
is 'restriction selectivity of <> and related operators';

create function pg_catalog.scalarltsel(internal, oid, internal, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.scalarltsel
;

comment on function pg_catalog.scalarltsel(internal, oid, internal, integer)
is 'restriction selectivity of < and related operators on scalar datatypes';

create function pg_catalog.scalargtsel(internal, oid, internal, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.scalargtsel
;

comment on function pg_catalog.scalargtsel(internal, oid, internal, integer)
is 'restriction selectivity of > and related operators on scalar datatypes';

create function pg_catalog.eqjoinsel(internal, oid, internal, smallint, internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.eqjoinsel
;

comment on function pg_catalog.eqjoinsel(internal, oid, internal, smallint, internal)
is 'join selectivity of = and related operators';

create function pg_catalog.neqjoinsel(internal, oid, internal, smallint, internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.neqjoinsel
;

comment on function pg_catalog.neqjoinsel(internal, oid, internal, smallint, internal)
is 'join selectivity of <> and related operators';

create function pg_catalog.scalarltjoinsel(internal, oid, internal, smallint, internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.scalarltjoinsel
;

comment on function pg_catalog.scalarltjoinsel(internal, oid, internal, smallint, internal)
is 'join selectivity of < and related operators on scalar datatypes';

create function pg_catalog.scalargtjoinsel(internal, oid, internal, smallint, internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.scalargtjoinsel
;

comment on function pg_catalog.scalargtjoinsel(internal, oid, internal, smallint, internal)
is 'join selectivity of > and related operators on scalar datatypes';

create function pg_catalog.unknownin(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.unknownin
;

comment on function pg_catalog.unknownin(cstring)
is 'I/O';

create function pg_catalog.unknownout(unknown)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.unknownout
;

comment on function pg_catalog.unknownout(unknown)
is 'I/O';

create function pg_catalog.numeric_fac(bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_fac
;

comment on function pg_catalog.numeric_fac(bigint)
is 'implementation of ! operator';

create function pg_catalog.box_above_eq(box, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_above_eq
;

comment on function pg_catalog.box_above_eq(box, box)
is 'implementation of >^ operator';

create function pg_catalog.box_below_eq(box, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_below_eq
;

comment on function pg_catalog.box_below_eq(box, box)
is 'implementation of <^ operator';

create function pg_catalog.point_in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.point_in
;

comment on function pg_catalog.point_in(cstring)
is 'I/O';

create function pg_catalog.point_out(point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.point_out
;

comment on function pg_catalog.point_out(point)
is 'I/O';

create function pg_catalog.lseg_in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lseg_in
;

comment on function pg_catalog.lseg_in(cstring)
is 'I/O';

create function pg_catalog.lseg_out(lseg)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lseg_out
;

comment on function pg_catalog.lseg_out(lseg)
is 'I/O';

create function pg_catalog.path_in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.path_in
;

comment on function pg_catalog.path_in(cstring)
is 'I/O';

create function pg_catalog.path_out(path)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.path_out
;

comment on function pg_catalog.path_out(path)
is 'I/O';

create function pg_catalog.box_in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_in
;

comment on function pg_catalog.box_in(cstring)
is 'I/O';

create function pg_catalog.box_out(box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_out
;

comment on function pg_catalog.box_out(box)
is 'I/O';

create function pg_catalog.box_overlap(box, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_overlap
;

comment on function pg_catalog.box_overlap(box, box)
is 'implementation of && operator';

create function pg_catalog.box_ge(box, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_ge
;

comment on function pg_catalog.box_ge(box, box)
is 'implementation of >= operator';

create function pg_catalog.box_gt(box, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_gt
;

comment on function pg_catalog.box_gt(box, box)
is 'implementation of > operator';

create function pg_catalog.box_eq(box, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_eq
;

comment on function pg_catalog.box_eq(box, box)
is 'implementation of = operator';

create function pg_catalog.box_lt(box, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_lt
;

comment on function pg_catalog.box_lt(box, box)
is 'implementation of < operator';

create function pg_catalog.box_le(box, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_le
;

comment on function pg_catalog.box_le(box, box)
is 'implementation of <= operator';

create function pg_catalog.point_above(point, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.point_above
;

comment on function pg_catalog.point_above(point, point)
is 'implementation of >^ operator';

create function pg_catalog.point_left(point, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.point_left
;

comment on function pg_catalog.point_left(point, point)
is 'implementation of << operator';

create function pg_catalog.point_right(point, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.point_right
;

comment on function pg_catalog.point_right(point, point)
is 'implementation of >> operator';

create function pg_catalog.point_below(point, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.point_below
;

comment on function pg_catalog.point_below(point, point)
is 'implementation of <^ operator';

create function pg_catalog.point_eq(point, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.point_eq
;

comment on function pg_catalog.point_eq(point, point)
is 'implementation of ~= operator';

create function pg_catalog.on_pb(point, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.on_pb
;

comment on function pg_catalog.on_pb(point, box)
is 'implementation of <@ operator';

create function pg_catalog.on_ppath(point, path)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.on_ppath
;

comment on function pg_catalog.on_ppath(point, path)
is 'implementation of <@ operator';

create function pg_catalog.box_center(box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_center
;

comment on function pg_catalog.box_center(box)
is 'implementation of @@ operator';

create function pg_catalog.areasel(internal, oid, internal, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.areasel
;

comment on function pg_catalog.areasel(internal, oid, internal, integer)
is 'restriction selectivity for area-comparison operators';

create function pg_catalog.areajoinsel(internal, oid, internal, smallint, internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.areajoinsel
;

comment on function pg_catalog.areajoinsel(internal, oid, internal, smallint, internal)
is 'join selectivity for area-comparison operators';

create function pg_catalog.int4mul(integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4mul
;

comment on function pg_catalog.int4mul(integer, integer)
is 'implementation of * operator';

create function pg_catalog.int4ne(integer, integer)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4ne
;

comment on function pg_catalog.int4ne(integer, integer)
is 'implementation of <> operator';

create function pg_catalog.int2ne(smallint, smallint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2ne
;

comment on function pg_catalog.int2ne(smallint, smallint)
is 'implementation of <> operator';

create function pg_catalog.int2gt(smallint, smallint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2gt
;

comment on function pg_catalog.int2gt(smallint, smallint)
is 'implementation of > operator';

create function pg_catalog.int4gt(integer, integer)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4gt
;

comment on function pg_catalog.int4gt(integer, integer)
is 'implementation of > operator';

create function pg_catalog.int2le(smallint, smallint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2le
;

comment on function pg_catalog.int2le(smallint, smallint)
is 'implementation of <= operator';

create function pg_catalog.int4le(integer, integer)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4le
;

comment on function pg_catalog.int4le(integer, integer)
is 'implementation of <= operator';

create function pg_catalog.int4ge(integer, integer)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4ge
;

comment on function pg_catalog.int4ge(integer, integer)
is 'implementation of >= operator';

create function pg_catalog.int2ge(smallint, smallint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2ge
;

comment on function pg_catalog.int2ge(smallint, smallint)
is 'implementation of >= operator';

create function pg_catalog.int2mul(smallint, smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2mul
;

comment on function pg_catalog.int2mul(smallint, smallint)
is 'implementation of * operator';

create function pg_catalog.int2div(smallint, smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2div
;

comment on function pg_catalog.int2div(smallint, smallint)
is 'implementation of / operator';

create function pg_catalog.int4div(integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4div
;

comment on function pg_catalog.int4div(integer, integer)
is 'implementation of / operator';

create function pg_catalog.int2mod(smallint, smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2mod
;

comment on function pg_catalog.int2mod(smallint, smallint)
is 'implementation of % operator';

create function pg_catalog.int4mod(integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4mod
;

comment on function pg_catalog.int4mod(integer, integer)
is 'implementation of % operator';

create function pg_catalog.textne(text, text)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.textne
;

comment on function pg_catalog.textne(text, text)
is 'implementation of <> operator';

create function pg_catalog.int24eq(smallint, integer)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int24eq
;

comment on function pg_catalog.int24eq(smallint, integer)
is 'implementation of = operator';

create function pg_catalog.int42eq(integer, smallint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int42eq
;

comment on function pg_catalog.int42eq(integer, smallint)
is 'implementation of = operator';

create function pg_catalog.int24lt(smallint, integer)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int24lt
;

comment on function pg_catalog.int24lt(smallint, integer)
is 'implementation of < operator';

create function pg_catalog.int42lt(integer, smallint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int42lt
;

comment on function pg_catalog.int42lt(integer, smallint)
is 'implementation of < operator';

create function pg_catalog.int24gt(smallint, integer)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int24gt
;

comment on function pg_catalog.int24gt(smallint, integer)
is 'implementation of > operator';

create function pg_catalog.int42gt(integer, smallint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int42gt
;

comment on function pg_catalog.int42gt(integer, smallint)
is 'implementation of > operator';

create function pg_catalog.int24ne(smallint, integer)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int24ne
;

comment on function pg_catalog.int24ne(smallint, integer)
is 'implementation of <> operator';

create function pg_catalog.int42ne(integer, smallint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int42ne
;

comment on function pg_catalog.int42ne(integer, smallint)
is 'implementation of <> operator';

create function pg_catalog.int24le(smallint, integer)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int24le
;

comment on function pg_catalog.int24le(smallint, integer)
is 'implementation of <= operator';

create function pg_catalog.int42le(integer, smallint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int42le
;

comment on function pg_catalog.int42le(integer, smallint)
is 'implementation of <= operator';

create function pg_catalog.int24ge(smallint, integer)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int24ge
;

comment on function pg_catalog.int24ge(smallint, integer)
is 'implementation of >= operator';

create function pg_catalog.int42ge(integer, smallint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int42ge
;

comment on function pg_catalog.int42ge(integer, smallint)
is 'implementation of >= operator';

create function pg_catalog.int24mul(smallint, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int24mul
;

comment on function pg_catalog.int24mul(smallint, integer)
is 'implementation of * operator';

create function pg_catalog.int42mul(integer, smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int42mul
;

comment on function pg_catalog.int42mul(integer, smallint)
is 'implementation of * operator';

create function pg_catalog.int24div(smallint, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int24div
;

comment on function pg_catalog.int24div(smallint, integer)
is 'implementation of / operator';

create function pg_catalog.int42div(integer, smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int42div
;

comment on function pg_catalog.int42div(integer, smallint)
is 'implementation of / operator';

create function pg_catalog.int2pl(smallint, smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2pl
;

comment on function pg_catalog.int2pl(smallint, smallint)
is 'implementation of + operator';

create function pg_catalog.int4pl(integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4pl
;

comment on function pg_catalog.int4pl(integer, integer)
is 'implementation of + operator';

create function pg_catalog.int24pl(smallint, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int24pl
;

comment on function pg_catalog.int24pl(smallint, integer)
is 'implementation of + operator';

create function pg_catalog.int42pl(integer, smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int42pl
;

comment on function pg_catalog.int42pl(integer, smallint)
is 'implementation of + operator';

create function pg_catalog.int2mi(smallint, smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2mi
;

comment on function pg_catalog.int2mi(smallint, smallint)
is 'implementation of - operator';

create function pg_catalog.int4mi(integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4mi
;

comment on function pg_catalog.int4mi(integer, integer)
is 'implementation of - operator';

create function pg_catalog.int24mi(smallint, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int24mi
;

comment on function pg_catalog.int24mi(smallint, integer)
is 'implementation of - operator';

create function pg_catalog.int42mi(integer, smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int42mi
;

comment on function pg_catalog.int42mi(integer, smallint)
is 'implementation of - operator';

create function pg_catalog.oideq(oid, oid)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.oideq
;

comment on function pg_catalog.oideq(oid, oid)
is 'implementation of = operator';

create function pg_catalog.oidne(oid, oid)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.oidne
;

comment on function pg_catalog.oidne(oid, oid)
is 'implementation of <> operator';

create function pg_catalog.box_same(box, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_same
;

comment on function pg_catalog.box_same(box, box)
is 'implementation of ~= operator';

create function pg_catalog.box_contain(box, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_contain
;

comment on function pg_catalog.box_contain(box, box)
is 'implementation of @> operator';

create function pg_catalog.box_left(box, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_left
;

comment on function pg_catalog.box_left(box, box)
is 'implementation of << operator';

create function pg_catalog.box_overleft(box, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_overleft
;

comment on function pg_catalog.box_overleft(box, box)
is 'implementation of &< operator';

create function pg_catalog.box_overright(box, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_overright
;

comment on function pg_catalog.box_overright(box, box)
is 'implementation of &> operator';

create function pg_catalog.box_right(box, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_right
;

comment on function pg_catalog.box_right(box, box)
is 'implementation of >> operator';

create function pg_catalog.box_contained(box, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_contained
;

comment on function pg_catalog.box_contained(box, box)
is 'implementation of <@ operator';

create function pg_catalog.box_contain_pt(box, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_contain_pt
;

comment on function pg_catalog.box_contain_pt(box, point)
is 'implementation of @> operator';

create function pg_catalog.pg_node_tree_in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_node_tree_in
;

comment on function pg_catalog.pg_node_tree_in(cstring)
is 'I/O';

create function pg_catalog.pg_node_tree_out(pg_node_tree)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_node_tree_out
;

comment on function pg_catalog.pg_node_tree_out(pg_node_tree)
is 'I/O';

create function pg_catalog.pg_node_tree_recv(internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_node_tree_recv
;

comment on function pg_catalog.pg_node_tree_recv(internal)
is 'I/O';

create function pg_catalog.pg_node_tree_send(pg_node_tree)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_node_tree_send
;

comment on function pg_catalog.pg_node_tree_send(pg_node_tree)
is 'I/O';

create function pg_catalog.float4in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float4in
;

comment on function pg_catalog.float4in(cstring)
is 'I/O';

create function pg_catalog.float4out(real)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float4out
;

comment on function pg_catalog.float4out(real)
is 'I/O';

create function pg_catalog.float4mul(real, real)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float4mul
;

comment on function pg_catalog.float4mul(real, real)
is 'implementation of * operator';

create function pg_catalog.float4div(real, real)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float4div
;

comment on function pg_catalog.float4div(real, real)
is 'implementation of / operator';

create function pg_catalog.float4pl(real, real)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float4pl
;

comment on function pg_catalog.float4pl(real, real)
is 'implementation of + operator';

create function pg_catalog.float4mi(real, real)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float4mi
;

comment on function pg_catalog.float4mi(real, real)
is 'implementation of - operator';

create function pg_catalog.float4um(real)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float4um
;

comment on function pg_catalog.float4um(real)
is 'implementation of - operator';

create function pg_catalog.float4abs(real)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float4abs
;

comment on function pg_catalog.float4abs(real)
is 'implementation of @ operator';

create function pg_catalog.float4_accum(double precision [], real)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float4_accum
;

comment on function pg_catalog.float4_accum(double precision [], real)
is 'aggregate transition function';

create function pg_catalog.float4larger(real, real)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float4larger
;

comment on function pg_catalog.float4larger(real, real)
is 'larger of two';

create function pg_catalog.float4smaller(real, real)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float4smaller
;

comment on function pg_catalog.float4smaller(real, real)
is 'smaller of two';

create function pg_catalog.int4um(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4um
;

comment on function pg_catalog.int4um(integer)
is 'implementation of - operator';

create function pg_catalog.int2um(smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2um
;

comment on function pg_catalog.int2um(smallint)
is 'implementation of - operator';

create function pg_catalog.float8in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8in
;

comment on function pg_catalog.float8in(cstring)
is 'I/O';

create function pg_catalog.float8out(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8out
;

comment on function pg_catalog.float8out(double precision)
is 'I/O';

create function pg_catalog.float8mul(double precision, double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8mul
;

comment on function pg_catalog.float8mul(double precision, double precision)
is 'implementation of * operator';

create function pg_catalog.float8div(double precision, double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8div
;

comment on function pg_catalog.float8div(double precision, double precision)
is 'implementation of / operator';

create function pg_catalog.float8pl(double precision, double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8pl
;

comment on function pg_catalog.float8pl(double precision, double precision)
is 'implementation of + operator';

create function pg_catalog.float8mi(double precision, double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8mi
;

comment on function pg_catalog.float8mi(double precision, double precision)
is 'implementation of - operator';

create function pg_catalog.float8um(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8um
;

comment on function pg_catalog.float8um(double precision)
is 'implementation of - operator';

create function pg_catalog.float8abs(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8abs
;

comment on function pg_catalog.float8abs(double precision)
is 'implementation of @ operator';

create function pg_catalog.float8_accum(double precision [], double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8_accum
;

comment on function pg_catalog.float8_accum(double precision [], double precision)
is 'aggregate transition function';

create function pg_catalog.float8larger(double precision, double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8larger
;

comment on function pg_catalog.float8larger(double precision, double precision)
is 'larger of two';

create function pg_catalog.float8smaller(double precision, double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8smaller
;

comment on function pg_catalog.float8smaller(double precision, double precision)
is 'smaller of two';

create function pg_catalog.lseg_center(lseg)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lseg_center
;

comment on function pg_catalog.lseg_center(lseg)
is 'implementation of @@ operator';

create function pg_catalog.path_center(path)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.path_center
;

comment on function pg_catalog.path_center(path)
is 'implementation of @@ operator';

create function pg_catalog.poly_center(polygon)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.poly_center
;

comment on function pg_catalog.poly_center(polygon)
is 'implementation of @@ operator';

create function pg_catalog.dround(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.dround
;

comment on function pg_catalog.dround(double precision)
is 'round to nearest integer';

create function pg_catalog.dtrunc(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.dtrunc
;

comment on function pg_catalog.dtrunc(double precision)
is 'truncate to integer';

create function pg_catalog.dsqrt(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.dsqrt
;

comment on function pg_catalog.dsqrt(double precision)
is 'implementation of |/ operator';

create function pg_catalog.dcbrt(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.dcbrt
;

comment on function pg_catalog.dcbrt(double precision)
is 'implementation of ||/ operator';

create function pg_catalog.dpow(double precision, double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.dpow
;

comment on function pg_catalog.dpow(double precision, double precision)
is 'implementation of ^ operator';

create function pg_catalog.dexp(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.dexp
;

comment on function pg_catalog.dexp(double precision)
is 'natural exponential (e^x)';

create function pg_catalog.dlog1(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.dlog1
;

comment on function pg_catalog.dlog1(double precision)
is 'natural logarithm';

create function pg_catalog.float8(smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8
;

comment on function pg_catalog.float8(smallint)
is 'convert int2 to float8';

create function pg_catalog.float4(smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float4
;

comment on function pg_catalog.float4(smallint)
is 'convert int2 to float4';

create function pg_catalog.int2(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2
;

comment on function pg_catalog.int2(double precision)
is 'convert float8 to int2';

create function pg_catalog.int2(real)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2
;

comment on function pg_catalog.int2(real)
is 'convert float4 to int2';

create function pg_catalog.line_distance(line, line)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.line_distance
;

comment on function pg_catalog.line_distance(line, line)
is 'implementation of <-> operator';

create function pg_catalog.abstimein(cstring)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.abstimein
;

comment on function pg_catalog.abstimein(cstring)
is 'I/O';

create function pg_catalog.abstimeout(abstime)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.abstimeout
;

comment on function pg_catalog.abstimeout(abstime)
is 'I/O';

create function pg_catalog.reltimein(cstring)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.reltimein
;

comment on function pg_catalog.reltimein(cstring)
is 'I/O';

create function pg_catalog.reltimeout(reltime)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.reltimeout
;

comment on function pg_catalog.reltimeout(reltime)
is 'I/O';

create function pg_catalog.timepl(abstime, reltime)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timepl
;

comment on function pg_catalog.timepl(abstime, reltime)
is 'implementation of + operator';

create function pg_catalog.timemi(abstime, reltime)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timemi
;

comment on function pg_catalog.timemi(abstime, reltime)
is 'implementation of - operator';

create function pg_catalog.tintervalin(cstring)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tintervalin
;

comment on function pg_catalog.tintervalin(cstring)
is 'I/O';

create function pg_catalog.tintervalout(tinterval)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tintervalout
;

comment on function pg_catalog.tintervalout(tinterval)
is 'I/O';

create function pg_catalog.intinterval(abstime, tinterval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.intinterval
;

comment on function pg_catalog.intinterval(abstime, tinterval)
is 'implementation of <?> operator';

create function pg_catalog.tintervalrel(tinterval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tintervalrel
;

comment on function pg_catalog.tintervalrel(tinterval)
is 'tinterval to reltime';

create function pg_catalog.timenow()
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timenow
;

comment on function pg_catalog.timenow()
is 'current date and time (abstime)';

create function pg_catalog.abstimeeq(abstime, abstime)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.abstimeeq
;

comment on function pg_catalog.abstimeeq(abstime, abstime)
is 'implementation of = operator';

create function pg_catalog.abstimene(abstime, abstime)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.abstimene
;

comment on function pg_catalog.abstimene(abstime, abstime)
is 'implementation of <> operator';

create function pg_catalog.abstimelt(abstime, abstime)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.abstimelt
;

comment on function pg_catalog.abstimelt(abstime, abstime)
is 'implementation of < operator';

create function pg_catalog.abstimegt(abstime, abstime)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.abstimegt
;

comment on function pg_catalog.abstimegt(abstime, abstime)
is 'implementation of > operator';

create function pg_catalog.abstimele(abstime, abstime)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.abstimele
;

comment on function pg_catalog.abstimele(abstime, abstime)
is 'implementation of <= operator';

create function pg_catalog.abstimege(abstime, abstime)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.abstimege
;

comment on function pg_catalog.abstimege(abstime, abstime)
is 'implementation of >= operator';

create function pg_catalog.reltimeeq(reltime, reltime)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.reltimeeq
;

comment on function pg_catalog.reltimeeq(reltime, reltime)
is 'implementation of = operator';

create function pg_catalog.reltimene(reltime, reltime)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.reltimene
;

comment on function pg_catalog.reltimene(reltime, reltime)
is 'implementation of <> operator';

create function pg_catalog.reltimelt(reltime, reltime)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.reltimelt
;

comment on function pg_catalog.reltimelt(reltime, reltime)
is 'implementation of < operator';

create function pg_catalog.reltimegt(reltime, reltime)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.reltimegt
;

comment on function pg_catalog.reltimegt(reltime, reltime)
is 'implementation of > operator';

create function pg_catalog.reltimele(reltime, reltime)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.reltimele
;

comment on function pg_catalog.reltimele(reltime, reltime)
is 'implementation of <= operator';

create function pg_catalog.reltimege(reltime, reltime)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.reltimege
;

comment on function pg_catalog.reltimege(reltime, reltime)
is 'implementation of >= operator';

create function pg_catalog.tintervalsame(tinterval, tinterval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tintervalsame
;

comment on function pg_catalog.tintervalsame(tinterval, tinterval)
is 'implementation of ~= operator';

create function pg_catalog.tintervalct(tinterval, tinterval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tintervalct
;

comment on function pg_catalog.tintervalct(tinterval, tinterval)
is 'implementation of << operator';

create function pg_catalog.tintervalov(tinterval, tinterval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tintervalov
;

comment on function pg_catalog.tintervalov(tinterval, tinterval)
is 'implementation of && operator';

create function pg_catalog.tintervalleneq(tinterval, reltime)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tintervalleneq
;

comment on function pg_catalog.tintervalleneq(tinterval, reltime)
is 'implementation of #= operator';

create function pg_catalog.tintervallenne(tinterval, reltime)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tintervallenne
;

comment on function pg_catalog.tintervallenne(tinterval, reltime)
is 'implementation of #<> operator';

create function pg_catalog.tintervallenlt(tinterval, reltime)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tintervallenlt
;

comment on function pg_catalog.tintervallenlt(tinterval, reltime)
is 'implementation of #< operator';

create function pg_catalog.tintervallengt(tinterval, reltime)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tintervallengt
;

comment on function pg_catalog.tintervallengt(tinterval, reltime)
is 'implementation of #> operator';

create function pg_catalog.tintervallenle(tinterval, reltime)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tintervallenle
;

comment on function pg_catalog.tintervallenle(tinterval, reltime)
is 'implementation of #<= operator';

create function pg_catalog.tintervallenge(tinterval, reltime)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tintervallenge
;

comment on function pg_catalog.tintervallenge(tinterval, reltime)
is 'implementation of #>= operator';

create function pg_catalog.tintervalstart(tinterval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tintervalstart
;

comment on function pg_catalog.tintervalstart(tinterval)
is 'implementation of | operator';

create function pg_catalog.tintervalend(tinterval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tintervalend
;

comment on function pg_catalog.tintervalend(tinterval)
is 'end of interval';

create function pg_catalog.timeofday()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timeofday
;

comment on function pg_catalog.timeofday()
is 'current date and time - increments during transactions';

create function pg_catalog.isfinite(abstime)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.isfinite
;

comment on function pg_catalog.isfinite(abstime)
is 'finite abstime?';

create function pg_catalog.float8_combine(double precision [], double precision [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8_combine
;

comment on function pg_catalog.float8_combine(double precision [], double precision [])
is 'aggregate combine function';

create function pg_catalog.inter_sl(lseg, line)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inter_sl
;

comment on function pg_catalog.inter_sl(lseg, line)
is 'implementation of ?# operator';

create function pg_catalog.inter_lb(line, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inter_lb
;

comment on function pg_catalog.inter_lb(line, box)
is 'implementation of ?# operator';

create function pg_catalog.float48mul(real, double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float48mul
;

comment on function pg_catalog.float48mul(real, double precision)
is 'implementation of * operator';

create function pg_catalog.float48div(real, double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float48div
;

comment on function pg_catalog.float48div(real, double precision)
is 'implementation of / operator';

create function pg_catalog.float48pl(real, double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float48pl
;

comment on function pg_catalog.float48pl(real, double precision)
is 'implementation of + operator';

create function pg_catalog.float48mi(real, double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float48mi
;

comment on function pg_catalog.float48mi(real, double precision)
is 'implementation of - operator';

create function pg_catalog.float84mul(double precision, real)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float84mul
;

comment on function pg_catalog.float84mul(double precision, real)
is 'implementation of * operator';

create function pg_catalog.float84div(double precision, real)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float84div
;

comment on function pg_catalog.float84div(double precision, real)
is 'implementation of / operator';

create function pg_catalog.float84pl(double precision, real)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float84pl
;

comment on function pg_catalog.float84pl(double precision, real)
is 'implementation of + operator';

create function pg_catalog.float84mi(double precision, real)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float84mi
;

comment on function pg_catalog.float84mi(double precision, real)
is 'implementation of - operator';

create function pg_catalog.float4eq(real, real)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float4eq
;

comment on function pg_catalog.float4eq(real, real)
is 'implementation of = operator';

create function pg_catalog.float4ne(real, real)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float4ne
;

comment on function pg_catalog.float4ne(real, real)
is 'implementation of <> operator';

create function pg_catalog.float4lt(real, real)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float4lt
;

comment on function pg_catalog.float4lt(real, real)
is 'implementation of < operator';

create function pg_catalog.float4le(real, real)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float4le
;

comment on function pg_catalog.float4le(real, real)
is 'implementation of <= operator';

create function pg_catalog.float4gt(real, real)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float4gt
;

comment on function pg_catalog.float4gt(real, real)
is 'implementation of > operator';

create function pg_catalog.float4ge(real, real)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float4ge
;

comment on function pg_catalog.float4ge(real, real)
is 'implementation of >= operator';

create function pg_catalog.float8eq(double precision, double precision)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8eq
;

comment on function pg_catalog.float8eq(double precision, double precision)
is 'implementation of = operator';

create function pg_catalog.float8ne(double precision, double precision)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8ne
;

comment on function pg_catalog.float8ne(double precision, double precision)
is 'implementation of <> operator';

create function pg_catalog.float8lt(double precision, double precision)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8lt
;

comment on function pg_catalog.float8lt(double precision, double precision)
is 'implementation of < operator';

create function pg_catalog.float8le(double precision, double precision)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8le
;

comment on function pg_catalog.float8le(double precision, double precision)
is 'implementation of <= operator';

create function pg_catalog.float8gt(double precision, double precision)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8gt
;

comment on function pg_catalog.float8gt(double precision, double precision)
is 'implementation of > operator';

create function pg_catalog.float8ge(double precision, double precision)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8ge
;

comment on function pg_catalog.float8ge(double precision, double precision)
is 'implementation of >= operator';

create function pg_catalog.float48eq(real, double precision)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float48eq
;

comment on function pg_catalog.float48eq(real, double precision)
is 'implementation of = operator';

create function pg_catalog.float48ne(real, double precision)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float48ne
;

comment on function pg_catalog.float48ne(real, double precision)
is 'implementation of <> operator';

create function pg_catalog.float48lt(real, double precision)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float48lt
;

comment on function pg_catalog.float48lt(real, double precision)
is 'implementation of < operator';

create function pg_catalog.float48le(real, double precision)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float48le
;

comment on function pg_catalog.float48le(real, double precision)
is 'implementation of <= operator';

create function pg_catalog.float48gt(real, double precision)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float48gt
;

comment on function pg_catalog.float48gt(real, double precision)
is 'implementation of > operator';

create function pg_catalog.float48ge(real, double precision)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float48ge
;

comment on function pg_catalog.float48ge(real, double precision)
is 'implementation of >= operator';

create function pg_catalog.float84eq(double precision, real)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float84eq
;

comment on function pg_catalog.float84eq(double precision, real)
is 'implementation of = operator';

create function pg_catalog.float84ne(double precision, real)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float84ne
;

comment on function pg_catalog.float84ne(double precision, real)
is 'implementation of <> operator';

create function pg_catalog.float84lt(double precision, real)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float84lt
;

comment on function pg_catalog.float84lt(double precision, real)
is 'implementation of < operator';

create function pg_catalog.float84le(double precision, real)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float84le
;

comment on function pg_catalog.float84le(double precision, real)
is 'implementation of <= operator';

create function pg_catalog.float84gt(double precision, real)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float84gt
;

comment on function pg_catalog.float84gt(double precision, real)
is 'implementation of > operator';

create function pg_catalog.float84ge(double precision, real)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float84ge
;

comment on function pg_catalog.float84ge(double precision, real)
is 'implementation of >= operator';

create function pg_catalog.float8(real)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8
;

comment on function pg_catalog.float8(real)
is 'convert float4 to float8';

create function pg_catalog.float4(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float4
;

comment on function pg_catalog.float4(double precision)
is 'convert float8 to float4';

create function pg_catalog.int4(smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4
;

comment on function pg_catalog.int4(smallint)
is 'convert int2 to int4';

create function pg_catalog.int2(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2
;

comment on function pg_catalog.int2(integer)
is 'convert int4 to int2';

create function pg_catalog.pg_jit_available()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_jit_available
;

comment on function pg_catalog.pg_jit_available()
is 'Is JIT compilation available in this session?';

create function pg_catalog.float8(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8
;

comment on function pg_catalog.float8(integer)
is 'convert int4 to float8';

create function pg_catalog.int4(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4
;

comment on function pg_catalog.int4(double precision)
is 'convert float8 to int4';

create function pg_catalog.float4(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float4
;

comment on function pg_catalog.float4(integer)
is 'convert int4 to float4';

create function pg_catalog.int4(real)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4
;

comment on function pg_catalog.int4(real)
is 'convert float4 to int4';

create function pg_catalog.width_bucket(double precision, double precision, double precision, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.width_bucket
;

comment on function pg_catalog.width_bucket(double precision, double precision, double precision, integer)
is 'bucket number of operand in equal-width histogram';

create function pg_catalog.json_in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.json_in
;

comment on function pg_catalog.json_in(cstring)
is 'I/O';

create function pg_catalog.json_out(json)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.json_out
;

comment on function pg_catalog.json_out(json)
is 'I/O';

create function pg_catalog.json_recv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.json_recv
;

comment on function pg_catalog.json_recv(internal)
is 'I/O';

create function pg_catalog.json_send(json)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.json_send
;

comment on function pg_catalog.json_send(json)
is 'I/O';

create function pg_catalog.index_am_handler_in(cstring)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.index_am_handler_in
;

comment on function pg_catalog.index_am_handler_in(cstring)
is 'I/O';

create function pg_catalog.index_am_handler_out(index_am_handler)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.index_am_handler_out
;

comment on function pg_catalog.index_am_handler_out(index_am_handler)
is 'I/O';

create function pg_catalog.hashmacaddr8(macaddr8)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hashmacaddr8
;

comment on function pg_catalog.hashmacaddr8(macaddr8)
is 'hash';

create function pg_catalog.hash_aclitem(aclitem)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hash_aclitem
;

comment on function pg_catalog.hash_aclitem(aclitem)
is 'hash';

create function pg_catalog.bthandler(internal)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bthandler
;

comment on function pg_catalog.bthandler(internal)
is 'btree index access method handler';

create function pg_catalog.hashhandler(internal)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hashhandler
;

comment on function pg_catalog.hashhandler(internal)
is 'hash index access method handler';

create function pg_catalog.gisthandler(internal)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gisthandler
;

comment on function pg_catalog.gisthandler(internal)
is 'gist index access method handler';

create function pg_catalog.ginhandler(internal)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ginhandler
;

comment on function pg_catalog.ginhandler(internal)
is 'gin index access method handler';

create function pg_catalog.spghandler(internal)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.spghandler
;

comment on function pg_catalog.spghandler(internal)
is 'spgist index access method handler';

create function pg_catalog.brinhandler(internal)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.brinhandler
;

comment on function pg_catalog.brinhandler(internal)
is 'brin index access method handler';

create function pg_catalog.scalarlesel(internal, oid, internal, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.scalarlesel
;

comment on function pg_catalog.scalarlesel(internal, oid, internal, integer)
is 'restriction selectivity of <= and related operators on scalar datatypes';

create function pg_catalog.scalargesel(internal, oid, internal, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.scalargesel
;

comment on function pg_catalog.scalargesel(internal, oid, internal, integer)
is 'restriction selectivity of >= and related operators on scalar datatypes';

create function pg_catalog.amvalidate(oid)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.amvalidate
;

comment on function pg_catalog.amvalidate(oid)
is 'validate an operator class';

create function pg_catalog.poly_same(polygon, polygon)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.poly_same
;

comment on function pg_catalog.poly_same(polygon, polygon)
is 'implementation of ~= operator';

create function pg_catalog.poly_contain(polygon, polygon)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.poly_contain
;

comment on function pg_catalog.poly_contain(polygon, polygon)
is 'implementation of @> operator';

create function pg_catalog.poly_left(polygon, polygon)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.poly_left
;

comment on function pg_catalog.poly_left(polygon, polygon)
is 'implementation of << operator';

create function pg_catalog.poly_overleft(polygon, polygon)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.poly_overleft
;

comment on function pg_catalog.poly_overleft(polygon, polygon)
is 'implementation of &< operator';

create function pg_catalog.poly_overright(polygon, polygon)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.poly_overright
;

comment on function pg_catalog.poly_overright(polygon, polygon)
is 'implementation of &> operator';

create function pg_catalog.poly_right(polygon, polygon)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.poly_right
;

comment on function pg_catalog.poly_right(polygon, polygon)
is 'implementation of >> operator';

create function pg_catalog.poly_contained(polygon, polygon)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.poly_contained
;

comment on function pg_catalog.poly_contained(polygon, polygon)
is 'implementation of <@ operator';

create function pg_catalog.poly_overlap(polygon, polygon)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.poly_overlap
;

comment on function pg_catalog.poly_overlap(polygon, polygon)
is 'implementation of && operator';

create function pg_catalog.poly_in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.poly_in
;

comment on function pg_catalog.poly_in(cstring)
is 'I/O';

create function pg_catalog.poly_out(polygon)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.poly_out
;

comment on function pg_catalog.poly_out(polygon)
is 'I/O';

create function pg_catalog.btint2cmp(smallint, smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btint2cmp
;

comment on function pg_catalog.btint2cmp(smallint, smallint)
is 'less-equal-greater';

create function pg_catalog.btint4cmp(integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btint4cmp
;

comment on function pg_catalog.btint4cmp(integer, integer)
is 'less-equal-greater';

create function pg_catalog.btfloat4cmp(real, real)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btfloat4cmp
;

comment on function pg_catalog.btfloat4cmp(real, real)
is 'less-equal-greater';

create function pg_catalog.btfloat8cmp(double precision, double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btfloat8cmp
;

comment on function pg_catalog.btfloat8cmp(double precision, double precision)
is 'less-equal-greater';

create function pg_catalog.btoidcmp(oid, oid)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btoidcmp
;

comment on function pg_catalog.btoidcmp(oid, oid)
is 'less-equal-greater';

create function pg_catalog.btabstimecmp(abstime, abstime)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btabstimecmp
;

comment on function pg_catalog.btabstimecmp(abstime, abstime)
is 'less-equal-greater';

create function pg_catalog.btcharcmp("char", "char")
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btcharcmp
;

comment on function pg_catalog.btcharcmp("char", "char")
is 'less-equal-greater';

create function pg_catalog.btnamecmp(name, name)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btnamecmp
;

comment on function pg_catalog.btnamecmp(name, name)
is 'less-equal-greater';

create function pg_catalog.bttextcmp(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bttextcmp
;

comment on function pg_catalog.bttextcmp(text, text)
is 'less-equal-greater';

create function pg_catalog.lseg_distance(lseg, lseg)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lseg_distance
;

comment on function pg_catalog.lseg_distance(lseg, lseg)
is 'implementation of <-> operator';

create function pg_catalog.lseg_interpt(lseg, lseg)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lseg_interpt
;

comment on function pg_catalog.lseg_interpt(lseg, lseg)
is 'implementation of # operator';

create function pg_catalog.dist_ps(point, lseg)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.dist_ps
;

comment on function pg_catalog.dist_ps(point, lseg)
is 'implementation of <-> operator';

create function pg_catalog.dist_pb(point, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.dist_pb
;

comment on function pg_catalog.dist_pb(point, box)
is 'implementation of <-> operator';

create function pg_catalog.dist_sb(lseg, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.dist_sb
;

comment on function pg_catalog.dist_sb(lseg, box)
is 'implementation of <-> operator';

create function pg_catalog.close_ps(point, lseg)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.close_ps
;

comment on function pg_catalog.close_ps(point, lseg)
is 'implementation of ## operator';

create function pg_catalog.close_pb(point, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.close_pb
;

comment on function pg_catalog.close_pb(point, box)
is 'implementation of ## operator';

create function pg_catalog.close_sb(lseg, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.close_sb
;

comment on function pg_catalog.close_sb(lseg, box)
is 'implementation of ## operator';

create function pg_catalog.on_ps(point, lseg)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.on_ps
;

comment on function pg_catalog.on_ps(point, lseg)
is 'implementation of <@ operator';

create function pg_catalog.path_distance(path, path)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.path_distance
;

comment on function pg_catalog.path_distance(path, path)
is 'implementation of <-> operator';

create function pg_catalog.dist_ppath(point, path)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.dist_ppath
;

comment on function pg_catalog.dist_ppath(point, path)
is 'implementation of <-> operator';

create function pg_catalog.on_sb(lseg, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.on_sb
;

comment on function pg_catalog.on_sb(lseg, box)
is 'implementation of <@ operator';

create function pg_catalog.inter_sb(lseg, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inter_sb
;

comment on function pg_catalog.inter_sb(lseg, box)
is 'implementation of ?# operator';

create function pg_catalog.string_to_array(text, text, text)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.string_to_array
;

comment on function pg_catalog.string_to_array(text, text, text)
is 'split delimited text into text[], with null string';

create function pg_catalog.cash_cmp(money, money)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cash_cmp
;

comment on function pg_catalog.cash_cmp(money, money)
is 'less-equal-greater';

create function pg_catalog.array_append(anyarray, anyelement)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_append
;

comment on function pg_catalog.array_append(anyarray, anyelement)
is 'append element onto end of array';

create function pg_catalog.array_prepend(anyelement, anyarray)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_prepend
;

comment on function pg_catalog.array_prepend(anyelement, anyarray)
is 'prepend element onto front of array';

create function pg_catalog.btreltimecmp(reltime, reltime)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btreltimecmp
;

comment on function pg_catalog.btreltimecmp(reltime, reltime)
is 'less-equal-greater';

create function pg_catalog.bttintervalcmp(tinterval, tinterval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bttintervalcmp
;

comment on function pg_catalog.bttintervalcmp(tinterval, tinterval)
is 'less-equal-greater';

create function pg_catalog.btarraycmp(anyarray, anyarray)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btarraycmp
;

comment on function pg_catalog.btarraycmp(anyarray, anyarray)
is 'less-equal-greater';

create function pg_catalog.array_cat(anyarray, anyarray)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_cat
;

comment on function pg_catalog.array_cat(anyarray, anyarray)
is 'implementation of || operator';

create function pg_catalog.array_to_string(anyarray, text, text)
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_to_string
;

comment on function pg_catalog.array_to_string(anyarray, text, text)
is 'concatenate array elements, using delimiter and null string, into text';

create function pg_catalog.scalarlejoinsel(internal, oid, internal, smallint, internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.scalarlejoinsel
;

comment on function pg_catalog.scalarlejoinsel(internal, oid, internal, smallint, internal)
is 'join selectivity of <= and related operators on scalar datatypes';

create function pg_catalog.array_ne(anyarray, anyarray)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_ne
;

comment on function pg_catalog.array_ne(anyarray, anyarray)
is 'implementation of <> operator';

create function pg_catalog.array_lt(anyarray, anyarray)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_lt
;

comment on function pg_catalog.array_lt(anyarray, anyarray)
is 'implementation of < operator';

create function pg_catalog.array_gt(anyarray, anyarray)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_gt
;

comment on function pg_catalog.array_gt(anyarray, anyarray)
is 'implementation of > operator';

create function pg_catalog.array_le(anyarray, anyarray)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_le
;

comment on function pg_catalog.array_le(anyarray, anyarray)
is 'implementation of <= operator';

create function pg_catalog.string_to_array(text, text)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.string_to_array
;

comment on function pg_catalog.string_to_array(text, text)
is 'split delimited text into text[]';

create function pg_catalog.array_to_string(anyarray, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_to_string
;

comment on function pg_catalog.array_to_string(anyarray, text)
is 'concatenate array elements, using delimiter, into text';

create function pg_catalog.array_ge(anyarray, anyarray)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_ge
;

comment on function pg_catalog.array_ge(anyarray, anyarray)
is 'implementation of >= operator';

create function pg_catalog.scalargejoinsel(internal, oid, internal, smallint, internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.scalargejoinsel
;

comment on function pg_catalog.scalargejoinsel(internal, oid, internal, smallint, internal)
is 'join selectivity of >= and related operators on scalar datatypes';

create function pg_catalog.hashmacaddr(macaddr)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hashmacaddr
;

comment on function pg_catalog.hashmacaddr(macaddr)
is 'hash';

create function pg_catalog.hashtext(text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hashtext
;

comment on function pg_catalog.hashtext(text)
is 'hash';

create function pg_catalog.text(char)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.text
;

comment on function pg_catalog.text(char)
is 'convert char(n) to text';

create function pg_catalog.btoidvectorcmp(oidvector, oidvector)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btoidvectorcmp
;

comment on function pg_catalog.btoidvectorcmp(oidvector, oidvector)
is 'less-equal-greater';

create function pg_catalog.text(name)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.text
;

comment on function pg_catalog.text(name)
is 'convert name to text';

create function pg_catalog.name(text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.name
;

comment on function pg_catalog.name(text)
is 'convert text to name';

create function pg_catalog.bpchar(name)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpchar
;

comment on function pg_catalog.bpchar(name)
is 'convert name to char(n)';

create function pg_catalog.name(char)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.name
;

comment on function pg_catalog.name(char)
is 'convert char(n) to name';

create function pg_catalog.hashinet(inet)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hashinet
;

comment on function pg_catalog.hashinet(inet)
is 'hash';

create function pg_catalog.hashint4extended(integer, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hashint4extended
;

comment on function pg_catalog.hashint4extended(integer, bigint)
is 'hash';

create function pg_catalog.hash_numeric(numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hash_numeric
;

comment on function pg_catalog.hash_numeric(numeric)
is 'hash';

create function pg_catalog.macaddr_in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr_in
;

comment on function pg_catalog.macaddr_in(cstring)
is 'I/O';

create function pg_catalog.macaddr_out(macaddr)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr_out
;

comment on function pg_catalog.macaddr_out(macaddr)
is 'I/O';

create function pg_catalog.num_nulls("any")
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.num_nulls
;

comment on function pg_catalog.num_nulls("any")
is 'count the number of NULL arguments';

create function pg_catalog.num_nonnulls("any")
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.num_nonnulls
;

comment on function pg_catalog.num_nonnulls("any")
is 'count the number of non-NULL arguments';

create function pg_catalog.hashint2extended(smallint, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hashint2extended
;

comment on function pg_catalog.hashint2extended(smallint, bigint)
is 'hash';

create function pg_catalog.hashint8extended(bigint, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hashint8extended
;

comment on function pg_catalog.hashint8extended(bigint, bigint)
is 'hash';

create function pg_catalog.hashfloat4extended(real, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hashfloat4extended
;

comment on function pg_catalog.hashfloat4extended(real, bigint)
is 'hash';

create function pg_catalog.hashfloat8extended(double precision, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hashfloat8extended
;

comment on function pg_catalog.hashfloat8extended(double precision, bigint)
is 'hash';

create function pg_catalog.hashoidextended(oid, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hashoidextended
;

comment on function pg_catalog.hashoidextended(oid, bigint)
is 'hash';

create function pg_catalog.hashcharextended("char", bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hashcharextended
;

comment on function pg_catalog.hashcharextended("char", bigint)
is 'hash';

create function pg_catalog.hashnameextended(name, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hashnameextended
;

comment on function pg_catalog.hashnameextended(name, bigint)
is 'hash';

create function pg_catalog.hashtextextended(text, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hashtextextended
;

comment on function pg_catalog.hashtextextended(text, bigint)
is 'hash';

create function pg_catalog.hashint2(smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hashint2
;

comment on function pg_catalog.hashint2(smallint)
is 'hash';

create function pg_catalog.hashint4(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hashint4
;

comment on function pg_catalog.hashint4(integer)
is 'hash';

create function pg_catalog.hashfloat4(real)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hashfloat4
;

comment on function pg_catalog.hashfloat4(real)
is 'hash';

create function pg_catalog.hashfloat8(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hashfloat8
;

comment on function pg_catalog.hashfloat8(double precision)
is 'hash';

create function pg_catalog.hashoid(oid)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hashoid
;

comment on function pg_catalog.hashoid(oid)
is 'hash';

create function pg_catalog.hashchar("char")
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hashchar
;

comment on function pg_catalog.hashchar("char")
is 'hash';

create function pg_catalog.hashname(name)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hashname
;

comment on function pg_catalog.hashname(name)
is 'hash';

create function pg_catalog.hashvarlena(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hashvarlena
;

comment on function pg_catalog.hashvarlena(internal)
is 'hash';

create function pg_catalog.hashoidvector(oidvector)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hashoidvector
;

comment on function pg_catalog.hashoidvector(oidvector)
is 'hash';

create function pg_catalog.text_larger(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.text_larger
;

comment on function pg_catalog.text_larger(text, text)
is 'larger of two';

create function pg_catalog.text_smaller(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.text_smaller
;

comment on function pg_catalog.text_smaller(text, text)
is 'smaller of two';

create function pg_catalog.int8in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8in
;

comment on function pg_catalog.int8in(cstring)
is 'I/O';

create function pg_catalog.int8out(bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8out
;

comment on function pg_catalog.int8out(bigint)
is 'I/O';

create function pg_catalog.int8um(bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8um
;

comment on function pg_catalog.int8um(bigint)
is 'implementation of - operator';

create function pg_catalog.int8pl(bigint, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8pl
;

comment on function pg_catalog.int8pl(bigint, bigint)
is 'implementation of + operator';

create function pg_catalog.int8mi(bigint, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8mi
;

comment on function pg_catalog.int8mi(bigint, bigint)
is 'implementation of - operator';

create function pg_catalog.int8mul(bigint, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8mul
;

comment on function pg_catalog.int8mul(bigint, bigint)
is 'implementation of * operator';

create function pg_catalog.int8div(bigint, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8div
;

comment on function pg_catalog.int8div(bigint, bigint)
is 'implementation of / operator';

create function pg_catalog.int8eq(bigint, bigint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8eq
;

comment on function pg_catalog.int8eq(bigint, bigint)
is 'implementation of = operator';

create function pg_catalog.int8ne(bigint, bigint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8ne
;

comment on function pg_catalog.int8ne(bigint, bigint)
is 'implementation of <> operator';

create function pg_catalog.int8lt(bigint, bigint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8lt
;

comment on function pg_catalog.int8lt(bigint, bigint)
is 'implementation of < operator';

create function pg_catalog.int8gt(bigint, bigint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8gt
;

comment on function pg_catalog.int8gt(bigint, bigint)
is 'implementation of > operator';

create function pg_catalog.int8le(bigint, bigint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8le
;

comment on function pg_catalog.int8le(bigint, bigint)
is 'implementation of <= operator';

create function pg_catalog.int8ge(bigint, bigint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8ge
;

comment on function pg_catalog.int8ge(bigint, bigint)
is 'implementation of >= operator';

create function pg_catalog.int84eq(bigint, integer)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int84eq
;

comment on function pg_catalog.int84eq(bigint, integer)
is 'implementation of = operator';

create function pg_catalog.int84ne(bigint, integer)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int84ne
;

comment on function pg_catalog.int84ne(bigint, integer)
is 'implementation of <> operator';

create function pg_catalog.int84lt(bigint, integer)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int84lt
;

comment on function pg_catalog.int84lt(bigint, integer)
is 'implementation of < operator';

create function pg_catalog.int84gt(bigint, integer)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int84gt
;

comment on function pg_catalog.int84gt(bigint, integer)
is 'implementation of > operator';

create function pg_catalog.int84le(bigint, integer)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int84le
;

comment on function pg_catalog.int84le(bigint, integer)
is 'implementation of <= operator';

create function pg_catalog.int84ge(bigint, integer)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int84ge
;

comment on function pg_catalog.int84ge(bigint, integer)
is 'implementation of >= operator';

create function pg_catalog.int4(bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4
;

comment on function pg_catalog.int4(bigint)
is 'convert int8 to int4';

create function pg_catalog.int8(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8
;

comment on function pg_catalog.int8(integer)
is 'convert int4 to int8';

create function pg_catalog.float8(bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8
;

comment on function pg_catalog.float8(bigint)
is 'convert int8 to float8';

create function pg_catalog.int8(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8
;

comment on function pg_catalog.int8(double precision)
is 'convert float8 to int8';

create function pg_catalog.array_larger(anyarray, anyarray)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_larger
;

comment on function pg_catalog.array_larger(anyarray, anyarray)
is 'larger of two';

create function pg_catalog.array_smaller(anyarray, anyarray)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_smaller
;

comment on function pg_catalog.array_smaller(anyarray, anyarray)
is 'smaller of two';

create function pg_catalog.abbrev(inet)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.abbrev
;

comment on function pg_catalog.abbrev(inet)
is 'abbreviated display of inet value';

create function pg_catalog.abbrev(cidr)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.abbrev
;

comment on function pg_catalog.abbrev(cidr)
is 'abbreviated display of cidr value';

create function pg_catalog.set_masklen(inet, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.set_masklen
;

comment on function pg_catalog.set_masklen(inet, integer)
is 'change netmask of inet';

create function pg_catalog.oidvectorne(oidvector, oidvector)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.oidvectorne
;

comment on function pg_catalog.oidvectorne(oidvector, oidvector)
is 'implementation of <> operator';

create function pg_catalog.hash_array(anyarray)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hash_array
;

comment on function pg_catalog.hash_array(anyarray)
is 'hash';

create function pg_catalog.set_masklen(cidr, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.set_masklen
;

comment on function pg_catalog.set_masklen(cidr, integer)
is 'change netmask of cidr';

create function pg_catalog.pg_indexam_has_property(oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_indexam_has_property
;

comment on function pg_catalog.pg_indexam_has_property(oid, text)
is 'test property of an index access method';

create function pg_catalog.pg_index_has_property(regclass, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_index_has_property
;

comment on function pg_catalog.pg_index_has_property(regclass, text)
is 'test property of an index';

create function pg_catalog.pg_index_column_has_property(regclass, integer, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_index_column_has_property
;

comment on function pg_catalog.pg_index_column_has_property(regclass, integer, text)
is 'test property of an index column';

create function pg_catalog.float4(bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float4
;

comment on function pg_catalog.float4(bigint)
is 'convert int8 to float4';

create function pg_catalog.int8(real)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8
;

comment on function pg_catalog.int8(real)
is 'convert float4 to int8';

create function pg_catalog.namelt(name, name)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.namelt
;

comment on function pg_catalog.namelt(name, name)
is 'implementation of < operator';

create function pg_catalog.namele(name, name)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.namele
;

comment on function pg_catalog.namele(name, name)
is 'implementation of <= operator';

create function pg_catalog.namegt(name, name)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.namegt
;

comment on function pg_catalog.namegt(name, name)
is 'implementation of > operator';

create function pg_catalog.namege(name, name)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.namege
;

comment on function pg_catalog.namege(name, name)
is 'implementation of >= operator';

create function pg_catalog.namene(name, name)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.namene
;

comment on function pg_catalog.namene(name, name)
is 'implementation of <> operator';

create function pg_catalog.bpchar(char, integer, boolean)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpchar
;

comment on function pg_catalog.bpchar(char, integer, boolean)
is 'adjust char() to typmod length';

create function pg_catalog.varchar(varchar, integer, boolean)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.varchar
;

comment on function pg_catalog.varchar(varchar, integer, boolean)
is 'adjust varchar() to typmod length';

create function pg_catalog.mktinterval(abstime, abstime)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.mktinterval
;

comment on function pg_catalog.mktinterval(abstime, abstime)
is 'implementation of <#> operator';

create function pg_catalog.oidvectorlt(oidvector, oidvector)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.oidvectorlt
;

comment on function pg_catalog.oidvectorlt(oidvector, oidvector)
is 'implementation of < operator';

create function pg_catalog.oidvectorle(oidvector, oidvector)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.oidvectorle
;

comment on function pg_catalog.oidvectorle(oidvector, oidvector)
is 'implementation of <= operator';

create function pg_catalog.oidvectoreq(oidvector, oidvector)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.oidvectoreq
;

comment on function pg_catalog.oidvectoreq(oidvector, oidvector)
is 'implementation of = operator';

create function pg_catalog.oidvectorge(oidvector, oidvector)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.oidvectorge
;

comment on function pg_catalog.oidvectorge(oidvector, oidvector)
is 'implementation of >= operator';

create function pg_catalog.oidvectorgt(oidvector, oidvector)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.oidvectorgt
;

comment on function pg_catalog.oidvectorgt(oidvector, oidvector)
is 'implementation of > operator';

create function pg_catalog.network(inet)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.network
;

comment on function pg_catalog.network(inet)
is 'network part of address';

create function pg_catalog.netmask(inet)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.netmask
;

comment on function pg_catalog.netmask(inet)
is 'netmask of address';

create function pg_catalog.masklen(inet)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.masklen
;

comment on function pg_catalog.masklen(inet)
is 'netmask length';

create function pg_catalog.broadcast(inet)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.broadcast
;

comment on function pg_catalog.broadcast(inet)
is 'broadcast address of network';

create function pg_catalog.host(inet)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.host
;

comment on function pg_catalog.host(inet)
is 'show address octets only';

create function pg_catalog.getpgusername()
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.getpgusername
;

comment on function pg_catalog.getpgusername()
is 'deprecated, use current_user instead';

create function pg_catalog.family(inet)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.family
;

comment on function pg_catalog.family(inet)
is 'address family (4 for IPv4, 6 for IPv6)';

create function pg_catalog.int2(bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2
;

comment on function pg_catalog.int2(bigint)
is 'convert int8 to int2';

create function pg_catalog.lo_create(oid)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.lo_create
;

comment on function pg_catalog.lo_create(oid)
is 'large object create';

create function pg_catalog.oidlt(oid, oid)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.oidlt
;

comment on function pg_catalog.oidlt(oid, oid)
is 'implementation of < operator';

create function pg_catalog.oidle(oid, oid)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.oidle
;

comment on function pg_catalog.oidle(oid, oid)
is 'implementation of <= operator';

create function pg_catalog.octet_length(bytea)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.octet_length
;

comment on function pg_catalog.octet_length(bytea)
is 'octet length';

create function pg_catalog.get_byte(bytea, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.get_byte
;

comment on function pg_catalog.get_byte(bytea, integer)
is 'get byte';

create function pg_catalog.set_byte(bytea, integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.set_byte
;

comment on function pg_catalog.set_byte(bytea, integer, integer)
is 'set byte';

create function pg_catalog.get_bit(bytea, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.get_bit
;

comment on function pg_catalog.get_bit(bytea, integer)
is 'get bit';

create function pg_catalog.set_bit(bytea, integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.set_bit
;

comment on function pg_catalog.set_bit(bytea, integer, integer)
is 'set bit';

create function pg_catalog.dist_pl(point, line)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.dist_pl
;

comment on function pg_catalog.dist_pl(point, line)
is 'implementation of <-> operator';

create function pg_catalog.dist_lb(line, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.dist_lb
;

comment on function pg_catalog.dist_lb(line, box)
is 'implementation of <-> operator';

create function pg_catalog.dist_sl(lseg, line)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.dist_sl
;

comment on function pg_catalog.dist_sl(lseg, line)
is 'implementation of <-> operator';

create function pg_catalog.dist_cpoly(circle, polygon)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.dist_cpoly
;

comment on function pg_catalog.dist_cpoly(circle, polygon)
is 'implementation of <-> operator';

create function pg_catalog.poly_distance(polygon, polygon)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.poly_distance
;

comment on function pg_catalog.poly_distance(polygon, polygon)
is 'implementation of <-> operator';

create function pg_catalog.text(inet)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.text
;

comment on function pg_catalog.text(inet)
is 'show all parts of inet/cidr value';

create function pg_catalog.text_lt(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.text_lt
;

comment on function pg_catalog.text_lt(text, text)
is 'implementation of < operator';

create function pg_catalog.text_le(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.text_le
;

comment on function pg_catalog.text_le(text, text)
is 'implementation of <= operator';

create function pg_catalog.text_gt(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.text_gt
;

comment on function pg_catalog.text_gt(text, text)
is 'implementation of > operator';

create function pg_catalog.text_ge(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.text_ge
;

comment on function pg_catalog.text_ge(text, text)
is 'implementation of >= operator';

create function pg_catalog.array_eq(anyarray, anyarray)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_eq
;

comment on function pg_catalog.array_eq(anyarray, anyarray)
is 'implementation of = operator';

create function pg_catalog."current_user"()
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog."current_user"
;

comment on function pg_catalog."current_user"()
is 'current user name';

create function pg_catalog."session_user"()
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog."session_user"
;

comment on function pg_catalog."session_user"()
is 'session user name';

create function pg_catalog.array_dims(anyarray)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_dims
;

comment on function pg_catalog.array_dims(anyarray)
is 'array dimensions';

create function pg_catalog.array_ndims(anyarray)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_ndims
;

comment on function pg_catalog.array_ndims(anyarray)
is 'number of array dimensions';

create function pg_catalog.overlay(bytea, bytea, integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.overlay
;

comment on function pg_catalog.overlay(bytea, bytea, integer, integer)
is 'substitute portion of string';

create function pg_catalog.array_in(cstring, oid, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_in
;

comment on function pg_catalog.array_in(cstring, oid, integer)
is 'I/O';

create function pg_catalog.array_out(anyarray)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_out
;

comment on function pg_catalog.array_out(anyarray)
is 'I/O';

create function pg_catalog.overlay(bytea, bytea, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.overlay
;

comment on function pg_catalog.overlay(bytea, bytea, integer)
is 'substitute portion of string';

create function pg_catalog.trunc(macaddr)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.trunc
;

comment on function pg_catalog.trunc(macaddr)
is 'MACADDR manufacturer fields';

create function pg_catalog.int8(smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8
;

comment on function pg_catalog.int8(smallint)
is 'convert int2 to int8';

create function pg_catalog.smgrin(cstring)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.smgrin
;

comment on function pg_catalog.smgrin(cstring)
is 'I/O';

create function pg_catalog.smgrout(smgr)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.smgrout
;

comment on function pg_catalog.smgrout(smgr)
is 'I/O';

create function pg_catalog.smgreq(smgr, smgr)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.smgreq
;

comment on function pg_catalog.smgreq(smgr, smgr)
is 'storage manager';

create function pg_catalog.smgrne(smgr, smgr)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.smgrne
;

comment on function pg_catalog.smgrne(smgr, smgr)
is 'storage manager';

create function pg_catalog.lo_import(text)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.lo_import
;

comment on function pg_catalog.lo_import(text)
is 'large object import';

create function pg_catalog.lo_export(oid, text)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.lo_export
;

comment on function pg_catalog.lo_export(oid, text)
is 'large object export';

create function pg_catalog.int4inc(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4inc
;

comment on function pg_catalog.int4inc(integer)
is 'increment';

create function pg_catalog.lo_import(text, oid)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.lo_import
;

comment on function pg_catalog.lo_import(text, oid)
is 'large object import';

create function pg_catalog.int4larger(integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4larger
;

comment on function pg_catalog.int4larger(integer, integer)
is 'larger of two';

create function pg_catalog.int4smaller(integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4smaller
;

comment on function pg_catalog.int4smaller(integer, integer)
is 'smaller of two';

create function pg_catalog.int2larger(smallint, smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2larger
;

comment on function pg_catalog.int2larger(smallint, smallint)
is 'larger of two';

create function pg_catalog.int2smaller(smallint, smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2smaller
;

comment on function pg_catalog.int2smaller(smallint, smallint)
is 'smaller of two';

create function pg_catalog.hashvarlenaextended(internal, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hashvarlenaextended
;

comment on function pg_catalog.hashvarlenaextended(internal, bigint)
is 'hash';

create function pg_catalog.hashoidvectorextended(oidvector, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hashoidvectorextended
;

comment on function pg_catalog.hashoidvectorextended(oidvector, bigint)
is 'hash';

create function pg_catalog.hash_aclitem_extended(aclitem, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hash_aclitem_extended
;

comment on function pg_catalog.hash_aclitem_extended(aclitem, bigint)
is 'hash';

create function pg_catalog.hashmacaddrextended(macaddr, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hashmacaddrextended
;

comment on function pg_catalog.hashmacaddrextended(macaddr, bigint)
is 'hash';

create function pg_catalog.hashinetextended(inet, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hashinetextended
;

comment on function pg_catalog.hashinetextended(inet, bigint)
is 'hash';

create function pg_catalog.hash_numeric_extended(numeric, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hash_numeric_extended
;

comment on function pg_catalog.hash_numeric_extended(numeric, bigint)
is 'hash';

create function pg_catalog.hashmacaddr8extended(macaddr8, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hashmacaddr8extended
;

comment on function pg_catalog.hashmacaddr8extended(macaddr8, bigint)
is 'hash';

create function pg_catalog.hash_array_extended(anyarray, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hash_array_extended
;

comment on function pg_catalog.hash_array_extended(anyarray, bigint)
is 'hash';

create function pg_catalog.tintervaleq(tinterval, tinterval)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tintervaleq
;

comment on function pg_catalog.tintervaleq(tinterval, tinterval)
is 'implementation of = operator';

create function pg_catalog.tintervalne(tinterval, tinterval)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tintervalne
;

comment on function pg_catalog.tintervalne(tinterval, tinterval)
is 'implementation of <> operator';

create function pg_catalog.tintervallt(tinterval, tinterval)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tintervallt
;

comment on function pg_catalog.tintervallt(tinterval, tinterval)
is 'implementation of < operator';

create function pg_catalog.tintervalgt(tinterval, tinterval)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tintervalgt
;

comment on function pg_catalog.tintervalgt(tinterval, tinterval)
is 'implementation of > operator';

create function pg_catalog.tintervalle(tinterval, tinterval)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tintervalle
;

comment on function pg_catalog.tintervalle(tinterval, tinterval)
is 'implementation of <= operator';

create function pg_catalog.tintervalge(tinterval, tinterval)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tintervalge
;

comment on function pg_catalog.tintervalge(tinterval, tinterval)
is 'implementation of >= operator';

create function pg_catalog.pg_client_encoding()
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_client_encoding
;

comment on function pg_catalog.pg_client_encoding()
is 'encoding name of current database';

create function pg_catalog.current_query()
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.current_query
;

comment on function pg_catalog.current_query()
is 'get the currently executing query';

create function pg_catalog.macaddr_eq(macaddr, macaddr)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr_eq
;

comment on function pg_catalog.macaddr_eq(macaddr, macaddr)
is 'implementation of = operator';

create function pg_catalog.macaddr_lt(macaddr, macaddr)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr_lt
;

comment on function pg_catalog.macaddr_lt(macaddr, macaddr)
is 'implementation of < operator';

create function pg_catalog.macaddr_le(macaddr, macaddr)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr_le
;

comment on function pg_catalog.macaddr_le(macaddr, macaddr)
is 'implementation of <= operator';

create function pg_catalog.macaddr_gt(macaddr, macaddr)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr_gt
;

comment on function pg_catalog.macaddr_gt(macaddr, macaddr)
is 'implementation of > operator';

create function pg_catalog.macaddr_ge(macaddr, macaddr)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr_ge
;

comment on function pg_catalog.macaddr_ge(macaddr, macaddr)
is 'implementation of >= operator';

create function pg_catalog.macaddr_ne(macaddr, macaddr)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr_ne
;

comment on function pg_catalog.macaddr_ne(macaddr, macaddr)
is 'implementation of <> operator';

create function pg_catalog.macaddr_cmp(macaddr, macaddr)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr_cmp
;

comment on function pg_catalog.macaddr_cmp(macaddr, macaddr)
is 'less-equal-greater';

create function pg_catalog.int82pl(bigint, smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int82pl
;

comment on function pg_catalog.int82pl(bigint, smallint)
is 'implementation of + operator';

create function pg_catalog.int82mi(bigint, smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int82mi
;

comment on function pg_catalog.int82mi(bigint, smallint)
is 'implementation of - operator';

create function pg_catalog.int82mul(bigint, smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int82mul
;

comment on function pg_catalog.int82mul(bigint, smallint)
is 'implementation of * operator';

create function pg_catalog.int82div(bigint, smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int82div
;

comment on function pg_catalog.int82div(bigint, smallint)
is 'implementation of / operator';

create function pg_catalog.int28pl(smallint, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int28pl
;

comment on function pg_catalog.int28pl(smallint, bigint)
is 'implementation of + operator';

create function pg_catalog.btint8cmp(bigint, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btint8cmp
;

comment on function pg_catalog.btint8cmp(bigint, bigint)
is 'less-equal-greater';

create function pg_catalog.cash_mul_flt4(money, real)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cash_mul_flt4
;

comment on function pg_catalog.cash_mul_flt4(money, real)
is 'implementation of * operator';

create function pg_catalog.cash_div_flt4(money, real)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cash_div_flt4
;

comment on function pg_catalog.cash_div_flt4(money, real)
is 'implementation of / operator';

create function pg_catalog.flt4_mul_cash(real, money)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.flt4_mul_cash
;

comment on function pg_catalog.flt4_mul_cash(real, money)
is 'implementation of * operator';

create function pg_catalog.position(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.position
;

comment on function pg_catalog.position(text, text)
is 'position of substring';

create function pg_catalog.textlike(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.textlike
;

comment on function pg_catalog.textlike(text, text)
is 'implementation of ~~ operator';

create function pg_catalog.textnlike(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.textnlike
;

comment on function pg_catalog.textnlike(text, text)
is 'implementation of !~~ operator';

create function pg_catalog.int48eq(integer, bigint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int48eq
;

comment on function pg_catalog.int48eq(integer, bigint)
is 'implementation of = operator';

create function pg_catalog.int48ne(integer, bigint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int48ne
;

comment on function pg_catalog.int48ne(integer, bigint)
is 'implementation of <> operator';

create function pg_catalog.int48lt(integer, bigint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int48lt
;

comment on function pg_catalog.int48lt(integer, bigint)
is 'implementation of < operator';

create function pg_catalog.int48gt(integer, bigint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int48gt
;

comment on function pg_catalog.int48gt(integer, bigint)
is 'implementation of > operator';

create function pg_catalog.int48le(integer, bigint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int48le
;

comment on function pg_catalog.int48le(integer, bigint)
is 'implementation of <= operator';

create function pg_catalog.int48ge(integer, bigint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int48ge
;

comment on function pg_catalog.int48ge(integer, bigint)
is 'implementation of >= operator';

create function pg_catalog.namelike(name, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.namelike
;

comment on function pg_catalog.namelike(name, text)
is 'implementation of ~~ operator';

create function pg_catalog.namenlike(name, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.namenlike
;

comment on function pg_catalog.namenlike(name, text)
is 'implementation of !~~ operator';

create function pg_catalog.bpchar("char")
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpchar
;

comment on function pg_catalog.bpchar("char")
is 'convert char to char(n)';

create function pg_catalog.current_database()
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.current_database
;

comment on function pg_catalog.current_database()
is 'name of the current database';

create function pg_catalog.int4_mul_cash(integer, money)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4_mul_cash
;

comment on function pg_catalog.int4_mul_cash(integer, money)
is 'implementation of * operator';

create function pg_catalog.int2_mul_cash(smallint, money)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2_mul_cash
;

comment on function pg_catalog.int2_mul_cash(smallint, money)
is 'implementation of * operator';

create function pg_catalog.cash_mul_int4(money, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cash_mul_int4
;

comment on function pg_catalog.cash_mul_int4(money, integer)
is 'implementation of * operator';

create function pg_catalog.cash_div_int4(money, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cash_div_int4
;

comment on function pg_catalog.cash_div_int4(money, integer)
is 'implementation of / operator';

create function pg_catalog.cash_mul_int2(money, smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cash_mul_int2
;

comment on function pg_catalog.cash_mul_int2(money, smallint)
is 'implementation of * operator';

create function pg_catalog.cash_div_int2(money, smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cash_div_int2
;

comment on function pg_catalog.cash_div_int2(money, smallint)
is 'implementation of / operator';

create function pg_catalog.strpos(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.strpos
;

comment on function pg_catalog.strpos(text, text)
is 'position of substring';

create function pg_catalog.lower(text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lower
;

comment on function pg_catalog.lower(text)
is 'lowercase';

create function pg_catalog.upper(text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.upper
;

comment on function pg_catalog.upper(text)
is 'uppercase';

create function pg_catalog.initcap(text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.initcap
;

comment on function pg_catalog.initcap(text)
is 'capitalize each word';

create function pg_catalog.lpad(text, integer, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lpad
;

comment on function pg_catalog.lpad(text, integer, text)
is 'left-pad string to length';

create function pg_catalog.rpad(text, integer, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.rpad
;

comment on function pg_catalog.rpad(text, integer, text)
is 'right-pad string to length';

create function pg_catalog.ltrim(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ltrim
;

comment on function pg_catalog.ltrim(text, text)
is 'trim selected characters from left end of string';

create function pg_catalog.rtrim(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.rtrim
;

comment on function pg_catalog.rtrim(text, text)
is 'trim selected characters from right end of string';

create function pg_catalog.substr(text, integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.substr
;

comment on function pg_catalog.substr(text, integer, integer)
is 'extract portion of string';

create function pg_catalog.translate(text, text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.translate
;

comment on function pg_catalog.translate(text, text, text)
is 'map a set of characters appearing in string';

create function pg_catalog.lpad(text, integer)
  returns text
immutable
strict
parallel safe
cost 1
language sql
as $$
select pg_catalog.lpad($1, $2, ' ')
$$;

comment on function pg_catalog.lpad(text, integer)
is 'left-pad string to length';

create function pg_catalog.rpad(text, integer)
  returns text
immutable
strict
parallel safe
cost 1
language sql
as $$
select pg_catalog.rpad($1, $2, ' ')
$$;

comment on function pg_catalog.rpad(text, integer)
is 'right-pad string to length';

create function pg_catalog.ltrim(text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ltrim
;

comment on function pg_catalog.ltrim(text)
is 'trim spaces from left end of string';

create function pg_catalog.rtrim(text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.rtrim
;

comment on function pg_catalog.rtrim(text)
is 'trim spaces from right end of string';

create function pg_catalog.substr(text, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.substr
;

comment on function pg_catalog.substr(text, integer)
is 'extract portion of string';

create function pg_catalog.btrim(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btrim
;

comment on function pg_catalog.btrim(text, text)
is 'trim selected characters from both ends of string';

create function pg_catalog.btrim(text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btrim
;

comment on function pg_catalog.btrim(text)
is 'trim spaces from both ends of string';

create function pg_catalog.cash_in(cstring)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cash_in
;

comment on function pg_catalog.cash_in(cstring)
is 'I/O';

create function pg_catalog.cash_out(money)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cash_out
;

comment on function pg_catalog.cash_out(money)
is 'I/O';

create function pg_catalog.cash_eq(money, money)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cash_eq
;

comment on function pg_catalog.cash_eq(money, money)
is 'implementation of = operator';

create function pg_catalog.cash_ne(money, money)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cash_ne
;

comment on function pg_catalog.cash_ne(money, money)
is 'implementation of <> operator';

create function pg_catalog.cash_lt(money, money)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cash_lt
;

comment on function pg_catalog.cash_lt(money, money)
is 'implementation of < operator';

create function pg_catalog.cash_le(money, money)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cash_le
;

comment on function pg_catalog.cash_le(money, money)
is 'implementation of <= operator';

create function pg_catalog.cash_gt(money, money)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cash_gt
;

comment on function pg_catalog.cash_gt(money, money)
is 'implementation of > operator';

create function pg_catalog.cash_ge(money, money)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cash_ge
;

comment on function pg_catalog.cash_ge(money, money)
is 'implementation of >= operator';

create function pg_catalog.cash_pl(money, money)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cash_pl
;

comment on function pg_catalog.cash_pl(money, money)
is 'implementation of + operator';

create function pg_catalog.cash_mi(money, money)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cash_mi
;

comment on function pg_catalog.cash_mi(money, money)
is 'implementation of - operator';

create function pg_catalog.cash_mul_flt8(money, double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cash_mul_flt8
;

comment on function pg_catalog.cash_mul_flt8(money, double precision)
is 'implementation of * operator';

create function pg_catalog.cash_div_flt8(money, double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cash_div_flt8
;

comment on function pg_catalog.cash_div_flt8(money, double precision)
is 'implementation of / operator';

create function pg_catalog.cashlarger(money, money)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cashlarger
;

comment on function pg_catalog.cashlarger(money, money)
is 'larger of two';

create function pg_catalog.cashsmaller(money, money)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cashsmaller
;

comment on function pg_catalog.cashsmaller(money, money)
is 'smaller of two';

create function pg_catalog.inet_in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inet_in
;

comment on function pg_catalog.inet_in(cstring)
is 'I/O';

create function pg_catalog.inet_out(inet)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inet_out
;

comment on function pg_catalog.inet_out(inet)
is 'I/O';

create function pg_catalog.flt8_mul_cash(double precision, money)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.flt8_mul_cash
;

comment on function pg_catalog.flt8_mul_cash(double precision, money)
is 'implementation of * operator';

create function pg_catalog.network_eq(inet, inet)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.network_eq
;

comment on function pg_catalog.network_eq(inet, inet)
is 'implementation of = operator';

create function pg_catalog.network_lt(inet, inet)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.network_lt
;

comment on function pg_catalog.network_lt(inet, inet)
is 'implementation of < operator';

create function pg_catalog.network_le(inet, inet)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.network_le
;

comment on function pg_catalog.network_le(inet, inet)
is 'implementation of <= operator';

create function pg_catalog.network_gt(inet, inet)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.network_gt
;

comment on function pg_catalog.network_gt(inet, inet)
is 'implementation of > operator';

create function pg_catalog.network_ge(inet, inet)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.network_ge
;

comment on function pg_catalog.network_ge(inet, inet)
is 'implementation of >= operator';

create function pg_catalog.network_ne(inet, inet)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.network_ne
;

comment on function pg_catalog.network_ne(inet, inet)
is 'implementation of <> operator';

create function pg_catalog.network_cmp(inet, inet)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.network_cmp
;

comment on function pg_catalog.network_cmp(inet, inet)
is 'less-equal-greater';

create function pg_catalog.network_sub(inet, inet)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.network_sub
;

comment on function pg_catalog.network_sub(inet, inet)
is 'implementation of << operator';

create function pg_catalog.network_subeq(inet, inet)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.network_subeq
;

comment on function pg_catalog.network_subeq(inet, inet)
is 'implementation of <<= operator';

create function pg_catalog.network_sup(inet, inet)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.network_sup
;

comment on function pg_catalog.network_sup(inet, inet)
is 'implementation of >> operator';

create function pg_catalog.network_supeq(inet, inet)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.network_supeq
;

comment on function pg_catalog.network_supeq(inet, inet)
is 'implementation of >>= operator';

create function pg_catalog.cash_words(money)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cash_words
;

comment on function pg_catalog.cash_words(money)
is 'output money amount as words';

create function pg_catalog.substring(text, integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.substring
;

comment on function pg_catalog.substring(text, integer, integer)
is 'extract portion of string';

create function pg_catalog.substring(text, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.substring
;

comment on function pg_catalog.substring(text, integer)
is 'extract portion of string';

create function pg_catalog.generate_series(timestamp, timestamp, interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.generate_series
;

comment on function pg_catalog.generate_series(timestamp, timestamp, interval)
is 'non-persistent series generator';

create function pg_catalog.generate_series(timestamp with time zone, timestamp with time zone, interval)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.generate_series
;

comment on function pg_catalog.generate_series(timestamp with time zone, timestamp with time zone, interval)
is 'non-persistent series generator';

create function pg_catalog.mod(smallint, smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.mod
;

comment on function pg_catalog.mod(smallint, smallint)
is 'modulus';

create function pg_catalog.mod(integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.mod
;

comment on function pg_catalog.mod(integer, integer)
is 'modulus';

create function pg_catalog.int28mi(smallint, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int28mi
;

comment on function pg_catalog.int28mi(smallint, bigint)
is 'implementation of - operator';

create function pg_catalog.int28mul(smallint, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int28mul
;

comment on function pg_catalog.int28mul(smallint, bigint)
is 'implementation of * operator';

create function pg_catalog.char(text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.char
;

comment on function pg_catalog.char(text)
is 'convert text to char';

create function pg_catalog.int8mod(bigint, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8mod
;

comment on function pg_catalog.int8mod(bigint, bigint)
is 'implementation of % operator';

create function pg_catalog.text("char")
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.text
;

comment on function pg_catalog.text("char")
is 'convert char to text';

create function pg_catalog.mod(bigint, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.mod
;

comment on function pg_catalog.mod(bigint, bigint)
is 'modulus';

create function pg_catalog.int28div(smallint, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int28div
;

comment on function pg_catalog.int28div(smallint, bigint)
is 'implementation of / operator';

create function pg_catalog.hashint8(bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hashint8
;

comment on function pg_catalog.hashint8(bigint)
is 'hash';

create function pg_catalog.lo_open(oid, integer)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.lo_open
;

comment on function pg_catalog.lo_open(oid, integer)
is 'large object open';

create function pg_catalog.lo_close(integer)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.lo_close
;

comment on function pg_catalog.lo_close(integer)
is 'large object close';

create function pg_catalog.loread(integer, integer)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.loread
;

comment on function pg_catalog.loread(integer, integer)
is 'large object read';

create function pg_catalog.lowrite(integer, bytea)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.lowrite
;

comment on function pg_catalog.lowrite(integer, bytea)
is 'large object write';

create function pg_catalog.lo_lseek(integer, integer, integer)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.lo_lseek
;

comment on function pg_catalog.lo_lseek(integer, integer, integer)
is 'large object seek';

create function pg_catalog.lo_creat(integer)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.lo_creat
;

comment on function pg_catalog.lo_creat(integer)
is 'large object create';

create function pg_catalog.lo_tell(integer)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.lo_tell
;

comment on function pg_catalog.lo_tell(integer)
is 'large object position';

create function pg_catalog.on_pl(point, line)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.on_pl
;

comment on function pg_catalog.on_pl(point, line)
is 'implementation of <@ operator';

create function pg_catalog.on_sl(lseg, line)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.on_sl
;

comment on function pg_catalog.on_sl(lseg, line)
is 'implementation of <@ operator';

create function pg_catalog.close_pl(point, line)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.close_pl
;

comment on function pg_catalog.close_pl(point, line)
is 'implementation of ## operator';

create function pg_catalog.close_sl(lseg, line)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.close_sl
;

comment on function pg_catalog.close_sl(lseg, line)
is 'implementation of ## operator';

create function pg_catalog.close_lb(line, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.close_lb
;

comment on function pg_catalog.close_lb(line, box)
is 'implementation of ## operator';

create function pg_catalog.lo_unlink(oid)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.lo_unlink
;

comment on function pg_catalog.lo_unlink(oid)
is 'large object unlink (delete)';

create function pg_catalog.hashbpcharextended(char, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hashbpcharextended
;

comment on function pg_catalog.hashbpcharextended(char, bigint)
is 'hash';

create function pg_catalog.path_inter(path, path)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.path_inter
;

comment on function pg_catalog.path_inter(path, path)
is 'implementation of ?# operator';

create function pg_catalog.area(box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.area
;

comment on function pg_catalog.area(box)
is 'box area';

create function pg_catalog.width(box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.width
;

comment on function pg_catalog.width(box)
is 'box width';

create function pg_catalog.height(box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.height
;

comment on function pg_catalog.height(box)
is 'box height';

create function pg_catalog.box_distance(box, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_distance
;

comment on function pg_catalog.box_distance(box, box)
is 'implementation of <-> operator';

create function pg_catalog.area(path)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.area
;

comment on function pg_catalog.area(path)
is 'area of a closed path';

create function pg_catalog.box_intersect(box, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_intersect
;

comment on function pg_catalog.box_intersect(box, box)
is 'implementation of # operator';

create function pg_catalog.diagonal(box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.diagonal
;

comment on function pg_catalog.diagonal(box)
is 'box diagonal';

create function pg_catalog.path_n_lt(path, path)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.path_n_lt
;

comment on function pg_catalog.path_n_lt(path, path)
is 'implementation of < operator';

create function pg_catalog.path_n_gt(path, path)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.path_n_gt
;

comment on function pg_catalog.path_n_gt(path, path)
is 'implementation of > operator';

create function pg_catalog.path_n_eq(path, path)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.path_n_eq
;

comment on function pg_catalog.path_n_eq(path, path)
is 'implementation of = operator';

create function pg_catalog.path_n_le(path, path)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.path_n_le
;

comment on function pg_catalog.path_n_le(path, path)
is 'implementation of <= operator';

create function pg_catalog.path_n_ge(path, path)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.path_n_ge
;

comment on function pg_catalog.path_n_ge(path, path)
is 'implementation of >= operator';

create function pg_catalog.path_length(path)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.path_length
;

comment on function pg_catalog.path_length(path)
is 'implementation of @-@ operator';

create function pg_catalog.point_ne(point, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.point_ne
;

comment on function pg_catalog.point_ne(point, point)
is 'implementation of <> operator';

create function pg_catalog.point_vert(point, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.point_vert
;

comment on function pg_catalog.point_vert(point, point)
is 'implementation of ?| operator';

create function pg_catalog.point_horiz(point, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.point_horiz
;

comment on function pg_catalog.point_horiz(point, point)
is 'implementation of ?- operator';

create function pg_catalog.point_distance(point, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.point_distance
;

comment on function pg_catalog.point_distance(point, point)
is 'implementation of <-> operator';

create function pg_catalog.slope(point, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.slope
;

comment on function pg_catalog.slope(point, point)
is 'slope between points';

create function pg_catalog.lseg(point, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lseg
;

comment on function pg_catalog.lseg(point, point)
is 'convert points to line segment';

create function pg_catalog.lseg_intersect(lseg, lseg)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lseg_intersect
;

comment on function pg_catalog.lseg_intersect(lseg, lseg)
is 'implementation of ?# operator';

create function pg_catalog.lseg_parallel(lseg, lseg)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lseg_parallel
;

comment on function pg_catalog.lseg_parallel(lseg, lseg)
is 'implementation of ?|| operator';

create function pg_catalog.lseg_perp(lseg, lseg)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lseg_perp
;

comment on function pg_catalog.lseg_perp(lseg, lseg)
is 'implementation of ?-| operator';

create function pg_catalog.lseg_vertical(lseg)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lseg_vertical
;

comment on function pg_catalog.lseg_vertical(lseg)
is 'implementation of ?| operator';

create function pg_catalog.lseg_horizontal(lseg)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lseg_horizontal
;

comment on function pg_catalog.lseg_horizontal(lseg)
is 'implementation of ?- operator';

create function pg_catalog.lseg_eq(lseg, lseg)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lseg_eq
;

comment on function pg_catalog.lseg_eq(lseg, lseg)
is 'implementation of = operator';

create function pg_catalog.lo_truncate(integer, integer)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.lo_truncate
;

comment on function pg_catalog.lo_truncate(integer, integer)
is 'truncate large object';

create function pg_catalog.timezone(interval, timestamp with time zone)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timezone
;

comment on function pg_catalog.timezone(interval, timestamp with time zone)
is 'adjust timestamp to new time zone';

create function pg_catalog.gist_point_compress(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gist_point_compress
;

comment on function pg_catalog.gist_point_compress(internal)
is 'GiST support';

create function pg_catalog.aclitemin(cstring)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.aclitemin
;

comment on function pg_catalog.aclitemin(cstring)
is 'I/O';

create function pg_catalog.aclitemout(aclitem)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.aclitemout
;

comment on function pg_catalog.aclitemout(aclitem)
is 'I/O';

create function pg_catalog.aclinsert(aclitem [], aclitem)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.aclinsert
;

comment on function pg_catalog.aclinsert(aclitem [], aclitem)
is 'add/update ACL item';

create function pg_catalog.aclremove(aclitem [], aclitem)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.aclremove
;

comment on function pg_catalog.aclremove(aclitem [], aclitem)
is 'remove ACL item';

create function pg_catalog.aclcontains(aclitem [], aclitem)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.aclcontains
;

comment on function pg_catalog.aclcontains(aclitem [], aclitem)
is 'contains';

create function pg_catalog.getdatabaseencoding()
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.getdatabaseencoding
;

comment on function pg_catalog.getdatabaseencoding()
is 'encoding name of current database';

create function pg_catalog.bpcharin(cstring, oid, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpcharin
;

comment on function pg_catalog.bpcharin(cstring, oid, integer)
is 'I/O';

create function pg_catalog.bpcharout(char)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpcharout
;

comment on function pg_catalog.bpcharout(char)
is 'I/O';

create function pg_catalog.varcharin(cstring, oid, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.varcharin
;

comment on function pg_catalog.varcharin(cstring, oid, integer)
is 'I/O';

create function pg_catalog.varcharout(varchar)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.varcharout
;

comment on function pg_catalog.varcharout(varchar)
is 'I/O';

create function pg_catalog.bpchareq(char, char)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpchareq
;

comment on function pg_catalog.bpchareq(char, char)
is 'implementation of = operator';

create function pg_catalog.bpcharlt(char, char)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpcharlt
;

comment on function pg_catalog.bpcharlt(char, char)
is 'implementation of < operator';

create function pg_catalog.bpcharle(char, char)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpcharle
;

comment on function pg_catalog.bpcharle(char, char)
is 'implementation of <= operator';

create function pg_catalog.bpchargt(char, char)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpchargt
;

comment on function pg_catalog.bpchargt(char, char)
is 'implementation of > operator';

create function pg_catalog.bpcharge(char, char)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpcharge
;

comment on function pg_catalog.bpcharge(char, char)
is 'implementation of >= operator';

create function pg_catalog.bpcharne(char, char)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpcharne
;

comment on function pg_catalog.bpcharne(char, char)
is 'implementation of <> operator';

create function pg_catalog.aclitemeq(aclitem, aclitem)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.aclitemeq
;

comment on function pg_catalog.aclitemeq(aclitem, aclitem)
is 'implementation of = operator';

create function pg_catalog.bpchar_larger(char, char)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpchar_larger
;

comment on function pg_catalog.bpchar_larger(char, char)
is 'larger of two';

create function pg_catalog.bpchar_smaller(char, char)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpchar_smaller
;

comment on function pg_catalog.bpchar_smaller(char, char)
is 'smaller of two';

create function pg_catalog.pg_prepared_xact(out transaction xid, out gid text, out prepared timestamp with time zone,
                                            out ownerid     oid, out dbid oid)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_prepared_xact
;

comment on function pg_catalog.pg_prepared_xact(out xid, out text, out timestamp with time zone, out oid, out oid)
is 'view two-phase transactions';

create function pg_catalog.generate_series(integer, integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.generate_series
;

comment on function pg_catalog.generate_series(integer, integer, integer)
is 'non-persistent series generator';

create function pg_catalog.generate_series(integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.generate_series
;

comment on function pg_catalog.generate_series(integer, integer)
is 'non-persistent series generator';

create function pg_catalog.generate_series(bigint, bigint, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.generate_series
;

comment on function pg_catalog.generate_series(bigint, bigint, bigint)
is 'non-persistent series generator';

create function pg_catalog.generate_series(bigint, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.generate_series
;

comment on function pg_catalog.generate_series(bigint, bigint)
is 'non-persistent series generator';

create function pg_catalog.bpcharcmp(char, char)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpcharcmp
;

comment on function pg_catalog.bpcharcmp(char, char)
is 'less-equal-greater';

create function pg_catalog.regclass(text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regclass
;

comment on function pg_catalog.regclass(text)
is 'convert text to regclass';

create function pg_catalog.hashbpchar(char)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hashbpchar
;

comment on function pg_catalog.hashbpchar(char)
is 'hash';

create function pg_catalog.format_type(oid, integer)
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.format_type
;

comment on function pg_catalog.format_type(oid, integer)
is 'format a type oid and atttypmod to canonical SQL';

create function pg_catalog.date_in(cstring)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_in
;

comment on function pg_catalog.date_in(cstring)
is 'I/O';

create function pg_catalog.date_out(date)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_out
;

comment on function pg_catalog.date_out(date)
is 'I/O';

create function pg_catalog.date_eq(date, date)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_eq
;

comment on function pg_catalog.date_eq(date, date)
is 'implementation of = operator';

create function pg_catalog.date_lt(date, date)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_lt
;

comment on function pg_catalog.date_lt(date, date)
is 'implementation of < operator';

create function pg_catalog.date_le(date, date)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_le
;

comment on function pg_catalog.date_le(date, date)
is 'implementation of <= operator';

create function pg_catalog.date_gt(date, date)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_gt
;

comment on function pg_catalog.date_gt(date, date)
is 'implementation of > operator';

create function pg_catalog.date_ge(date, date)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_ge
;

comment on function pg_catalog.date_ge(date, date)
is 'implementation of >= operator';

create function pg_catalog.date_ne(date, date)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_ne
;

comment on function pg_catalog.date_ne(date, date)
is 'implementation of <> operator';

create function pg_catalog.date_cmp(date, date)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_cmp
;

comment on function pg_catalog.date_cmp(date, date)
is 'less-equal-greater';

create function pg_catalog.time_lt(time, time)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.time_lt
;

comment on function pg_catalog.time_lt(time, time)
is 'implementation of < operator';

create function pg_catalog.time_le(time, time)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.time_le
;

comment on function pg_catalog.time_le(time, time)
is 'implementation of <= operator';

create function pg_catalog.time_gt(time, time)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.time_gt
;

comment on function pg_catalog.time_gt(time, time)
is 'implementation of > operator';

create function pg_catalog.time_ge(time, time)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.time_ge
;

comment on function pg_catalog.time_ge(time, time)
is 'implementation of >= operator';

create function pg_catalog.time_ne(time, time)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.time_ne
;

comment on function pg_catalog.time_ne(time, time)
is 'implementation of <> operator';

create function pg_catalog.time_cmp(time, time)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.time_cmp
;

comment on function pg_catalog.time_cmp(time, time)
is 'less-equal-greater';

create function pg_catalog.date_larger(date, date)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_larger
;

comment on function pg_catalog.date_larger(date, date)
is 'larger of two';

create function pg_catalog.date_smaller(date, date)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_smaller
;

comment on function pg_catalog.date_smaller(date, date)
is 'smaller of two';

create function pg_catalog.date_mi(date, date)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_mi
;

comment on function pg_catalog.date_mi(date, date)
is 'implementation of - operator';

create function pg_catalog.date_pli(date, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_pli
;

comment on function pg_catalog.date_pli(date, integer)
is 'implementation of + operator';

create function pg_catalog.date_mii(date, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_mii
;

comment on function pg_catalog.date_mii(date, integer)
is 'implementation of - operator';

create function pg_catalog.time_in(cstring, oid, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.time_in
;

comment on function pg_catalog.time_in(cstring, oid, integer)
is 'I/O';

create function pg_catalog.time_out(time)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.time_out
;

comment on function pg_catalog.time_out(time)
is 'I/O';

create function pg_catalog.time_eq(time, time)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.time_eq
;

comment on function pg_catalog.time_eq(time, time)
is 'implementation of = operator';

create function pg_catalog.circle_add_pt(circle, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_add_pt
;

comment on function pg_catalog.circle_add_pt(circle, point)
is 'implementation of + operator';

create function pg_catalog.circle_sub_pt(circle, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_sub_pt
;

comment on function pg_catalog.circle_sub_pt(circle, point)
is 'implementation of - operator';

create function pg_catalog.circle_mul_pt(circle, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_mul_pt
;

comment on function pg_catalog.circle_mul_pt(circle, point)
is 'implementation of * operator';

create function pg_catalog.circle_div_pt(circle, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_div_pt
;

comment on function pg_catalog.circle_div_pt(circle, point)
is 'implementation of / operator';

create function pg_catalog.timestamptz_in(cstring, oid, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_in
;

comment on function pg_catalog.timestamptz_in(cstring, oid, integer)
is 'I/O';

create function pg_catalog.timestamptz_out(timestamp with time zone)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_out
;

comment on function pg_catalog.timestamptz_out(timestamp with time zone)
is 'I/O';

create function pg_catalog.timestamptz_eq(timestamp with time zone, timestamp with time zone)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_eq
;

comment on function pg_catalog.timestamptz_eq(timestamp with time zone, timestamp with time zone)
is 'implementation of = operator';

create function pg_catalog.timestamptz_ne(timestamp with time zone, timestamp with time zone)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_ne
;

comment on function pg_catalog.timestamptz_ne(timestamp with time zone, timestamp with time zone)
is 'implementation of <> operator';

create function pg_catalog.timestamptz_lt(timestamp with time zone, timestamp with time zone)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_lt
;

comment on function pg_catalog.timestamptz_lt(timestamp with time zone, timestamp with time zone)
is 'implementation of < operator';

create function pg_catalog.timestamptz_le(timestamp with time zone, timestamp with time zone)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_le
;

comment on function pg_catalog.timestamptz_le(timestamp with time zone, timestamp with time zone)
is 'implementation of <= operator';

create function pg_catalog.timestamptz_ge(timestamp with time zone, timestamp with time zone)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_ge
;

comment on function pg_catalog.timestamptz_ge(timestamp with time zone, timestamp with time zone)
is 'implementation of >= operator';

create function pg_catalog.timestamptz_gt(timestamp with time zone, timestamp with time zone)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_gt
;

comment on function pg_catalog.timestamptz_gt(timestamp with time zone, timestamp with time zone)
is 'implementation of > operator';

create function pg_catalog.to_timestamp(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.to_timestamp
;

comment on function pg_catalog.to_timestamp(double precision)
is 'convert UNIX epoch to timestamptz';

create function pg_catalog.timezone(text, timestamp with time zone)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timezone
;

comment on function pg_catalog.timezone(text, timestamp with time zone)
is 'adjust timestamp to new time zone';

create function pg_catalog.interval_in(cstring, oid, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.interval_in
;

comment on function pg_catalog.interval_in(cstring, oid, integer)
is 'I/O';

create function pg_catalog.interval_out(interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.interval_out
;

comment on function pg_catalog.interval_out(interval)
is 'I/O';

create function pg_catalog.interval_eq(interval, interval)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.interval_eq
;

comment on function pg_catalog.interval_eq(interval, interval)
is 'implementation of = operator';

create function pg_catalog.interval_ne(interval, interval)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.interval_ne
;

comment on function pg_catalog.interval_ne(interval, interval)
is 'implementation of <> operator';

create function pg_catalog.interval_lt(interval, interval)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.interval_lt
;

comment on function pg_catalog.interval_lt(interval, interval)
is 'implementation of < operator';

create function pg_catalog.interval_le(interval, interval)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.interval_le
;

comment on function pg_catalog.interval_le(interval, interval)
is 'implementation of <= operator';

create function pg_catalog.interval_ge(interval, interval)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.interval_ge
;

comment on function pg_catalog.interval_ge(interval, interval)
is 'implementation of >= operator';

create function pg_catalog.interval_gt(interval, interval)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.interval_gt
;

comment on function pg_catalog.interval_gt(interval, interval)
is 'implementation of > operator';

create function pg_catalog.interval_um(interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.interval_um
;

comment on function pg_catalog.interval_um(interval)
is 'implementation of - operator';

create function pg_catalog.interval_pl(interval, interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.interval_pl
;

comment on function pg_catalog.interval_pl(interval, interval)
is 'implementation of + operator';

create function pg_catalog.interval_mi(interval, interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.interval_mi
;

comment on function pg_catalog.interval_mi(interval, interval)
is 'implementation of - operator';

create function pg_catalog.date_part(text, timestamp with time zone)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_part
;

comment on function pg_catalog.date_part(text, timestamp with time zone)
is 'extract field from timestamp with time zone';

create function pg_catalog.date_part(text, interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_part
;

comment on function pg_catalog.date_part(text, interval)
is 'extract field from interval';

create function pg_catalog.timestamptz(abstime)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz
;

comment on function pg_catalog.timestamptz(abstime)
is 'convert abstime to timestamp with time zone';

create function pg_catalog.timestamptz(date)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz
;

comment on function pg_catalog.timestamptz(date)
is 'convert date to timestamp with time zone';

create function pg_catalog.justify_hours(interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.justify_hours
;

comment on function pg_catalog.justify_hours(interval)
is 'promote groups of 24 hours to numbers of days';

create function pg_catalog.timestamptz(date, time without time zone)
  returns timestamp with time zone
stable
strict
parallel safe
cost 1
language sql
as $$
select cast(($1 + $2) as timestamp with time zone)
$$;

comment on function pg_catalog.timestamptz(date, time)
is 'convert date and time to timestamp with time zone';

create function pg_catalog.interval(reltime)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.interval
;

comment on function pg_catalog.interval(reltime)
is 'convert reltime to interval';

create function pg_catalog.date(timestamp with time zone)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date
;

comment on function pg_catalog.date(timestamp with time zone)
is 'convert timestamp with time zone to date';

create function pg_catalog.date(abstime)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date
;

comment on function pg_catalog.date(abstime)
is 'convert abstime to date';

create function pg_catalog.abstime(timestamp with time zone)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.abstime
;

comment on function pg_catalog.abstime(timestamp with time zone)
is 'convert timestamp with time zone to abstime';

create function pg_catalog.age(xid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.age
;

comment on function pg_catalog.age(xid)
is 'age of a transaction ID, in transactions before current transaction';

create function pg_catalog.timestamptz_mi(timestamp with time zone, timestamp with time zone)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_mi
;

comment on function pg_catalog.timestamptz_mi(timestamp with time zone, timestamp with time zone)
is 'implementation of - operator';

create function pg_catalog.timestamptz_pl_interval(timestamp with time zone, interval)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_pl_interval
;

comment on function pg_catalog.timestamptz_pl_interval(timestamp with time zone, interval)
is 'implementation of + operator';

create function pg_catalog.timestamptz_mi_interval(timestamp with time zone, interval)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_mi_interval
;

comment on function pg_catalog.timestamptz_mi_interval(timestamp with time zone, interval)
is 'implementation of - operator';

create function pg_catalog.generate_subscripts(anyarray, integer, boolean)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.generate_subscripts
;

comment on function pg_catalog.generate_subscripts(anyarray, integer, boolean)
is 'array subscripts generator';

create function pg_catalog.generate_subscripts(anyarray, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.generate_subscripts
;

comment on function pg_catalog.generate_subscripts(anyarray, integer)
is 'array subscripts generator';

create function pg_catalog.array_fill(anyelement, integer [])
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_fill
;

comment on function pg_catalog.array_fill(anyelement, integer [])
is 'array constructor with value';

create function pg_catalog.reltime(interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.reltime
;

comment on function pg_catalog.reltime(interval)
is 'convert interval to reltime';

create function pg_catalog.timestamptz_smaller(timestamp with time zone, timestamp with time zone)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_smaller
;

comment on function pg_catalog.timestamptz_smaller(timestamp with time zone, timestamp with time zone)
is 'smaller of two';

create function pg_catalog.timestamptz_larger(timestamp with time zone, timestamp with time zone)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_larger
;

comment on function pg_catalog.timestamptz_larger(timestamp with time zone, timestamp with time zone)
is 'larger of two';

create function pg_catalog.interval_smaller(interval, interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.interval_smaller
;

comment on function pg_catalog.interval_smaller(interval, interval)
is 'smaller of two';

create function pg_catalog.interval_larger(interval, interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.interval_larger
;

comment on function pg_catalog.interval_larger(interval, interval)
is 'larger of two';

create function pg_catalog.age(timestamp with time zone, timestamp with time zone)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.age
;

comment on function pg_catalog.age(timestamp with time zone, timestamp with time zone)
is 'date difference preserving months and years';

create function pg_catalog.interval(interval, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.interval
;

comment on function pg_catalog.interval(interval, integer)
is 'adjust interval precision';

create function pg_catalog.obj_description(oid, name)
  returns text
stable
strict
parallel safe
language sql
as $$
select description
from pg_catalog.pg_description
where objoid = $1
  and classoid = (select oid
                  from pg_catalog.pg_class
                  where relname = $2
                    and relnamespace = 11)
  and objsubid = 0
$$;

comment on function pg_catalog.obj_description(oid, name)
is 'get description for object id and catalog name';

create function pg_catalog.col_description(oid, integer)
  returns text
stable
strict
parallel safe
language sql
as $$
select description
from pg_catalog.pg_description
where objoid = $1
  and classoid = 'pg_catalog.pg_class' :: pg_catalog.regclass
  and objsubid = $2
$$;

comment on function pg_catalog.col_description(oid, integer)
is 'get description for table column';

create function pg_catalog.date_trunc(text, timestamp with time zone)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_trunc
;

comment on function pg_catalog.date_trunc(text, timestamp with time zone)
is 'truncate timestamp with time zone to specified units';

create function pg_catalog.date_trunc(text, interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_trunc
;

comment on function pg_catalog.date_trunc(text, interval)
is 'truncate interval to specified units';

create function pg_catalog.int8inc(bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8inc
;

comment on function pg_catalog.int8inc(bigint)
is 'increment';

create function pg_catalog.int8abs(bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8abs
;

comment on function pg_catalog.int8abs(bigint)
is 'implementation of @ operator';

create function pg_catalog.int8larger(bigint, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8larger
;

comment on function pg_catalog.int8larger(bigint, bigint)
is 'larger of two';

create function pg_catalog.int8smaller(bigint, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8smaller
;

comment on function pg_catalog.int8smaller(bigint, bigint)
is 'smaller of two';

create function pg_catalog.texticregexeq(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.texticregexeq
;

comment on function pg_catalog.texticregexeq(text, text)
is 'implementation of ~* operator';

create function pg_catalog.texticregexne(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.texticregexne
;

comment on function pg_catalog.texticregexne(text, text)
is 'implementation of !~* operator';

create function pg_catalog.nameicregexeq(name, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.nameicregexeq
;

comment on function pg_catalog.nameicregexeq(name, text)
is 'implementation of ~* operator';

create function pg_catalog.nameicregexne(name, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.nameicregexne
;

comment on function pg_catalog.nameicregexne(name, text)
is 'implementation of !~* operator';

create function pg_catalog.boolin(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.boolin
;

comment on function pg_catalog.boolin(cstring)
is 'I/O';

create function pg_catalog.boolout(boolean)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.boolout
;

comment on function pg_catalog.boolout(boolean)
is 'I/O';

create function pg_catalog.byteain(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.byteain
;

comment on function pg_catalog.byteain(cstring)
is 'I/O';

create function pg_catalog.charin(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.charin
;

comment on function pg_catalog.charin(cstring)
is 'I/O';

create function pg_catalog.charlt("char", "char")
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.charlt
;

comment on function pg_catalog.charlt("char", "char")
is 'implementation of < operator';

create function pg_catalog.unique_key_recheck()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.unique_key_recheck
;

comment on function pg_catalog.unique_key_recheck()
is 'deferred UNIQUE constraint check';

create function pg_catalog.int4abs(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4abs
;

comment on function pg_catalog.int4abs(integer)
is 'implementation of @ operator';

create function pg_catalog.nameregexne(name, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.nameregexne
;

comment on function pg_catalog.nameregexne(name, text)
is 'implementation of !~ operator';

create function pg_catalog.int2abs(smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2abs
;

comment on function pg_catalog.int2abs(smallint)
is 'implementation of @ operator';

create function pg_catalog.textregexeq(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.textregexeq
;

comment on function pg_catalog.textregexeq(text, text)
is 'implementation of ~ operator';

create function pg_catalog.textregexne(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.textregexne
;

comment on function pg_catalog.textregexne(text, text)
is 'implementation of !~ operator';

create function pg_catalog.textlen(text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.textlen
;

comment on function pg_catalog.textlen(text)
is 'length';

create function pg_catalog.textcat(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.textcat
;

comment on function pg_catalog.textcat(text, text)
is 'implementation of || operator';

create function pg_catalog.pg_char_to_encoding(name)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_char_to_encoding
;

comment on function pg_catalog.pg_char_to_encoding(name)
is 'convert encoding name to encoding id';

create function pg_catalog.tidne(tid, tid)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tidne
;

comment on function pg_catalog.tidne(tid, tid)
is 'implementation of <> operator';

create function pg_catalog.cidr_in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cidr_in
;

comment on function pg_catalog.cidr_in(cstring)
is 'I/O';

create function pg_catalog.parse_ident(str text, strict boolean default true)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.parse_ident
;

comment on function pg_catalog.parse_ident(text, boolean)
is 'parse qualified identifier to array of identifiers';

create function pg_catalog.pg_column_size("any")
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_column_size
;

comment on function pg_catalog.pg_column_size("any")
is 'bytes required to store the value, perhaps with compression';

create function pg_catalog."overlaps"(time with time zone, time with time zone, time with time zone,
                                      time with time zone)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog."overlaps"
;

comment on function pg_catalog."overlaps"(time with time zone, time with time zone, time with time zone,
                                          time with time zone)
is 'intervals overlap?';

create function pg_catalog.datetime_pl(date, time)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.datetime_pl
;

comment on function pg_catalog.datetime_pl(date, time)
is 'implementation of + operator';

create function pg_catalog.date_part(text, time with time zone)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_part
;

comment on function pg_catalog.date_part(text, time with time zone)
is 'extract field from time with time zone';

create function pg_catalog.int84pl(bigint, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int84pl
;

comment on function pg_catalog.int84pl(bigint, integer)
is 'implementation of + operator';

create function pg_catalog.int84mi(bigint, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int84mi
;

comment on function pg_catalog.int84mi(bigint, integer)
is 'implementation of - operator';

create function pg_catalog.int84mul(bigint, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int84mul
;

comment on function pg_catalog.int84mul(bigint, integer)
is 'implementation of * operator';

create function pg_catalog.int84div(bigint, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int84div
;

comment on function pg_catalog.int84div(bigint, integer)
is 'implementation of / operator';

create function pg_catalog.int48pl(integer, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int48pl
;

comment on function pg_catalog.int48pl(integer, bigint)
is 'implementation of + operator';

create function pg_catalog.int48mi(integer, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int48mi
;

comment on function pg_catalog.int48mi(integer, bigint)
is 'implementation of - operator';

create function pg_catalog.int48mul(integer, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int48mul
;

comment on function pg_catalog.int48mul(integer, bigint)
is 'implementation of * operator';

create function pg_catalog.int48div(integer, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int48div
;

comment on function pg_catalog.int48div(integer, bigint)
is 'implementation of / operator';

create function pg_catalog.quote_ident(text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.quote_ident
;

comment on function pg_catalog.quote_ident(text)
is 'quote an identifier for usage in a querystring';

create function pg_catalog.quote_literal(text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.quote_literal
;

comment on function pg_catalog.quote_literal(text)
is 'quote a literal for usage in a querystring';

create function pg_catalog.quote_literal(anyelement)
  returns text
stable
strict
parallel safe
cost 1
language sql
as $$
select pg_catalog.quote_literal($1 :: pg_catalog.text)
$$;

comment on function pg_catalog.quote_literal(anyelement)
is 'quote a data value for usage in a querystring';

create function pg_catalog.array_fill(anyelement, integer [], integer [])
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_fill
;

comment on function pg_catalog.array_fill(anyelement, integer [], integer [])
is 'array constructor with value';

create function pg_catalog.oid(bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.oid
;

comment on function pg_catalog.oid(bigint)
is 'convert int8 to oid';

create function pg_catalog.int8(oid)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8
;

comment on function pg_catalog.int8(oid)
is 'convert oid to int8';

create function pg_catalog.quote_nullable(text)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.quote_nullable
;

comment on function pg_catalog.quote_nullable(text)
is 'quote a possibly-null literal for usage in a querystring';

create function pg_catalog.quote_nullable(anyelement)
  returns text
stable
parallel safe
cost 1
language sql
as $$
select pg_catalog.quote_nullable($1 :: pg_catalog.text)
$$;

comment on function pg_catalog.quote_nullable(anyelement)
is 'quote a possibly-null data value for usage in a querystring';

create function pg_catalog.suppress_redundant_updates_trigger()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.suppress_redundant_updates_trigger
;

comment on function pg_catalog.suppress_redundant_updates_trigger()
is 'trigger to suppress updates when new and old records match';

create function pg_catalog.tideq(tid, tid)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tideq
;

comment on function pg_catalog.tideq(tid, tid)
is 'implementation of = operator';

create function pg_catalog.currtid(oid, tid)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.currtid
;

comment on function pg_catalog.currtid(oid, tid)
is 'latest tid of a tuple';

create function pg_catalog.currtid2(text, tid)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.currtid2
;

comment on function pg_catalog.currtid2(text, tid)
is 'latest tid of a tuple';

create function pg_catalog.justify_days(interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.justify_days
;

comment on function pg_catalog.justify_days(interval)
is 'promote groups of 30 days to numbers of months';

create function pg_catalog.timedate_pl(time without time zone, date)
  returns timestamp without time zone
immutable
strict
parallel safe
cost 1
language sql
as $$
select ($2 + $1)
$$;

comment on function pg_catalog.timedate_pl(time, date)
is 'implementation of + operator';

create function pg_catalog.datetimetz_pl(date, time with time zone)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.datetimetz_pl
;

comment on function pg_catalog.datetimetz_pl(date, time with time zone)
is 'implementation of + operator';

create function pg_catalog.timetzdate_pl(time with time zone, date)
  returns timestamp with time zone
immutable
strict
parallel safe
cost 1
language sql
as $$
select ($2 + $1)
$$;

comment on function pg_catalog.timetzdate_pl(time with time zone, date)
is 'implementation of + operator';

create function pg_catalog.now()
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.now
;

comment on function pg_catalog.now()
is 'current transaction time';

create function pg_catalog.positionsel(internal, oid, internal, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.positionsel
;

comment on function pg_catalog.positionsel(internal, oid, internal, integer)
is 'restriction selectivity for position-comparison operators';

create function pg_catalog.positionjoinsel(internal, oid, internal, smallint, internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.positionjoinsel
;

comment on function pg_catalog.positionjoinsel(internal, oid, internal, smallint, internal)
is 'join selectivity for position-comparison operators';

create function pg_catalog.contsel(internal, oid, internal, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.contsel
;

comment on function pg_catalog.contsel(internal, oid, internal, integer)
is 'restriction selectivity for containment comparison operators';

create function pg_catalog.contjoinsel(internal, oid, internal, smallint, internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.contjoinsel
;

comment on function pg_catalog.contjoinsel(internal, oid, internal, smallint, internal)
is 'join selectivity for containment comparison operators';

create function pg_catalog."overlaps"(timestamp with time zone, timestamp with time zone, timestamp with time zone,
                                      timestamp with time zone)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog."overlaps"
;

comment on function pg_catalog."overlaps"(timestamp with time zone, timestamp with time zone, timestamp with time zone,
                                          timestamp with time zone)
is 'intervals overlap?';

create function pg_catalog."overlaps"(timestamp with time zone, interval, timestamp with time zone, interval)
  returns boolean
stable
parallel safe
cost 1
language sql
as $$
select ($1, ($1 + $2)) overlaps ($3, ($3 + $4))
$$;

comment on function pg_catalog."overlaps"(timestamp with time zone, interval, timestamp with time zone, interval)
is 'intervals overlap?';

create function pg_catalog."overlaps"(timestamp with time zone, timestamp with time zone, timestamp with time zone,
                                      interval)
  returns boolean
stable
parallel safe
cost 1
language sql
as $$
select ($1, $2) overlaps ($3, ($3 + $4))
$$;

comment on function pg_catalog."overlaps"(timestamp with time zone, timestamp with time zone, timestamp with time zone,
                                          interval)
is 'intervals overlap?';

create function pg_catalog."overlaps"(timestamp with time zone, interval, timestamp with time zone,
                                      timestamp with time zone)
  returns boolean
stable
parallel safe
cost 1
language sql
as $$
select ($1, ($1 + $2)) overlaps ($3, $4)
$$;

comment on function pg_catalog."overlaps"(timestamp with time zone, interval, timestamp with time zone,
                                          timestamp with time zone)
is 'intervals overlap?';

create function pg_catalog."overlaps"(time, time, time, time)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog."overlaps"
;

comment on function pg_catalog."overlaps"(time, time, time, time)
is 'intervals overlap?';

create function pg_catalog."overlaps"(time without time zone, interval, time without time zone, interval)
  returns boolean
immutable
parallel safe
cost 1
language sql
as $$
select ($1, ($1 + $2)) overlaps ($3, ($3 + $4))
$$;

comment on function pg_catalog."overlaps"(time, interval, time, interval)
is 'intervals overlap?';

create function pg_catalog."overlaps"(time without time zone, time without time zone, time without time zone, interval)
  returns boolean
immutable
parallel safe
cost 1
language sql
as $$
select ($1, $2) overlaps ($3, ($3 + $4))
$$;

comment on function pg_catalog."overlaps"(time, time, time, interval)
is 'intervals overlap?';

create function pg_catalog."overlaps"(time without time zone, interval, time without time zone, time without time zone)
  returns boolean
immutable
parallel safe
cost 1
language sql
as $$
select ($1, ($1 + $2)) overlaps ($3, $4)
$$;

comment on function pg_catalog."overlaps"(time, interval, time, time)
is 'intervals overlap?';

create function pg_catalog.timestamp_in(cstring, oid, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_in
;

comment on function pg_catalog.timestamp_in(cstring, oid, integer)
is 'I/O';

create function pg_catalog.timestamp_out(timestamp)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_out
;

comment on function pg_catalog.timestamp_out(timestamp)
is 'I/O';

create function pg_catalog.timestamptz_cmp(timestamp with time zone, timestamp with time zone)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_cmp
;

comment on function pg_catalog.timestamptz_cmp(timestamp with time zone, timestamp with time zone)
is 'less-equal-greater';

create function pg_catalog.interval_cmp(interval, interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.interval_cmp
;

comment on function pg_catalog.interval_cmp(interval, interval)
is 'less-equal-greater';

create function pg_catalog.time(timestamp)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.time
;

comment on function pg_catalog.time(timestamp)
is 'convert timestamp to time';

create function pg_catalog.length(text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.length
;

comment on function pg_catalog.length(text)
is 'length';

create function pg_catalog.length(char)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.length
;

comment on function pg_catalog.length(char)
is 'character length';

create function pg_catalog.xideqint4(xid, integer)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.xideqint4
;

comment on function pg_catalog.xideqint4(xid, integer)
is 'implementation of = operator';

create function pg_catalog.interval_div(interval, double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.interval_div
;

comment on function pg_catalog.interval_div(interval, double precision)
is 'implementation of / operator';

create function pg_catalog.dlog10(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.dlog10
;

comment on function pg_catalog.dlog10(double precision)
is 'base 10 logarithm';

create function pg_catalog.log(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.log
;

comment on function pg_catalog.log(double precision)
is 'base 10 logarithm';

create function pg_catalog.ln(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ln
;

comment on function pg_catalog.ln(double precision)
is 'natural logarithm';

create function pg_catalog.round(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.round
;

comment on function pg_catalog.round(double precision)
is 'round to nearest integer';

create function pg_catalog.trunc(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.trunc
;

comment on function pg_catalog.trunc(double precision)
is 'truncate to integer';

create function pg_catalog.sqrt(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.sqrt
;

comment on function pg_catalog.sqrt(double precision)
is 'square root';

create function pg_catalog.cbrt(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cbrt
;

comment on function pg_catalog.cbrt(double precision)
is 'cube root';

create function pg_catalog.pow(double precision, double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pow
;

comment on function pg_catalog.pow(double precision, double precision)
is 'exponentiation';

create function pg_catalog.exp(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.exp
;

comment on function pg_catalog.exp(double precision)
is 'natural exponential (e^x)';

create function pg_catalog.obj_description(oid)
  returns text
stable
strict
parallel safe
language sql
as $$
select description
from pg_catalog.pg_description
where objoid = $1
  and objsubid = 0
$$;

comment on function pg_catalog.obj_description(oid)
is 'deprecated, use two-argument form instead';

create function pg_catalog.oidvectortypes(oidvector)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.oidvectortypes
;

comment on function pg_catalog.oidvectortypes(oidvector)
is 'print type names of oidvector field';

create function pg_catalog.timetz_in(cstring, oid, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timetz_in
;

comment on function pg_catalog.timetz_in(cstring, oid, integer)
is 'I/O';

create function pg_catalog.timetz_out(time with time zone)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timetz_out
;

comment on function pg_catalog.timetz_out(time with time zone)
is 'I/O';

create function pg_catalog.timetz_eq(time with time zone, time with time zone)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timetz_eq
;

comment on function pg_catalog.timetz_eq(time with time zone, time with time zone)
is 'implementation of = operator';

create function pg_catalog.timetz_ne(time with time zone, time with time zone)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timetz_ne
;

comment on function pg_catalog.timetz_ne(time with time zone, time with time zone)
is 'implementation of <> operator';

create function pg_catalog.timetz_lt(time with time zone, time with time zone)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timetz_lt
;

comment on function pg_catalog.timetz_lt(time with time zone, time with time zone)
is 'implementation of < operator';

create function pg_catalog.timetz_le(time with time zone, time with time zone)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timetz_le
;

comment on function pg_catalog.timetz_le(time with time zone, time with time zone)
is 'implementation of <= operator';

create function pg_catalog.timetz_ge(time with time zone, time with time zone)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timetz_ge
;

comment on function pg_catalog.timetz_ge(time with time zone, time with time zone)
is 'implementation of >= operator';

create function pg_catalog.timetz_gt(time with time zone, time with time zone)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timetz_gt
;

comment on function pg_catalog.timetz_gt(time with time zone, time with time zone)
is 'implementation of > operator';

create function pg_catalog.timetz_cmp(time with time zone, time with time zone)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timetz_cmp
;

comment on function pg_catalog.timetz_cmp(time with time zone, time with time zone)
is 'less-equal-greater';

create function pg_catalog.timestamptz(date, time with time zone)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz
;

comment on function pg_catalog.timestamptz(date, time with time zone)
is 'convert date and time with time zone to timestamp with time zone';

create function pg_catalog.hostmask(inet)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hostmask
;

comment on function pg_catalog.hostmask(inet)
is 'hostmask of address';

create function pg_catalog.time(abstime)
  returns time without time zone
stable
strict
parallel safe
cost 1
language sql
as $$
select cast(cast($1 as timestamp without time zone) as pg_catalog.time)
$$;

comment on function pg_catalog.time(abstime)
is 'convert abstime to time';

create function pg_catalog.makeaclitem(oid, oid, text, boolean)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.makeaclitem
;

comment on function pg_catalog.makeaclitem(oid, oid, text, boolean)
is 'make ACL item';

create function pg_catalog.character_length(char)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.character_length
;

comment on function pg_catalog.character_length(char)
is 'character length';

create function pg_catalog.power(double precision, double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.power
;

comment on function pg_catalog.power(double precision, double precision)
is 'exponentiation';

create function pg_catalog.character_length(text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.character_length
;

comment on function pg_catalog.character_length(text)
is 'character length';

create function pg_catalog.interval(time)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.interval
;

comment on function pg_catalog.interval(time)
is 'convert time to interval';

create function pg_catalog.pg_lock_status(out locktype           text, out database oid, out relation oid,
                                          out page               integer, out tuple smallint, out virtualxid text,
                                          out transactionid      xid, out classid oid, out objid oid,
                                          out objsubid           smallint, out virtualtransaction text, out pid integer,
                                          out mode               text, out granted boolean, out fastpath boolean)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_lock_status
;

comment on function pg_catalog.pg_lock_status(out text, out oid, out oid, out integer, out smallint, out text, out xid,
                                              out oid, out oid, out smallint, out text, out integer, out text,
                                              out boolean, out boolean)
is 'view system lock information';

create function pg_catalog.char_length(char)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.char_length
;

comment on function pg_catalog.char_length(char)
is 'character length';

create function pg_catalog.isfinite(date)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.isfinite
;

comment on function pg_catalog.isfinite(date)
is 'finite date?';

create function pg_catalog.octet_length(text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.octet_length
;

comment on function pg_catalog.octet_length(text)
is 'octet length';

create function pg_catalog.octet_length(char)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.octet_length
;

comment on function pg_catalog.octet_length(char)
is 'octet length';

create function pg_catalog.factorial(bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.factorial
;

comment on function pg_catalog.factorial(bigint)
is 'factorial';

create function pg_catalog.time_larger(time, time)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.time_larger
;

comment on function pg_catalog.time_larger(time, time)
is 'larger of two';

create function pg_catalog.time_smaller(time, time)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.time_smaller
;

comment on function pg_catalog.time_smaller(time, time)
is 'smaller of two';

create function pg_catalog.timetz_larger(time with time zone, time with time zone)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timetz_larger
;

comment on function pg_catalog.timetz_larger(time with time zone, time with time zone)
is 'larger of two';

create function pg_catalog.timetz_smaller(time with time zone, time with time zone)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timetz_smaller
;

comment on function pg_catalog.timetz_smaller(time with time zone, time with time zone)
is 'smaller of two';

create function pg_catalog.char_length(text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.char_length
;

comment on function pg_catalog.char_length(text)
is 'character length';

create function pg_catalog.date_part(text, abstime)
  returns double precision
stable
strict
parallel safe
cost 1
language sql
as $$
select pg_catalog.date_part($1, cast($2 as timestamp with time zone))
$$;

comment on function pg_catalog.date_part(text, abstime)
is 'extract field from abstime';

create function pg_catalog.date_part(text, reltime)
  returns double precision
stable
strict
parallel safe
cost 1
language sql
as $$
select pg_catalog.date_part($1, cast($2 as pg_catalog.interval))
$$;

comment on function pg_catalog.date_part(text, reltime)
is 'extract field from reltime';

create function pg_catalog.date_part(text, date)
  returns double precision
immutable
strict
parallel safe
cost 1
language sql
as $$
select pg_catalog.date_part($1, cast($2 as timestamp without time zone))
$$;

comment on function pg_catalog.date_part(text, date)
is 'extract field from date';

create function pg_catalog.date_part(text, time)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_part
;

comment on function pg_catalog.date_part(text, time)
is 'extract field from time';

create function pg_catalog.age(timestamp with time zone)
  returns interval
stable
strict
parallel safe
cost 1
language sql
as $$
select pg_catalog.age(cast(current_date as timestamp with time zone), $1)
$$;

comment on function pg_catalog.age(timestamp with time zone)
is 'date difference from today preserving months and years';

create function pg_catalog.pg_get_constraintdef(oid)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_get_constraintdef
;

comment on function pg_catalog.pg_get_constraintdef(oid)
is 'constraint description';

create function pg_catalog.timetz(timestamp with time zone)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timetz
;

comment on function pg_catalog.timetz(timestamp with time zone)
is 'convert timestamp with time zone to time with time zone';

create function pg_catalog.isfinite(timestamp with time zone)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.isfinite
;

comment on function pg_catalog.isfinite(timestamp with time zone)
is 'finite timestamp?';

create function pg_catalog.isfinite(interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.isfinite
;

comment on function pg_catalog.isfinite(interval)
is 'finite interval?';

create function pg_catalog.pg_stat_get_backend_start(integer)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_backend_start
;

comment on function pg_catalog.pg_stat_get_backend_start(integer)
is 'statistics: start time for current backend session';

create function pg_catalog.pg_stat_get_backend_client_addr(integer)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_backend_client_addr
;

comment on function pg_catalog.pg_stat_get_backend_client_addr(integer)
is 'statistics: address of client connected to backend';

create function pg_catalog.pg_stat_get_backend_client_port(integer)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_backend_client_port
;

comment on function pg_catalog.pg_stat_get_backend_client_port(integer)
is 'statistics: port number of client connected to backend';

create function pg_catalog.abs(real)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.abs
;

comment on function pg_catalog.abs(real)
is 'absolute value';

create function pg_catalog.abs(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.abs
;

comment on function pg_catalog.abs(double precision)
is 'absolute value';

create function pg_catalog.abs(bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.abs
;

comment on function pg_catalog.abs(bigint)
is 'absolute value';

create function pg_catalog.abs(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.abs
;

comment on function pg_catalog.abs(integer)
is 'absolute value';

create function pg_catalog.abs(smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.abs
;

comment on function pg_catalog.abs(smallint)
is 'absolute value';

create function pg_catalog.name(varchar)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.name
;

comment on function pg_catalog.name(varchar)
is 'convert varchar to name';

create function pg_catalog.varchar(name)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.varchar
;

comment on function pg_catalog.varchar(name)
is 'convert name to varchar';

create function pg_catalog."current_schema"()
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog."current_schema"
;

comment on function pg_catalog."current_schema"()
is 'current schema name';

create function pg_catalog.current_schemas(boolean)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.current_schemas
;

comment on function pg_catalog.current_schemas(boolean)
is 'current schema search list';

create function pg_catalog.overlay(text, text, integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.overlay
;

comment on function pg_catalog.overlay(text, text, integer, integer)
is 'substitute portion of string';

create function pg_catalog.overlay(text, text, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.overlay
;

comment on function pg_catalog.overlay(text, text, integer)
is 'substitute portion of string';

create function pg_catalog.isvertical(point, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.isvertical
;

comment on function pg_catalog.isvertical(point, point)
is 'vertically aligned';

create function pg_catalog.ishorizontal(point, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ishorizontal
;

comment on function pg_catalog.ishorizontal(point, point)
is 'horizontally aligned';

create function pg_catalog.isparallel(lseg, lseg)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.isparallel
;

comment on function pg_catalog.isparallel(lseg, lseg)
is 'parallel';

create function pg_catalog.isperp(lseg, lseg)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.isperp
;

comment on function pg_catalog.isperp(lseg, lseg)
is 'perpendicular';

create function pg_catalog.isvertical(lseg)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.isvertical
;

comment on function pg_catalog.isvertical(lseg)
is 'vertical';

create function pg_catalog.ishorizontal(lseg)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ishorizontal
;

comment on function pg_catalog.ishorizontal(lseg)
is 'horizontal';

create function pg_catalog.isparallel(line, line)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.isparallel
;

comment on function pg_catalog.isparallel(line, line)
is 'parallel';

create function pg_catalog.isperp(line, line)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.isperp
;

comment on function pg_catalog.isperp(line, line)
is 'perpendicular';

create function pg_catalog.isvertical(line)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.isvertical
;

comment on function pg_catalog.isvertical(line)
is 'vertical';

create function pg_catalog.ishorizontal(line)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ishorizontal
;

comment on function pg_catalog.ishorizontal(line)
is 'horizontal';

create function pg_catalog.point(circle)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.point
;

comment on function pg_catalog.point(circle)
is 'center of';

create function pg_catalog.time(interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.time
;

comment on function pg_catalog.time(interval)
is 'convert interval to time';

create function pg_catalog.box(point, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box
;

comment on function pg_catalog.box(point, point)
is 'convert points to box';

create function pg_catalog.box_add(box, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_add
;

comment on function pg_catalog.box_add(box, point)
is 'implementation of + operator';

create function pg_catalog.box_sub(box, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_sub
;

comment on function pg_catalog.box_sub(box, point)
is 'implementation of - operator';

create function pg_catalog.box_mul(box, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_mul
;

comment on function pg_catalog.box_mul(box, point)
is 'implementation of * operator';

create function pg_catalog.box_div(box, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_div
;

comment on function pg_catalog.box_div(box, point)
is 'implementation of / operator';

create function pg_catalog.path_contain_pt(path, point)
  returns boolean
immutable
strict
parallel safe
cost 1
language sql
as $$
select pg_catalog.on_ppath($2, $1)
$$;

comment on function pg_catalog.path_contain_pt(path, point)
is 'implementation of @> operator';

create function pg_catalog.cidr_out(cidr)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cidr_out
;

comment on function pg_catalog.cidr_out(cidr)
is 'I/O';

create function pg_catalog.poly_contain_pt(polygon, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.poly_contain_pt
;

comment on function pg_catalog.poly_contain_pt(polygon, point)
is 'implementation of @> operator';

create function pg_catalog.pt_contained_poly(point, polygon)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pt_contained_poly
;

comment on function pg_catalog.pt_contained_poly(point, polygon)
is 'implementation of <@ operator';

create function pg_catalog.isclosed(path)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.isclosed
;

comment on function pg_catalog.isclosed(path)
is 'path closed?';

create function pg_catalog.isopen(path)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.isopen
;

comment on function pg_catalog.isopen(path)
is 'path open?';

create function pg_catalog.path_npoints(path)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.path_npoints
;

comment on function pg_catalog.path_npoints(path)
is 'implementation of # operator';

create function pg_catalog.pclose(path)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pclose
;

comment on function pg_catalog.pclose(path)
is 'close path';

create function pg_catalog.popen(path)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.popen
;

comment on function pg_catalog.popen(path)
is 'open path';

create function pg_catalog.path_add(path, path)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.path_add
;

comment on function pg_catalog.path_add(path, path)
is 'implementation of + operator';

create function pg_catalog.path_add_pt(path, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.path_add_pt
;

comment on function pg_catalog.path_add_pt(path, point)
is 'implementation of + operator';

create function pg_catalog.path_sub_pt(path, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.path_sub_pt
;

comment on function pg_catalog.path_sub_pt(path, point)
is 'implementation of - operator';

create function pg_catalog.path_mul_pt(path, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.path_mul_pt
;

comment on function pg_catalog.path_mul_pt(path, point)
is 'implementation of * operator';

create function pg_catalog.path_div_pt(path, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.path_div_pt
;

comment on function pg_catalog.path_div_pt(path, point)
is 'implementation of / operator';

create function pg_catalog.point(double precision, double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.point
;

comment on function pg_catalog.point(double precision, double precision)
is 'convert x, y to point';

create function pg_catalog.point_add(point, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.point_add
;

comment on function pg_catalog.point_add(point, point)
is 'implementation of + operator';

create function pg_catalog.point_sub(point, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.point_sub
;

comment on function pg_catalog.point_sub(point, point)
is 'implementation of - operator';

create function pg_catalog.point_mul(point, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.point_mul
;

comment on function pg_catalog.point_mul(point, point)
is 'implementation of * operator';

create function pg_catalog.point_div(point, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.point_div
;

comment on function pg_catalog.point_div(point, point)
is 'implementation of / operator';

create function pg_catalog.poly_npoints(polygon)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.poly_npoints
;

comment on function pg_catalog.poly_npoints(polygon)
is 'implementation of # operator';

create function pg_catalog.box(polygon)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box
;

comment on function pg_catalog.box(polygon)
is 'convert polygon to bounding box';

create function pg_catalog.path(polygon)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.path
;

comment on function pg_catalog.path(polygon)
is 'convert polygon to path';

create function pg_catalog.polygon(box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.polygon
;

comment on function pg_catalog.polygon(box)
is 'convert box to polygon';

create function pg_catalog.polygon(path)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.polygon
;

comment on function pg_catalog.polygon(path)
is 'convert path to polygon';

create function pg_catalog.circle_in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_in
;

comment on function pg_catalog.circle_in(cstring)
is 'I/O';

create function pg_catalog.circle_out(circle)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_out
;

comment on function pg_catalog.circle_out(circle)
is 'I/O';

create function pg_catalog.circle_same(circle, circle)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_same
;

comment on function pg_catalog.circle_same(circle, circle)
is 'implementation of ~= operator';

create function pg_catalog.circle_contain(circle, circle)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_contain
;

comment on function pg_catalog.circle_contain(circle, circle)
is 'implementation of @> operator';

create function pg_catalog.circle_left(circle, circle)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_left
;

comment on function pg_catalog.circle_left(circle, circle)
is 'implementation of << operator';

create function pg_catalog.circle_overleft(circle, circle)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_overleft
;

comment on function pg_catalog.circle_overleft(circle, circle)
is 'implementation of &< operator';

create function pg_catalog.circle_overright(circle, circle)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_overright
;

comment on function pg_catalog.circle_overright(circle, circle)
is 'implementation of &> operator';

create function pg_catalog.circle_right(circle, circle)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_right
;

comment on function pg_catalog.circle_right(circle, circle)
is 'implementation of >> operator';

create function pg_catalog.circle_contained(circle, circle)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_contained
;

comment on function pg_catalog.circle_contained(circle, circle)
is 'implementation of <@ operator';

create function pg_catalog.circle_overlap(circle, circle)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_overlap
;

comment on function pg_catalog.circle_overlap(circle, circle)
is 'implementation of && operator';

create function pg_catalog.circle_below(circle, circle)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_below
;

comment on function pg_catalog.circle_below(circle, circle)
is 'implementation of <<| operator';

create function pg_catalog.circle_above(circle, circle)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_above
;

comment on function pg_catalog.circle_above(circle, circle)
is 'implementation of |>> operator';

create function pg_catalog.circle_eq(circle, circle)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_eq
;

comment on function pg_catalog.circle_eq(circle, circle)
is 'implementation of = operator';

create function pg_catalog.circle_ne(circle, circle)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_ne
;

comment on function pg_catalog.circle_ne(circle, circle)
is 'implementation of <> operator';

create function pg_catalog.circle_lt(circle, circle)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_lt
;

comment on function pg_catalog.circle_lt(circle, circle)
is 'implementation of < operator';

create function pg_catalog.circle_gt(circle, circle)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_gt
;

comment on function pg_catalog.circle_gt(circle, circle)
is 'implementation of > operator';

create function pg_catalog.circle_le(circle, circle)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_le
;

comment on function pg_catalog.circle_le(circle, circle)
is 'implementation of <= operator';

create function pg_catalog.circle_ge(circle, circle)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_ge
;

comment on function pg_catalog.circle_ge(circle, circle)
is 'implementation of >= operator';

create function pg_catalog.area(circle)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.area
;

comment on function pg_catalog.area(circle)
is 'area of circle';

create function pg_catalog.diameter(circle)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.diameter
;

comment on function pg_catalog.diameter(circle)
is 'diameter of circle';

create function pg_catalog.radius(circle)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.radius
;

comment on function pg_catalog.radius(circle)
is 'radius of circle';

create function pg_catalog.circle_distance(circle, circle)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_distance
;

comment on function pg_catalog.circle_distance(circle, circle)
is 'implementation of <-> operator';

create function pg_catalog.circle_center(circle)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_center
;

comment on function pg_catalog.circle_center(circle)
is 'implementation of @@ operator';

create function pg_catalog.circle(point, double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle
;

comment on function pg_catalog.circle(point, double precision)
is 'convert point and radius to circle';

create function pg_catalog.circle(polygon)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle
;

comment on function pg_catalog.circle(polygon)
is 'convert polygon to circle';

create function pg_catalog.polygon(integer, circle)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.polygon
;

comment on function pg_catalog.polygon(integer, circle)
is 'convert vertex count and circle to polygon';

create function pg_catalog.dist_pc(point, circle)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.dist_pc
;

comment on function pg_catalog.dist_pc(point, circle)
is 'implementation of <-> operator';

create function pg_catalog.circle_contain_pt(circle, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_contain_pt
;

comment on function pg_catalog.circle_contain_pt(circle, point)
is 'implementation of @> operator';

create function pg_catalog.pt_contained_circle(point, circle)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pt_contained_circle
;

comment on function pg_catalog.pt_contained_circle(point, circle)
is 'implementation of <@ operator';

create function pg_catalog.circle(box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle
;

comment on function pg_catalog.circle(box)
is 'convert box to circle';

create function pg_catalog.box(circle)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box
;

comment on function pg_catalog.box(circle)
is 'convert circle to box';

create function pg_catalog.tinterval(abstime, abstime)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tinterval
;

comment on function pg_catalog.tinterval(abstime, abstime)
is 'convert to tinterval';

create function pg_catalog.lseg_ne(lseg, lseg)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lseg_ne
;

comment on function pg_catalog.lseg_ne(lseg, lseg)
is 'implementation of <> operator';

create function pg_catalog.lseg_lt(lseg, lseg)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lseg_lt
;

comment on function pg_catalog.lseg_lt(lseg, lseg)
is 'implementation of < operator';

create function pg_catalog.lseg_le(lseg, lseg)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lseg_le
;

comment on function pg_catalog.lseg_le(lseg, lseg)
is 'implementation of <= operator';

create function pg_catalog.lseg_gt(lseg, lseg)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lseg_gt
;

comment on function pg_catalog.lseg_gt(lseg, lseg)
is 'implementation of > operator';

create function pg_catalog.lseg_ge(lseg, lseg)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lseg_ge
;

comment on function pg_catalog.lseg_ge(lseg, lseg)
is 'implementation of >= operator';

create function pg_catalog.lseg_length(lseg)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lseg_length
;

comment on function pg_catalog.lseg_length(lseg)
is 'implementation of @-@ operator';

create function pg_catalog.close_ls(line, lseg)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.close_ls
;

comment on function pg_catalog.close_ls(line, lseg)
is 'implementation of ## operator';

create function pg_catalog.close_lseg(lseg, lseg)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.close_lseg
;

comment on function pg_catalog.close_lseg(lseg, lseg)
is 'implementation of ## operator';

create function pg_catalog.line_in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.line_in
;

comment on function pg_catalog.line_in(cstring)
is 'I/O';

create function pg_catalog.line_out(line)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.line_out
;

comment on function pg_catalog.line_out(line)
is 'I/O';

create function pg_catalog.line_eq(line, line)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.line_eq
;

comment on function pg_catalog.line_eq(line, line)
is 'implementation of = operator';

create function pg_catalog.line(point, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.line
;

comment on function pg_catalog.line(point, point)
is 'construct line from points';

create function pg_catalog.line_interpt(line, line)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.line_interpt
;

comment on function pg_catalog.line_interpt(line, line)
is 'implementation of # operator';

create function pg_catalog.line_intersect(line, line)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.line_intersect
;

comment on function pg_catalog.line_intersect(line, line)
is 'implementation of ?# operator';

create function pg_catalog.line_parallel(line, line)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.line_parallel
;

comment on function pg_catalog.line_parallel(line, line)
is 'implementation of ?|| operator';

create function pg_catalog.line_perp(line, line)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.line_perp
;

comment on function pg_catalog.line_perp(line, line)
is 'implementation of ?-| operator';

create function pg_catalog.line_vertical(line)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.line_vertical
;

comment on function pg_catalog.line_vertical(line)
is 'implementation of ?| operator';

create function pg_catalog.line_horizontal(line)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.line_horizontal
;

comment on function pg_catalog.line_horizontal(line)
is 'implementation of ?- operator';

create function pg_catalog.length(lseg)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.length
;

comment on function pg_catalog.length(lseg)
is 'distance between endpoints';

create function pg_catalog.length(path)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.length
;

comment on function pg_catalog.length(path)
is 'sum of path segments';

create function pg_catalog.point(lseg)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.point
;

comment on function pg_catalog.point(lseg)
is 'center of';

create function pg_catalog.point(path)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.point
;

comment on function pg_catalog.point(path)
is 'center of';

create function pg_catalog.point(box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.point
;

comment on function pg_catalog.point(box)
is 'center of';

create function pg_catalog.point(polygon)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.point
;

comment on function pg_catalog.point(polygon)
is 'center of';

create function pg_catalog.lseg(box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lseg
;

comment on function pg_catalog.lseg(box)
is 'diagonal of';

create function pg_catalog.center(box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.center
;

comment on function pg_catalog.center(box)
is 'center of';

create function pg_catalog.center(circle)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.center
;

comment on function pg_catalog.center(circle)
is 'center of';

create function pg_catalog.polygon(circle)
  returns polygon
immutable
strict
parallel safe
cost 1
language sql
as $$
select pg_catalog.polygon(12, $1)
$$;

comment on function pg_catalog.polygon(circle)
is 'convert circle to 12-vertex polygon';

create function pg_catalog.npoints(path)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.npoints
;

comment on function pg_catalog.npoints(path)
is 'number of points';

create function pg_catalog.npoints(polygon)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.npoints
;

comment on function pg_catalog.npoints(polygon)
is 'number of points';

create function pg_catalog.bit_in(cstring, oid, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bit_in
;

comment on function pg_catalog.bit_in(cstring, oid, integer)
is 'I/O';

create function pg_catalog.bit_out(bit)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bit_out
;

comment on function pg_catalog.bit_out(bit)
is 'I/O';

create function pg_catalog."like"(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog."like"
;

comment on function pg_catalog."like"(text, text)
is 'matches LIKE expression';

create function pg_catalog.notlike(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.notlike
;

comment on function pg_catalog.notlike(text, text)
is 'does not match LIKE expression';

create function pg_catalog."like"(name, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog."like"
;

comment on function pg_catalog."like"(name, text)
is 'matches LIKE expression';

create function pg_catalog.notlike(name, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.notlike
;

comment on function pg_catalog.notlike(name, text)
is 'does not match LIKE expression';

create function pg_catalog.pg_get_ruledef(oid)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_get_ruledef
;

comment on function pg_catalog.pg_get_ruledef(oid)
is 'source text of a rule';

create function pg_catalog.nextval(regclass)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.nextval
;

comment on function pg_catalog.nextval(regclass)
is 'sequence next value';

create function pg_catalog.currval(regclass)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.currval
;

comment on function pg_catalog.currval(regclass)
is 'sequence current value';

create function pg_catalog.setval(regclass, bigint)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.setval
;

comment on function pg_catalog.setval(regclass, bigint)
is 'set sequence value';

create function pg_catalog.varbit_in(cstring, oid, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.varbit_in
;

comment on function pg_catalog.varbit_in(cstring, oid, integer)
is 'I/O';

create function pg_catalog.varbit_out(bit varying)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.varbit_out
;

comment on function pg_catalog.varbit_out(bit varying)
is 'I/O';

create function pg_catalog.biteq(bit, bit)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.biteq
;

comment on function pg_catalog.biteq(bit, bit)
is 'implementation of = operator';

create function pg_catalog.bitne(bit, bit)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bitne
;

comment on function pg_catalog.bitne(bit, bit)
is 'implementation of <> operator';

create function pg_catalog.bitge(bit, bit)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bitge
;

comment on function pg_catalog.bitge(bit, bit)
is 'implementation of >= operator';

create function pg_catalog.bitgt(bit, bit)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bitgt
;

comment on function pg_catalog.bitgt(bit, bit)
is 'implementation of > operator';

create function pg_catalog.bitle(bit, bit)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bitle
;

comment on function pg_catalog.bitle(bit, bit)
is 'implementation of <= operator';

create function pg_catalog.bitlt(bit, bit)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bitlt
;

comment on function pg_catalog.bitlt(bit, bit)
is 'implementation of < operator';

create function pg_catalog.bitcmp(bit, bit)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bitcmp
;

comment on function pg_catalog.bitcmp(bit, bit)
is 'less-equal-greater';

create function pg_catalog.pg_encoding_to_char(integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_encoding_to_char
;

comment on function pg_catalog.pg_encoding_to_char(integer)
is 'convert encoding id to encoding name';

create function pg_catalog.random()
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.random
;

comment on function pg_catalog.random()
is 'random value';

create function pg_catalog.setseed(double precision)
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.setseed
;

comment on function pg_catalog.setseed(double precision)
is 'set random seed';

create function pg_catalog.asin(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.asin
;

comment on function pg_catalog.asin(double precision)
is 'arcsine';

create function pg_catalog.acos(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.acos
;

comment on function pg_catalog.acos(double precision)
is 'arccosine';

create function pg_catalog.atan(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.atan
;

comment on function pg_catalog.atan(double precision)
is 'arctangent';

create function pg_catalog.atan2(double precision, double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.atan2
;

comment on function pg_catalog.atan2(double precision, double precision)
is 'arctangent, two arguments';

create function pg_catalog.sin(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.sin
;

comment on function pg_catalog.sin(double precision)
is 'sine';

create function pg_catalog.cos(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cos
;

comment on function pg_catalog.cos(double precision)
is 'cosine';

create function pg_catalog.tan(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tan
;

comment on function pg_catalog.tan(double precision)
is 'tangent';

create function pg_catalog.cot(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cot
;

comment on function pg_catalog.cot(double precision)
is 'cotangent';

create function pg_catalog.degrees(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.degrees
;

comment on function pg_catalog.degrees(double precision)
is 'radians to degrees';

create function pg_catalog.radians(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.radians
;

comment on function pg_catalog.radians(double precision)
is 'degrees to radians';

create function pg_catalog.pi()
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pi
;

comment on function pg_catalog.pi()
is 'PI';

create function pg_catalog.interval_mul(interval, double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.interval_mul
;

comment on function pg_catalog.interval_mul(interval, double precision)
is 'implementation of * operator';

create function pg_catalog.pg_typeof("any")
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_typeof
;

comment on function pg_catalog.pg_typeof("any")
is 'type of the argument';

create function pg_catalog.ascii(text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ascii
;

comment on function pg_catalog.ascii(text)
is 'convert first char to int4';

create function pg_catalog.chr(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.chr
;

comment on function pg_catalog.chr(integer)
is 'convert int4 to char';

create function pg_catalog.repeat(text, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.repeat
;

comment on function pg_catalog.repeat(text, integer)
is 'replicate string n times';

create function pg_catalog.similar_escape(text, text)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.similar_escape
;

comment on function pg_catalog.similar_escape(text, text)
is 'convert SQL99 regexp pattern to POSIX style';

create function pg_catalog.mul_d_interval(double precision, interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.mul_d_interval
;

comment on function pg_catalog.mul_d_interval(double precision, interval)
is 'implementation of * operator';

create function pg_catalog.bpcharlike(char, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpcharlike
;

comment on function pg_catalog.bpcharlike(char, text)
is 'implementation of ~~ operator';

create function pg_catalog.bpcharnlike(char, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpcharnlike
;

comment on function pg_catalog.bpcharnlike(char, text)
is 'implementation of !~~ operator';

create function pg_catalog.texticlike(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.texticlike
;

comment on function pg_catalog.texticlike(text, text)
is 'implementation of ~~* operator';

create function pg_catalog.texticnlike(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.texticnlike
;

comment on function pg_catalog.texticnlike(text, text)
is 'implementation of !~~* operator';

create function pg_catalog.nameiclike(name, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.nameiclike
;

comment on function pg_catalog.nameiclike(name, text)
is 'implementation of ~~* operator';

create function pg_catalog.nameicnlike(name, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.nameicnlike
;

comment on function pg_catalog.nameicnlike(name, text)
is 'implementation of !~~* operator';

create function pg_catalog.like_escape(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.like_escape
;

comment on function pg_catalog.like_escape(text, text)
is 'convert LIKE pattern to use backslash escapes';

create function pg_catalog.oidgt(oid, oid)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.oidgt
;

comment on function pg_catalog.oidgt(oid, oid)
is 'implementation of > operator';

create function pg_catalog.oidge(oid, oid)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.oidge
;

comment on function pg_catalog.oidge(oid, oid)
is 'implementation of >= operator';

create function pg_catalog.pg_get_viewdef(text)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_get_viewdef
;

comment on function pg_catalog.pg_get_viewdef(text)
is 'select statement of a view';

create function pg_catalog.pg_get_viewdef(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_get_viewdef
;

comment on function pg_catalog.pg_get_viewdef(oid)
is 'select statement of a view';

create function pg_catalog.pg_get_userbyid(oid)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_get_userbyid
;

comment on function pg_catalog.pg_get_userbyid(oid)
is 'role name by OID (with fallback)';

create function pg_catalog.pg_get_indexdef(oid)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_get_indexdef
;

comment on function pg_catalog.pg_get_indexdef(oid)
is 'index description';

create function pg_catalog."RI_FKey_check_ins"()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog."RI_FKey_check_ins"
;

comment on function pg_catalog."RI_FKey_check_ins"()
is 'referential integrity FOREIGN KEY ... REFERENCES';

create function pg_catalog."RI_FKey_check_upd"()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog."RI_FKey_check_upd"
;

comment on function pg_catalog."RI_FKey_check_upd"()
is 'referential integrity FOREIGN KEY ... REFERENCES';

create function pg_catalog."RI_FKey_cascade_del"()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog."RI_FKey_cascade_del"
;

comment on function pg_catalog."RI_FKey_cascade_del"()
is 'referential integrity ON DELETE CASCADE';

create function pg_catalog."RI_FKey_cascade_upd"()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog."RI_FKey_cascade_upd"
;

comment on function pg_catalog."RI_FKey_cascade_upd"()
is 'referential integrity ON UPDATE CASCADE';

create function pg_catalog."RI_FKey_restrict_del"()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog."RI_FKey_restrict_del"
;

comment on function pg_catalog."RI_FKey_restrict_del"()
is 'referential integrity ON DELETE RESTRICT';

create function pg_catalog."RI_FKey_restrict_upd"()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog."RI_FKey_restrict_upd"
;

comment on function pg_catalog."RI_FKey_restrict_upd"()
is 'referential integrity ON UPDATE RESTRICT';

create function pg_catalog."RI_FKey_setnull_del"()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog."RI_FKey_setnull_del"
;

comment on function pg_catalog."RI_FKey_setnull_del"()
is 'referential integrity ON DELETE SET NULL';

create function pg_catalog."RI_FKey_setnull_upd"()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog."RI_FKey_setnull_upd"
;

comment on function pg_catalog."RI_FKey_setnull_upd"()
is 'referential integrity ON UPDATE SET NULL';

create function pg_catalog."RI_FKey_setdefault_del"()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog."RI_FKey_setdefault_del"
;

comment on function pg_catalog."RI_FKey_setdefault_del"()
is 'referential integrity ON DELETE SET DEFAULT';

create function pg_catalog."RI_FKey_setdefault_upd"()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog."RI_FKey_setdefault_upd"
;

comment on function pg_catalog."RI_FKey_setdefault_upd"()
is 'referential integrity ON UPDATE SET DEFAULT';

create function pg_catalog."RI_FKey_noaction_del"()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog."RI_FKey_noaction_del"
;

comment on function pg_catalog."RI_FKey_noaction_del"()
is 'referential integrity ON DELETE NO ACTION';

create function pg_catalog."RI_FKey_noaction_upd"()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog."RI_FKey_noaction_upd"
;

comment on function pg_catalog."RI_FKey_noaction_upd"()
is 'referential integrity ON UPDATE NO ACTION';

create function pg_catalog.bpcharicregexeq(char, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpcharicregexeq
;

comment on function pg_catalog.bpcharicregexeq(char, text)
is 'implementation of ~* operator';

create function pg_catalog.bpcharicregexne(char, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpcharicregexne
;

comment on function pg_catalog.bpcharicregexne(char, text)
is 'implementation of !~* operator';

create function pg_catalog.bpcharregexeq(char, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpcharregexeq
;

comment on function pg_catalog.bpcharregexeq(char, text)
is 'implementation of ~ operator';

create function pg_catalog.bpcharregexne(char, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpcharregexne
;

comment on function pg_catalog.bpcharregexne(char, text)
is 'implementation of !~ operator';

create function pg_catalog.bpchariclike(char, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpchariclike
;

comment on function pg_catalog.bpchariclike(char, text)
is 'implementation of ~~* operator';

create function pg_catalog.bpcharicnlike(char, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpcharicnlike
;

comment on function pg_catalog.bpcharicnlike(char, text)
is 'implementation of !~~* operator';

create function pg_catalog.pg_get_triggerdef(oid)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_get_triggerdef
;

comment on function pg_catalog.pg_get_triggerdef(oid)
is 'trigger description';

create function pg_catalog.pg_get_serial_sequence(text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_get_serial_sequence
;

comment on function pg_catalog.pg_get_serial_sequence(text, text)
is 'name of sequence for a serial column';

create function pg_catalog.varbiteq(bit varying, bit varying)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.varbiteq
;

comment on function pg_catalog.varbiteq(bit varying, bit varying)
is 'implementation of = operator';

create function pg_catalog.varbitne(bit varying, bit varying)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.varbitne
;

comment on function pg_catalog.varbitne(bit varying, bit varying)
is 'implementation of <> operator';

create function pg_catalog.varbitge(bit varying, bit varying)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.varbitge
;

comment on function pg_catalog.varbitge(bit varying, bit varying)
is 'implementation of >= operator';

create function pg_catalog.varbitgt(bit varying, bit varying)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.varbitgt
;

comment on function pg_catalog.varbitgt(bit varying, bit varying)
is 'implementation of > operator';

create function pg_catalog.varbitle(bit varying, bit varying)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.varbitle
;

comment on function pg_catalog.varbitle(bit varying, bit varying)
is 'implementation of <= operator';

create function pg_catalog.varbitlt(bit varying, bit varying)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.varbitlt
;

comment on function pg_catalog.varbitlt(bit varying, bit varying)
is 'implementation of < operator';

create function pg_catalog.varbitcmp(bit varying, bit varying)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.varbitcmp
;

comment on function pg_catalog.varbitcmp(bit varying, bit varying)
is 'less-equal-greater';

create function pg_catalog.bitand(bit, bit)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bitand
;

comment on function pg_catalog.bitand(bit, bit)
is 'implementation of & operator';

create function pg_catalog.bitor(bit, bit)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bitor
;

comment on function pg_catalog.bitor(bit, bit)
is 'implementation of | operator';

create function pg_catalog.bitxor(bit, bit)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bitxor
;

comment on function pg_catalog.bitxor(bit, bit)
is 'implementation of # operator';

create function pg_catalog.bitnot(bit)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bitnot
;

comment on function pg_catalog.bitnot(bit)
is 'implementation of ~ operator';

create function pg_catalog.bitshiftleft(bit, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bitshiftleft
;

comment on function pg_catalog.bitshiftleft(bit, integer)
is 'implementation of << operator';

create function pg_catalog.bitshiftright(bit, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bitshiftright
;

comment on function pg_catalog.bitshiftright(bit, integer)
is 'implementation of >> operator';

create function pg_catalog.bitcat(bit varying, bit varying)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bitcat
;

comment on function pg_catalog.bitcat(bit varying, bit varying)
is 'implementation of || operator';

create function pg_catalog.substring(bit, integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.substring
;

comment on function pg_catalog.substring(bit, integer, integer)
is 'extract portion of bitstring';

create function pg_catalog.length(bit)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.length
;

comment on function pg_catalog.length(bit)
is 'bitstring length';

create function pg_catalog.octet_length(bit)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.octet_length
;

comment on function pg_catalog.octet_length(bit)
is 'octet length';

create function pg_catalog.bit(integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bit
;

comment on function pg_catalog.bit(integer, integer)
is 'convert int4 to bitstring';

create function pg_catalog.int4(bit)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4
;

comment on function pg_catalog.int4(bit)
is 'convert bitstring to int4';

create function pg_catalog.bit(bit, integer, boolean)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bit
;

comment on function pg_catalog.bit(bit, integer, boolean)
is 'adjust bit() to typmod length';

create function pg_catalog.pg_get_keywords(out word text, out catcode "char", out catdesc text)
stable
strict
parallel safe
cost 10
rows 400
language internal
as
-- missing source code for pg_catalog.pg_get_keywords
;

comment on function pg_catalog.pg_get_keywords(out text, out "char", out text)
is 'list of SQL keywords';

create function pg_catalog.varbit(bit varying, integer, boolean)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.varbit
;

comment on function pg_catalog.varbit(bit varying, integer, boolean)
is 'adjust varbit() to typmod length';

create function pg_catalog.time_hash(time)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.time_hash
;

comment on function pg_catalog.time_hash(time)
is 'hash';

create function pg_catalog.aclexplode(acl aclitem [], out grantor oid, out grantee oid, out privilege_type text,
                                                      out is_grantable boolean)
stable
strict
parallel safe
cost 1
rows 10
language internal
as
-- missing source code for pg_catalog.aclexplode
;

comment on function pg_catalog.aclexplode(aclitem [], out oid, out oid, out text, out boolean)
is 'convert ACL item array to table, for use by information schema';

create function pg_catalog.time_mi_time(time, time)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.time_mi_time
;

comment on function pg_catalog.time_mi_time(time, time)
is 'implementation of - operator';

create function pg_catalog.boolle(boolean, boolean)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.boolle
;

comment on function pg_catalog.boolle(boolean, boolean)
is 'implementation of <= operator';

create function pg_catalog.boolge(boolean, boolean)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.boolge
;

comment on function pg_catalog.boolge(boolean, boolean)
is 'implementation of >= operator';

create function pg_catalog.btboolcmp(boolean, boolean)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btboolcmp
;

comment on function pg_catalog.btboolcmp(boolean, boolean)
is 'less-equal-greater';

create function pg_catalog.timetz_hash(time with time zone)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timetz_hash
;

comment on function pg_catalog.timetz_hash(time with time zone)
is 'hash';

create function pg_catalog.interval_hash(interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.interval_hash
;

comment on function pg_catalog.interval_hash(interval)
is 'hash';

create function pg_catalog.position(bit, bit)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.position
;

comment on function pg_catalog.position(bit, bit)
is 'position of sub-bitstring';

create function pg_catalog.substring(bit, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.substring
;

comment on function pg_catalog.substring(bit, integer)
is 'extract portion of bitstring';

create function pg_catalog.numeric_in(cstring, oid, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_in
;

comment on function pg_catalog.numeric_in(cstring, oid, integer)
is 'I/O';

create function pg_catalog.numeric_out(numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_out
;

comment on function pg_catalog.numeric_out(numeric)
is 'I/O';

create function pg_catalog.numeric(numeric, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric
;

comment on function pg_catalog.numeric(numeric, integer)
is 'adjust numeric to typmod precision/scale';

create function pg_catalog.numeric_abs(numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_abs
;

comment on function pg_catalog.numeric_abs(numeric)
is 'implementation of @ operator';

create function pg_catalog.abs(numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.abs
;

comment on function pg_catalog.abs(numeric)
is 'absolute value';

create function pg_catalog.sign(numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.sign
;

comment on function pg_catalog.sign(numeric)
is 'sign of value';

create function pg_catalog.round(numeric, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.round
;

comment on function pg_catalog.round(numeric, integer)
is 'value rounded to ''scale''';

create function pg_catalog.round(numeric)
  returns numeric
immutable
strict
parallel safe
cost 1
language sql
as $$
select pg_catalog.round($1, 0)
$$;

comment on function pg_catalog.round(numeric)
is 'value rounded to ''scale'' of zero';

create function pg_catalog.trunc(numeric, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.trunc
;

comment on function pg_catalog.trunc(numeric, integer)
is 'value truncated to ''scale''';

create function pg_catalog.trunc(numeric)
  returns numeric
immutable
strict
parallel safe
cost 1
language sql
as $$
select pg_catalog.trunc($1, 0)
$$;

comment on function pg_catalog.trunc(numeric)
is 'value truncated to ''scale'' of zero';

create function pg_catalog.ceil(numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ceil
;

comment on function pg_catalog.ceil(numeric)
is 'nearest integer >= value';

create function pg_catalog.floor(numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.floor
;

comment on function pg_catalog.floor(numeric)
is 'nearest integer <= value';

create function pg_catalog.length(bytea, name)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.length
;

comment on function pg_catalog.length(bytea, name)
is 'length of string in specified encoding';

create function pg_catalog.convert_from(bytea, name)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.convert_from
;

comment on function pg_catalog.convert_from(bytea, name)
is 'convert string with specified source encoding name';

create function pg_catalog.cidr(inet)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cidr
;

comment on function pg_catalog.cidr(inet)
is 'convert inet to cidr';

create function pg_catalog.pg_get_expr(pg_node_tree, oid)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_get_expr
;

comment on function pg_catalog.pg_get_expr(pg_node_tree, oid)
is 'deparse an encoded expression';

create function pg_catalog.convert_to(text, name)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.convert_to
;

comment on function pg_catalog.convert_to(text, name)
is 'convert string with specified destination encoding name';

create function pg_catalog.numeric_eq(numeric, numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_eq
;

comment on function pg_catalog.numeric_eq(numeric, numeric)
is 'implementation of = operator';

create function pg_catalog.numeric_ne(numeric, numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_ne
;

comment on function pg_catalog.numeric_ne(numeric, numeric)
is 'implementation of <> operator';

create function pg_catalog.numeric_gt(numeric, numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_gt
;

comment on function pg_catalog.numeric_gt(numeric, numeric)
is 'implementation of > operator';

create function pg_catalog.numeric_ge(numeric, numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_ge
;

comment on function pg_catalog.numeric_ge(numeric, numeric)
is 'implementation of >= operator';

create function pg_catalog.numeric_lt(numeric, numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_lt
;

comment on function pg_catalog.numeric_lt(numeric, numeric)
is 'implementation of < operator';

create function pg_catalog.numeric_le(numeric, numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_le
;

comment on function pg_catalog.numeric_le(numeric, numeric)
is 'implementation of <= operator';

create function pg_catalog.numeric_add(numeric, numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_add
;

comment on function pg_catalog.numeric_add(numeric, numeric)
is 'implementation of + operator';

create function pg_catalog.numeric_sub(numeric, numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_sub
;

comment on function pg_catalog.numeric_sub(numeric, numeric)
is 'implementation of - operator';

create function pg_catalog.numeric_mul(numeric, numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_mul
;

comment on function pg_catalog.numeric_mul(numeric, numeric)
is 'implementation of * operator';

create function pg_catalog.numeric_div(numeric, numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_div
;

comment on function pg_catalog.numeric_div(numeric, numeric)
is 'implementation of / operator';

create function pg_catalog.mod(numeric, numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.mod
;

comment on function pg_catalog.mod(numeric, numeric)
is 'modulus';

create function pg_catalog.numeric_mod(numeric, numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_mod
;

comment on function pg_catalog.numeric_mod(numeric, numeric)
is 'implementation of % operator';

create function pg_catalog.sqrt(numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.sqrt
;

comment on function pg_catalog.sqrt(numeric)
is 'square root';

create function pg_catalog.numeric_sqrt(numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_sqrt
;

comment on function pg_catalog.numeric_sqrt(numeric)
is 'square root';

create function pg_catalog.exp(numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.exp
;

comment on function pg_catalog.exp(numeric)
is 'natural exponential (e^x)';

create function pg_catalog.numeric_exp(numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_exp
;

comment on function pg_catalog.numeric_exp(numeric)
is 'natural exponential (e^x)';

create function pg_catalog.ln(numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ln
;

comment on function pg_catalog.ln(numeric)
is 'natural logarithm';

create function pg_catalog.numeric_ln(numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_ln
;

comment on function pg_catalog.numeric_ln(numeric)
is 'natural logarithm';

create function pg_catalog.log(numeric, numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.log
;

comment on function pg_catalog.log(numeric, numeric)
is 'logarithm base m of n';

create function pg_catalog.numeric_log(numeric, numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_log
;

comment on function pg_catalog.numeric_log(numeric, numeric)
is 'logarithm base m of n';

create function pg_catalog.pow(numeric, numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pow
;

comment on function pg_catalog.pow(numeric, numeric)
is 'exponentiation';

create function pg_catalog.numeric_power(numeric, numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_power
;

comment on function pg_catalog.numeric_power(numeric, numeric)
is 'implementation of ^ operator';

create function pg_catalog.numeric(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric
;

comment on function pg_catalog.numeric(integer)
is 'convert int4 to numeric';

create function pg_catalog.log(numeric)
  returns numeric
immutable
strict
parallel safe
cost 1
language sql
as $$
select pg_catalog.log(10, $1)
$$;

comment on function pg_catalog.log(numeric)
is 'base 10 logarithm';

create function pg_catalog.numeric(real)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric
;

comment on function pg_catalog.numeric(real)
is 'convert float4 to numeric';

create function pg_catalog.numeric(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric
;

comment on function pg_catalog.numeric(double precision)
is 'convert float8 to numeric';

create function pg_catalog.int4(numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4
;

comment on function pg_catalog.int4(numeric)
is 'convert numeric to int4';

create function pg_catalog.float4(numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float4
;

comment on function pg_catalog.float4(numeric)
is 'convert numeric to float4';

create function pg_catalog.float8(numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8
;

comment on function pg_catalog.float8(numeric)
is 'convert numeric to float8';

create function pg_catalog.time_pl_interval(time, interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.time_pl_interval
;

comment on function pg_catalog.time_pl_interval(time, interval)
is 'implementation of + operator';

create function pg_catalog.time_mi_interval(time, interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.time_mi_interval
;

comment on function pg_catalog.time_mi_interval(time, interval)
is 'implementation of - operator';

create function pg_catalog.timetz_pl_interval(time with time zone, interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timetz_pl_interval
;

comment on function pg_catalog.timetz_pl_interval(time with time zone, interval)
is 'implementation of + operator';

create function pg_catalog.timetz_mi_interval(time with time zone, interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timetz_mi_interval
;

comment on function pg_catalog.timetz_mi_interval(time with time zone, interval)
is 'implementation of - operator';

create function pg_catalog.numeric_inc(numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_inc
;

comment on function pg_catalog.numeric_inc(numeric)
is 'increment by one';

create function pg_catalog.setval(regclass, bigint, boolean)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.setval
;

comment on function pg_catalog.setval(regclass, bigint, boolean)
is 'set sequence value and is_called status';

create function pg_catalog.numeric_smaller(numeric, numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_smaller
;

comment on function pg_catalog.numeric_smaller(numeric, numeric)
is 'smaller of two';

create function pg_catalog.numeric_larger(numeric, numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_larger
;

comment on function pg_catalog.numeric_larger(numeric, numeric)
is 'larger of two';

create function pg_catalog.to_char(interval, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.to_char
;

comment on function pg_catalog.to_char(interval, text)
is 'format interval to text';

create function pg_catalog.numeric_cmp(numeric, numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_cmp
;

comment on function pg_catalog.numeric_cmp(numeric, numeric)
is 'less-equal-greater';

create function pg_catalog.to_char(timestamp with time zone, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.to_char
;

comment on function pg_catalog.to_char(timestamp with time zone, text)
is 'format timestamp with time zone to text';

create function pg_catalog.numeric_uminus(numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_uminus
;

comment on function pg_catalog.numeric_uminus(numeric)
is 'implementation of - operator';

create function pg_catalog.to_char(numeric, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.to_char
;

comment on function pg_catalog.to_char(numeric, text)
is 'format numeric to text';

create function pg_catalog.to_char(integer, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.to_char
;

comment on function pg_catalog.to_char(integer, text)
is 'format int4 to text';

create function pg_catalog.to_char(bigint, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.to_char
;

comment on function pg_catalog.to_char(bigint, text)
is 'format int8 to text';

create function pg_catalog.to_char(real, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.to_char
;

comment on function pg_catalog.to_char(real, text)
is 'format float4 to text';

create function pg_catalog.to_char(double precision, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.to_char
;

comment on function pg_catalog.to_char(double precision, text)
is 'format float8 to text';

create function pg_catalog.to_number(text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.to_number
;

comment on function pg_catalog.to_number(text, text)
is 'convert text to numeric';

create function pg_catalog.to_timestamp(text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.to_timestamp
;

comment on function pg_catalog.to_timestamp(text, text)
is 'convert text to timestamp with time zone';

create function pg_catalog.int8(numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8
;

comment on function pg_catalog.int8(numeric)
is 'convert numeric to int8';

create function pg_catalog.to_date(text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.to_date
;

comment on function pg_catalog.to_date(text, text)
is 'convert text to date';

create function pg_catalog.numeric(bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric
;

comment on function pg_catalog.numeric(bigint)
is 'convert int8 to numeric';

create function pg_catalog.numeric(smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric
;

comment on function pg_catalog.numeric(smallint)
is 'convert int2 to numeric';

create function pg_catalog.int2(numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2
;

comment on function pg_catalog.int2(numeric)
is 'convert numeric to int2';

create function pg_catalog.oidin(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.oidin
;

comment on function pg_catalog.oidin(cstring)
is 'I/O';

create function pg_catalog.oidout(oid)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.oidout
;

comment on function pg_catalog.oidout(oid)
is 'I/O';

create function pg_catalog.bit_length(bytea)
  returns integer
immutable
strict
parallel safe
cost 1
language sql
as $$
select pg_catalog.octet_length($1) * 8
$$;

comment on function pg_catalog.bit_length(bytea)
is 'length in bits';

create function pg_catalog.bit_length(text)
  returns integer
immutable
strict
parallel safe
cost 1
language sql
as $$
select pg_catalog.octet_length($1) * 8
$$;

comment on function pg_catalog.bit_length(text)
is 'length in bits';

create function pg_catalog.bit_length(bit)
  returns integer
immutable
strict
parallel safe
cost 1
language sql
as $$
select pg_catalog.length($1)
$$;

comment on function pg_catalog.bit_length(bit)
is 'length in bits';

create function pg_catalog.convert(bytea, name, name)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.convert
;

comment on function pg_catalog.convert(bytea, name, name)
is 'convert string with specified encoding names';

create function pg_catalog.iclikesel(internal, oid, internal, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.iclikesel
;

comment on function pg_catalog.iclikesel(internal, oid, internal, integer)
is 'restriction selectivity of ILIKE';

create function pg_catalog.icnlikesel(internal, oid, internal, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.icnlikesel
;

comment on function pg_catalog.icnlikesel(internal, oid, internal, integer)
is 'restriction selectivity of NOT ILIKE';

create function pg_catalog.iclikejoinsel(internal, oid, internal, smallint, internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.iclikejoinsel
;

comment on function pg_catalog.iclikejoinsel(internal, oid, internal, smallint, internal)
is 'join selectivity of ILIKE';

create function pg_catalog.icnlikejoinsel(internal, oid, internal, smallint, internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.icnlikejoinsel
;

comment on function pg_catalog.icnlikejoinsel(internal, oid, internal, smallint, internal)
is 'join selectivity of NOT ILIKE';

create function pg_catalog.regexeqsel(internal, oid, internal, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regexeqsel
;

comment on function pg_catalog.regexeqsel(internal, oid, internal, integer)
is 'restriction selectivity of regex match';

create function pg_catalog.likesel(internal, oid, internal, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.likesel
;

comment on function pg_catalog.likesel(internal, oid, internal, integer)
is 'restriction selectivity of LIKE';

create function pg_catalog.icregexeqsel(internal, oid, internal, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.icregexeqsel
;

comment on function pg_catalog.icregexeqsel(internal, oid, internal, integer)
is 'restriction selectivity of case-insensitive regex match';

create function pg_catalog.regexnesel(internal, oid, internal, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regexnesel
;

comment on function pg_catalog.regexnesel(internal, oid, internal, integer)
is 'restriction selectivity of regex non-match';

create function pg_catalog.nlikesel(internal, oid, internal, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.nlikesel
;

comment on function pg_catalog.nlikesel(internal, oid, internal, integer)
is 'restriction selectivity of NOT LIKE';

create function pg_catalog.icregexnesel(internal, oid, internal, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.icregexnesel
;

comment on function pg_catalog.icregexnesel(internal, oid, internal, integer)
is 'restriction selectivity of case-insensitive regex non-match';

create function pg_catalog.regexeqjoinsel(internal, oid, internal, smallint, internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regexeqjoinsel
;

comment on function pg_catalog.regexeqjoinsel(internal, oid, internal, smallint, internal)
is 'join selectivity of regex match';

create function pg_catalog.likejoinsel(internal, oid, internal, smallint, internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.likejoinsel
;

comment on function pg_catalog.likejoinsel(internal, oid, internal, smallint, internal)
is 'join selectivity of LIKE';

create function pg_catalog.icregexeqjoinsel(internal, oid, internal, smallint, internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.icregexeqjoinsel
;

comment on function pg_catalog.icregexeqjoinsel(internal, oid, internal, smallint, internal)
is 'join selectivity of case-insensitive regex match';

create function pg_catalog.regexnejoinsel(internal, oid, internal, smallint, internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regexnejoinsel
;

comment on function pg_catalog.regexnejoinsel(internal, oid, internal, smallint, internal)
is 'join selectivity of regex non-match';

create function pg_catalog.nlikejoinsel(internal, oid, internal, smallint, internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.nlikejoinsel
;

comment on function pg_catalog.nlikejoinsel(internal, oid, internal, smallint, internal)
is 'join selectivity of NOT LIKE';

create function pg_catalog.icregexnejoinsel(internal, oid, internal, smallint, internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.icregexnejoinsel
;

comment on function pg_catalog.icregexnejoinsel(internal, oid, internal, smallint, internal)
is 'join selectivity of case-insensitive regex non-match';

create function pg_catalog.float8_avg(double precision [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8_avg
;

comment on function pg_catalog.float8_avg(double precision [])
is 'aggregate final function';

create function pg_catalog.float8_var_samp(double precision [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8_var_samp
;

comment on function pg_catalog.float8_var_samp(double precision [])
is 'aggregate final function';

create function pg_catalog.float8_stddev_samp(double precision [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8_stddev_samp
;

comment on function pg_catalog.float8_stddev_samp(double precision [])
is 'aggregate final function';

create function pg_catalog.numeric_accum(internal, numeric)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_accum
;

comment on function pg_catalog.numeric_accum(internal, numeric)
is 'aggregate transition function';

create function pg_catalog.int2_accum(internal, smallint)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2_accum
;

comment on function pg_catalog.int2_accum(internal, smallint)
is 'aggregate transition function';

create function pg_catalog.int4_accum(internal, integer)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4_accum
;

comment on function pg_catalog.int4_accum(internal, integer)
is 'aggregate transition function';

create function pg_catalog.int8_accum(internal, bigint)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8_accum
;

comment on function pg_catalog.int8_accum(internal, bigint)
is 'aggregate transition function';

create function pg_catalog.numeric_avg(internal)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_avg
;

comment on function pg_catalog.numeric_avg(internal)
is 'aggregate final function';

create function pg_catalog.numeric_var_samp(internal)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_var_samp
;

comment on function pg_catalog.numeric_var_samp(internal)
is 'aggregate final function';

create function pg_catalog.numeric_stddev_samp(internal)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_stddev_samp
;

comment on function pg_catalog.numeric_stddev_samp(internal)
is 'aggregate final function';

create function pg_catalog.int2_sum(bigint, smallint)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2_sum
;

comment on function pg_catalog.int2_sum(bigint, smallint)
is 'aggregate transition function';

create function pg_catalog.int4_sum(bigint, integer)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4_sum
;

comment on function pg_catalog.int4_sum(bigint, integer)
is 'aggregate transition function';

create function pg_catalog.int8_sum(numeric, bigint)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8_sum
;

comment on function pg_catalog.int8_sum(numeric, bigint)
is 'aggregate transition function';

create function pg_catalog.interval_accum(interval [], interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.interval_accum
;

comment on function pg_catalog.interval_accum(interval [], interval)
is 'aggregate transition function';

create function pg_catalog.interval_avg(interval [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.interval_avg
;

comment on function pg_catalog.interval_avg(interval [])
is 'aggregate final function';

create function pg_catalog.to_ascii(text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.to_ascii
;

comment on function pg_catalog.to_ascii(text)
is 'encode text from DB encoding to ASCII text';

create function pg_catalog.to_ascii(text, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.to_ascii
;

comment on function pg_catalog.to_ascii(text, integer)
is 'encode text from encoding to ASCII text';

create function pg_catalog.to_ascii(text, name)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.to_ascii
;

comment on function pg_catalog.to_ascii(text, name)
is 'encode text from encoding to ASCII text';

create function pg_catalog.interval_pl_time(interval, time without time zone)
  returns time without time zone
immutable
strict
parallel safe
cost 1
language sql
as $$
select $2 + $1
$$;

comment on function pg_catalog.interval_pl_time(interval, time)
is 'implementation of + operator';

create function pg_catalog.int28eq(smallint, bigint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int28eq
;

comment on function pg_catalog.int28eq(smallint, bigint)
is 'implementation of = operator';

create function pg_catalog.int28ne(smallint, bigint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int28ne
;

comment on function pg_catalog.int28ne(smallint, bigint)
is 'implementation of <> operator';

create function pg_catalog.int28lt(smallint, bigint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int28lt
;

comment on function pg_catalog.int28lt(smallint, bigint)
is 'implementation of < operator';

create function pg_catalog.int28gt(smallint, bigint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int28gt
;

comment on function pg_catalog.int28gt(smallint, bigint)
is 'implementation of > operator';

create function pg_catalog.int28le(smallint, bigint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int28le
;

comment on function pg_catalog.int28le(smallint, bigint)
is 'implementation of <= operator';

create function pg_catalog.int28ge(smallint, bigint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int28ge
;

comment on function pg_catalog.int28ge(smallint, bigint)
is 'implementation of >= operator';

create function pg_catalog.int82eq(bigint, smallint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int82eq
;

comment on function pg_catalog.int82eq(bigint, smallint)
is 'implementation of = operator';

create function pg_catalog.int82ne(bigint, smallint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int82ne
;

comment on function pg_catalog.int82ne(bigint, smallint)
is 'implementation of <> operator';

create function pg_catalog.int82lt(bigint, smallint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int82lt
;

comment on function pg_catalog.int82lt(bigint, smallint)
is 'implementation of < operator';

create function pg_catalog.int82gt(bigint, smallint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int82gt
;

comment on function pg_catalog.int82gt(bigint, smallint)
is 'implementation of > operator';

create function pg_catalog.int82le(bigint, smallint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int82le
;

comment on function pg_catalog.int82le(bigint, smallint)
is 'implementation of <= operator';

create function pg_catalog.int82ge(bigint, smallint)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int82ge
;

comment on function pg_catalog.int82ge(bigint, smallint)
is 'implementation of >= operator';

create function pg_catalog.int2and(smallint, smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2and
;

comment on function pg_catalog.int2and(smallint, smallint)
is 'implementation of & operator';

create function pg_catalog.int2or(smallint, smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2or
;

comment on function pg_catalog.int2or(smallint, smallint)
is 'implementation of | operator';

create function pg_catalog.int2xor(smallint, smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2xor
;

comment on function pg_catalog.int2xor(smallint, smallint)
is 'implementation of # operator';

create function pg_catalog.int2not(smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2not
;

comment on function pg_catalog.int2not(smallint)
is 'implementation of ~ operator';

create function pg_catalog.int2shl(smallint, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2shl
;

comment on function pg_catalog.int2shl(smallint, integer)
is 'implementation of << operator';

create function pg_catalog.int2shr(smallint, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2shr
;

comment on function pg_catalog.int2shr(smallint, integer)
is 'implementation of >> operator';

create function pg_catalog.int4and(integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4and
;

comment on function pg_catalog.int4and(integer, integer)
is 'implementation of & operator';

create function pg_catalog.int4or(integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4or
;

comment on function pg_catalog.int4or(integer, integer)
is 'implementation of | operator';

create function pg_catalog.int4xor(integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4xor
;

comment on function pg_catalog.int4xor(integer, integer)
is 'implementation of # operator';

create function pg_catalog.int4not(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4not
;

comment on function pg_catalog.int4not(integer)
is 'implementation of ~ operator';

create function pg_catalog.int4shl(integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4shl
;

comment on function pg_catalog.int4shl(integer, integer)
is 'implementation of << operator';

create function pg_catalog.int4shr(integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4shr
;

comment on function pg_catalog.int4shr(integer, integer)
is 'implementation of >> operator';

create function pg_catalog.int8and(bigint, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8and
;

comment on function pg_catalog.int8and(bigint, bigint)
is 'implementation of & operator';

create function pg_catalog.int8or(bigint, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8or
;

comment on function pg_catalog.int8or(bigint, bigint)
is 'implementation of | operator';

create function pg_catalog.int8xor(bigint, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8xor
;

comment on function pg_catalog.int8xor(bigint, bigint)
is 'implementation of # operator';

create function pg_catalog.int8not(bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8not
;

comment on function pg_catalog.int8not(bigint)
is 'implementation of ~ operator';

create function pg_catalog.int8shl(bigint, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8shl
;

comment on function pg_catalog.int8shl(bigint, integer)
is 'implementation of << operator';

create function pg_catalog.int8shr(bigint, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8shr
;

comment on function pg_catalog.int8shr(bigint, integer)
is 'implementation of >> operator';

create function pg_catalog.int8up(bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8up
;

comment on function pg_catalog.int8up(bigint)
is 'implementation of + operator';

create function pg_catalog.int2up(smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2up
;

comment on function pg_catalog.int2up(smallint)
is 'implementation of + operator';

create function pg_catalog.int4up(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4up
;

comment on function pg_catalog.int4up(integer)
is 'implementation of + operator';

create function pg_catalog.float4up(real)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float4up
;

comment on function pg_catalog.float4up(real)
is 'implementation of + operator';

create function pg_catalog.float8up(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8up
;

comment on function pg_catalog.float8up(double precision)
is 'implementation of + operator';

create function pg_catalog.numeric_uplus(numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_uplus
;

comment on function pg_catalog.numeric_uplus(numeric)
is 'implementation of + operator';

create function pg_catalog.has_table_privilege(name, text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_table_privilege
;

comment on function pg_catalog.has_table_privilege(name, text, text)
is 'user privilege on relation by username, rel name';

create function pg_catalog.has_table_privilege(name, oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_table_privilege
;

comment on function pg_catalog.has_table_privilege(name, oid, text)
is 'user privilege on relation by username, rel oid';

create function pg_catalog.has_table_privilege(oid, text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_table_privilege
;

comment on function pg_catalog.has_table_privilege(oid, text, text)
is 'user privilege on relation by user oid, rel name';

create function pg_catalog.has_table_privilege(oid, oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_table_privilege
;

comment on function pg_catalog.has_table_privilege(oid, oid, text)
is 'user privilege on relation by user oid, rel oid';

create function pg_catalog.has_table_privilege(text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_table_privilege
;

comment on function pg_catalog.has_table_privilege(text, text)
is 'current user privilege on relation by rel name';

create function pg_catalog.has_table_privilege(oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_table_privilege
;

comment on function pg_catalog.has_table_privilege(oid, text)
is 'current user privilege on relation by rel oid';

create function pg_catalog.pg_stat_get_numscans(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_numscans
;

comment on function pg_catalog.pg_stat_get_numscans(oid)
is 'statistics: number of scans done for table/index';

create function pg_catalog.pg_stat_get_tuples_returned(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_tuples_returned
;

comment on function pg_catalog.pg_stat_get_tuples_returned(oid)
is 'statistics: number of tuples read by seqscan';

create function pg_catalog.pg_stat_get_tuples_fetched(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_tuples_fetched
;

comment on function pg_catalog.pg_stat_get_tuples_fetched(oid)
is 'statistics: number of tuples fetched by idxscan';

create function pg_catalog.pg_stat_get_tuples_inserted(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_tuples_inserted
;

comment on function pg_catalog.pg_stat_get_tuples_inserted(oid)
is 'statistics: number of tuples inserted';

create function pg_catalog.pg_stat_get_tuples_updated(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_tuples_updated
;

comment on function pg_catalog.pg_stat_get_tuples_updated(oid)
is 'statistics: number of tuples updated';

create function pg_catalog.pg_stat_get_tuples_deleted(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_tuples_deleted
;

comment on function pg_catalog.pg_stat_get_tuples_deleted(oid)
is 'statistics: number of tuples deleted';

create function pg_catalog.pg_stat_get_blocks_fetched(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_blocks_fetched
;

comment on function pg_catalog.pg_stat_get_blocks_fetched(oid)
is 'statistics: number of blocks fetched';

create function pg_catalog.pg_stat_get_blocks_hit(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_blocks_hit
;

comment on function pg_catalog.pg_stat_get_blocks_hit(oid)
is 'statistics: number of blocks found in cache';

create function pg_catalog.pg_stat_get_backend_idset()
stable
strict
parallel restricted
cost 1
rows 100
language internal
as
-- missing source code for pg_catalog.pg_stat_get_backend_idset
;

comment on function pg_catalog.pg_stat_get_backend_idset()
is 'statistics: currently active backend IDs';

create function pg_catalog.pg_stat_get_backend_pid(integer)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_backend_pid
;

comment on function pg_catalog.pg_stat_get_backend_pid(integer)
is 'statistics: PID of backend';

create function pg_catalog.pg_stat_get_backend_dbid(integer)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_backend_dbid
;

comment on function pg_catalog.pg_stat_get_backend_dbid(integer)
is 'statistics: database ID of backend';

create function pg_catalog.pg_stat_get_backend_userid(integer)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_backend_userid
;

comment on function pg_catalog.pg_stat_get_backend_userid(integer)
is 'statistics: user ID of backend';

create function pg_catalog.pg_stat_get_backend_activity(integer)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_backend_activity
;

comment on function pg_catalog.pg_stat_get_backend_activity(integer)
is 'statistics: current query of backend';

create function pg_catalog.pg_stat_get_db_numbackends(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_db_numbackends
;

comment on function pg_catalog.pg_stat_get_db_numbackends(oid)
is 'statistics: number of backends in database';

create function pg_catalog.pg_stat_get_db_xact_commit(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_db_xact_commit
;

comment on function pg_catalog.pg_stat_get_db_xact_commit(oid)
is 'statistics: transactions committed';

create function pg_catalog.pg_stat_get_db_xact_rollback(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_db_xact_rollback
;

comment on function pg_catalog.pg_stat_get_db_xact_rollback(oid)
is 'statistics: transactions rolled back';

create function pg_catalog.pg_stat_get_db_blocks_fetched(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_db_blocks_fetched
;

comment on function pg_catalog.pg_stat_get_db_blocks_fetched(oid)
is 'statistics: blocks fetched for database';

create function pg_catalog.pg_stat_get_db_blocks_hit(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_db_blocks_hit
;

comment on function pg_catalog.pg_stat_get_db_blocks_hit(oid)
is 'statistics: blocks found in cache for database';

create function pg_catalog.encode(bytea, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.encode
;

comment on function pg_catalog.encode(bytea, text)
is 'convert bytea value into some ascii-only text string';

create function pg_catalog.decode(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.decode
;

comment on function pg_catalog.decode(text, text)
is 'convert ascii-encoded text string into bytea value';

create function pg_catalog.byteaeq(bytea, bytea)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.byteaeq
;

comment on function pg_catalog.byteaeq(bytea, bytea)
is 'implementation of = operator';

create function pg_catalog.bytealt(bytea, bytea)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bytealt
;

comment on function pg_catalog.bytealt(bytea, bytea)
is 'implementation of < operator';

create function pg_catalog.byteale(bytea, bytea)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.byteale
;

comment on function pg_catalog.byteale(bytea, bytea)
is 'implementation of <= operator';

create function pg_catalog.byteagt(bytea, bytea)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.byteagt
;

comment on function pg_catalog.byteagt(bytea, bytea)
is 'implementation of > operator';

create function pg_catalog.byteage(bytea, bytea)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.byteage
;

comment on function pg_catalog.byteage(bytea, bytea)
is 'implementation of >= operator';

create function pg_catalog.byteane(bytea, bytea)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.byteane
;

comment on function pg_catalog.byteane(bytea, bytea)
is 'implementation of <> operator';

create function pg_catalog.byteacmp(bytea, bytea)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.byteacmp
;

comment on function pg_catalog.byteacmp(bytea, bytea)
is 'less-equal-greater';

create function pg_catalog.timestamp(timestamp, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp
;

comment on function pg_catalog.timestamp(timestamp, integer)
is 'adjust timestamp precision';

create function pg_catalog.int2_avg_accum(bigint [], smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2_avg_accum
;

comment on function pg_catalog.int2_avg_accum(bigint [], smallint)
is 'aggregate transition function';

create function pg_catalog.int4_avg_accum(bigint [], integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4_avg_accum
;

comment on function pg_catalog.int4_avg_accum(bigint [], integer)
is 'aggregate transition function';

create function pg_catalog.int8_avg(bigint [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8_avg
;

comment on function pg_catalog.int8_avg(bigint [])
is 'aggregate final function';

create function pg_catalog.oidlarger(oid, oid)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.oidlarger
;

comment on function pg_catalog.oidlarger(oid, oid)
is 'larger of two';

create function pg_catalog.oidsmaller(oid, oid)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.oidsmaller
;

comment on function pg_catalog.oidsmaller(oid, oid)
is 'smaller of two';

create function pg_catalog.timestamptz(timestamp with time zone, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz
;

comment on function pg_catalog.timestamptz(timestamp with time zone, integer)
is 'adjust timestamptz precision';

create function pg_catalog.time(time, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.time
;

comment on function pg_catalog.time(time, integer)
is 'adjust time precision';

create function pg_catalog.timetz(time with time zone, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timetz
;

comment on function pg_catalog.timetz(time with time zone, integer)
is 'adjust time with time zone precision';

create function pg_catalog.pg_stat_get_tuples_hot_updated(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_tuples_hot_updated
;

comment on function pg_catalog.pg_stat_get_tuples_hot_updated(oid)
is 'statistics: number of tuples hot updated';

create function pg_catalog.div(numeric, numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.div
;

comment on function pg_catalog.div(numeric, numeric)
is 'trunc(x/y)';

create function pg_catalog.numeric_div_trunc(numeric, numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_div_trunc
;

comment on function pg_catalog.numeric_div_trunc(numeric, numeric)
is 'trunc(x/y)';

create function pg_catalog.shobj_description(oid, name)
  returns text
stable
strict
parallel safe
language sql
as $$
select description
from pg_catalog.pg_shdescription
where objoid = $1
  and classoid = (select oid
                  from pg_catalog.pg_class
                  where relname = $2
                    and relnamespace = 11)
$$;

comment on function pg_catalog.shobj_description(oid, name)
is 'get description for object id and shared catalog name';

create function pg_catalog.textanycat(text, anynonarray)
  returns text
stable
strict
parallel safe
cost 1
language sql
as $$
select $1 || $2 :: pg_catalog.text
$$;

comment on function pg_catalog.textanycat(text, anynonarray)
is 'implementation of || operator';

create function pg_catalog.anytextcat(anynonarray, text)
  returns text
stable
strict
parallel safe
cost 1
language sql
as $$
select $1 :: pg_catalog.text || $2
$$;

comment on function pg_catalog.anytextcat(anynonarray, text)
is 'implementation of || operator';

create function pg_catalog.bytealike(bytea, bytea)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bytealike
;

comment on function pg_catalog.bytealike(bytea, bytea)
is 'implementation of ~~ operator';

create function pg_catalog.byteanlike(bytea, bytea)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.byteanlike
;

comment on function pg_catalog.byteanlike(bytea, bytea)
is 'implementation of !~~ operator';

create function pg_catalog."like"(bytea, bytea)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog."like"
;

comment on function pg_catalog."like"(bytea, bytea)
is 'matches LIKE expression';

create function pg_catalog.notlike(bytea, bytea)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.notlike
;

comment on function pg_catalog.notlike(bytea, bytea)
is 'does not match LIKE expression';

create function pg_catalog.like_escape(bytea, bytea)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.like_escape
;

comment on function pg_catalog.like_escape(bytea, bytea)
is 'convert LIKE pattern to use backslash escapes';

create function pg_catalog.length(bytea)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.length
;

comment on function pg_catalog.length(bytea)
is 'octet length';

create function pg_catalog.byteacat(bytea, bytea)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.byteacat
;

comment on function pg_catalog.byteacat(bytea, bytea)
is 'implementation of || operator';

create function pg_catalog.substring(bytea, integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.substring
;

comment on function pg_catalog.substring(bytea, integer, integer)
is 'extract portion of string';

create function pg_catalog.substring(bytea, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.substring
;

comment on function pg_catalog.substring(bytea, integer)
is 'extract portion of string';

create function pg_catalog.position(bytea, bytea)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.position
;

comment on function pg_catalog.position(bytea, bytea)
is 'position of substring';

create function pg_catalog.btrim(bytea, bytea)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btrim
;

comment on function pg_catalog.btrim(bytea, bytea)
is 'trim both ends of string';

create function pg_catalog.time(timestamp with time zone)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.time
;

comment on function pg_catalog.time(timestamp with time zone)
is 'convert timestamp with time zone to time';

create function pg_catalog.date_trunc(text, timestamp)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_trunc
;

comment on function pg_catalog.date_trunc(text, timestamp)
is 'truncate timestamp to specified units';

create function pg_catalog.date_part(text, timestamp)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_part
;

comment on function pg_catalog.date_part(text, timestamp)
is 'extract field from timestamp';

create function pg_catalog.pg_stat_get_activity(pid integer, out datid oid, out pid integer, out usesysid oid,
                                                             out application_name text, out state text, out query text,
                                                             out wait_event_type text, out wait_event text,
                                                             out xact_start timestamp with time zone,
                                                             out query_start timestamp with time zone,
                                                             out backend_start timestamp with time zone,
                                                             out state_change timestamp with time zone,
                                                             out client_addr inet, out client_hostname text,
                                                             out client_port integer, out backend_xid xid,
                                                             out backend_xmin xid, out backend_type text,
                                                             out ssl boolean, out sslversion text, out sslcipher text,
                                                             out sslbits integer, out sslcompression boolean,
                                                             out sslclientdn text)
stable
parallel restricted
cost 1
rows 100
language internal
as
-- missing source code for pg_catalog.pg_stat_get_activity
;

comment on function pg_catalog.pg_stat_get_activity(integer, out oid, out integer, out oid, out text, out text,
                                                             out text, out text, out text, out timestamp with time zone,
                                                             out timestamp with time zone, out timestamp with time zone,
                                                             out timestamp with time zone, out inet, out text,
                                                             out integer, out xid, out xid, out text, out boolean,
                                                             out text, out text, out integer, out boolean, out text)
is 'statistics: information about currently active backends';

create function pg_catalog.timestamp(abstime)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp
;

comment on function pg_catalog.timestamp(abstime)
is 'convert abstime to timestamp';

create function pg_catalog.timestamp(date)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp
;

comment on function pg_catalog.timestamp(date)
is 'convert date to timestamp';

create function pg_catalog.timestamp(date, time)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp
;

comment on function pg_catalog.timestamp(date, time)
is 'convert date and time to timestamp';

create function pg_catalog.pg_backend_pid()
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_backend_pid
;

comment on function pg_catalog.pg_backend_pid()
is 'statistics: current backend PID';

create function pg_catalog.timestamp(timestamp with time zone)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp
;

comment on function pg_catalog.timestamp(timestamp with time zone)
is 'convert timestamp with time zone to timestamp';

create function pg_catalog.timestamptz(timestamp)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz
;

comment on function pg_catalog.timestamptz(timestamp)
is 'convert timestamp to timestamp with time zone';

create function pg_catalog.date(timestamp)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date
;

comment on function pg_catalog.date(timestamp)
is 'convert timestamp to date';

create function pg_catalog.abstime(timestamp)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.abstime
;

comment on function pg_catalog.abstime(timestamp)
is 'convert timestamp to abstime';

create function pg_catalog.timestamp_mi(timestamp, timestamp)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_mi
;

comment on function pg_catalog.timestamp_mi(timestamp, timestamp)
is 'implementation of - operator';

create function pg_catalog.timestamp_pl_interval(timestamp, interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_pl_interval
;

comment on function pg_catalog.timestamp_pl_interval(timestamp, interval)
is 'implementation of + operator';

create function pg_catalog.timestamp_mi_interval(timestamp, interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_mi_interval
;

comment on function pg_catalog.timestamp_mi_interval(timestamp, interval)
is 'implementation of - operator';

create function pg_catalog.pg_conf_load_time()
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_conf_load_time
;

comment on function pg_catalog.pg_conf_load_time()
is 'configuration load time';

create function pg_catalog.timestamp_smaller(timestamp, timestamp)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_smaller
;

comment on function pg_catalog.timestamp_smaller(timestamp, timestamp)
is 'smaller of two';

create function pg_catalog.timestamp_larger(timestamp, timestamp)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_larger
;

comment on function pg_catalog.timestamp_larger(timestamp, timestamp)
is 'larger of two';

create function pg_catalog.timezone(text, time with time zone)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timezone
;

comment on function pg_catalog.timezone(text, time with time zone)
is 'adjust time with time zone to new zone';

create function pg_catalog.timezone(interval, time with time zone)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timezone
;

comment on function pg_catalog.timezone(interval, time with time zone)
is 'adjust time with time zone to new zone';

create function pg_catalog.timestamp_hash(timestamp)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_hash
;

comment on function pg_catalog.timestamp_hash(timestamp)
is 'hash';

create function pg_catalog."overlaps"(timestamp, timestamp, timestamp, timestamp)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog."overlaps"
;

comment on function pg_catalog."overlaps"(timestamp, timestamp, timestamp, timestamp)
is 'intervals overlap?';

create function pg_catalog."overlaps"(timestamp without time zone, interval, timestamp without time zone, interval)
  returns boolean
immutable
parallel safe
cost 1
language sql
as $$
select ($1, ($1 + $2)) overlaps ($3, ($3 + $4))
$$;

comment on function pg_catalog."overlaps"(timestamp, interval, timestamp, interval)
is 'intervals overlap?';

create function pg_catalog."overlaps"(timestamp without time zone, timestamp without time zone,
                                      timestamp without time zone, interval)
  returns boolean
immutable
parallel safe
cost 1
language sql
as $$
select ($1, $2) overlaps ($3, ($3 + $4))
$$;

comment on function pg_catalog."overlaps"(timestamp, timestamp, timestamp, interval)
is 'intervals overlap?';

create function pg_catalog."overlaps"(timestamp without time zone, interval, timestamp without time zone,
                                      timestamp without time zone)
  returns boolean
immutable
parallel safe
cost 1
language sql
as $$
select ($1, ($1 + $2)) overlaps ($3, $4)
$$;

comment on function pg_catalog."overlaps"(timestamp, interval, timestamp, timestamp)
is 'intervals overlap?';

create function pg_catalog.timestamp_cmp(timestamp, timestamp)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_cmp
;

comment on function pg_catalog.timestamp_cmp(timestamp, timestamp)
is 'less-equal-greater';

create function pg_catalog.time(time with time zone)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.time
;

comment on function pg_catalog.time(time with time zone)
is 'convert time with time zone to time';

create function pg_catalog.timetz(time)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timetz
;

comment on function pg_catalog.timetz(time)
is 'convert time to time with time zone';

create function pg_catalog.isfinite(timestamp)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.isfinite
;

comment on function pg_catalog.isfinite(timestamp)
is 'finite timestamp?';

create function pg_catalog.to_char(timestamp, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.to_char
;

comment on function pg_catalog.to_char(timestamp, text)
is 'format timestamp to text';

create function pg_catalog.timestamp_eq(timestamp, timestamp)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_eq
;

comment on function pg_catalog.timestamp_eq(timestamp, timestamp)
is 'implementation of = operator';

create function pg_catalog.timestamp_ne(timestamp, timestamp)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_ne
;

comment on function pg_catalog.timestamp_ne(timestamp, timestamp)
is 'implementation of <> operator';

create function pg_catalog.timestamp_lt(timestamp, timestamp)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_lt
;

comment on function pg_catalog.timestamp_lt(timestamp, timestamp)
is 'implementation of < operator';

create function pg_catalog.timestamp_le(timestamp, timestamp)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_le
;

comment on function pg_catalog.timestamp_le(timestamp, timestamp)
is 'implementation of <= operator';

create function pg_catalog.timestamp_ge(timestamp, timestamp)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_ge
;

comment on function pg_catalog.timestamp_ge(timestamp, timestamp)
is 'implementation of >= operator';

create function pg_catalog.timestamp_gt(timestamp, timestamp)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_gt
;

comment on function pg_catalog.timestamp_gt(timestamp, timestamp)
is 'implementation of > operator';

create function pg_catalog.age(timestamp, timestamp)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.age
;

comment on function pg_catalog.age(timestamp, timestamp)
is 'date difference preserving months and years';

create function pg_catalog.age(timestamp without time zone)
  returns interval
stable
strict
parallel safe
cost 1
language sql
as $$
select pg_catalog.age(cast(current_date as timestamp without time zone), $1)
$$;

comment on function pg_catalog.age(timestamp)
is 'date difference from today preserving months and years';

create function pg_catalog.timezone(text, timestamp)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timezone
;

comment on function pg_catalog.timezone(text, timestamp)
is 'adjust timestamp to new time zone';

create function pg_catalog.timezone(interval, timestamp)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timezone
;

comment on function pg_catalog.timezone(interval, timestamp)
is 'adjust timestamp to new time zone';

create function pg_catalog.date_pl_interval(date, interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_pl_interval
;

comment on function pg_catalog.date_pl_interval(date, interval)
is 'implementation of + operator';

create function pg_catalog.date_mi_interval(date, interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_mi_interval
;

comment on function pg_catalog.date_mi_interval(date, interval)
is 'implementation of - operator';

create function pg_catalog.substring(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.substring
;

comment on function pg_catalog.substring(text, text)
is 'extract text matching regular expression';

create function pg_catalog.substring(text, text, text)
  returns text
immutable
strict
parallel safe
cost 1
language sql
as $$
select pg_catalog.substring($1, pg_catalog.similar_escape($2, $3))
$$;

comment on function pg_catalog.substring(text, text, text)
is 'extract text matching SQL99 regular expression';

create function pg_catalog.bit(bigint, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bit
;

comment on function pg_catalog.bit(bigint, integer)
is 'convert int8 to bitstring';

create function pg_catalog.int8(bit)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8
;

comment on function pg_catalog.int8(bit)
is 'convert bitstring to int8';

create function pg_catalog.current_setting(text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.current_setting
;

comment on function pg_catalog.current_setting(text)
is 'SHOW X as a function';

create function pg_catalog.set_config(text, text, boolean)
cost 1
language internal
as
-- missing source code for pg_catalog.set_config
;

comment on function pg_catalog.set_config(text, text, boolean)
is 'SET X as a function';

create function pg_catalog.pg_table_is_visible(oid)
stable
strict
parallel safe
cost 10
language internal
as
-- missing source code for pg_catalog.pg_table_is_visible
;

comment on function pg_catalog.pg_table_is_visible(oid)
is 'is table visible in search path?';

create function pg_catalog.pg_type_is_visible(oid)
stable
strict
parallel safe
cost 10
language internal
as
-- missing source code for pg_catalog.pg_type_is_visible
;

comment on function pg_catalog.pg_type_is_visible(oid)
is 'is type visible in search path?';

create function pg_catalog.pg_function_is_visible(oid)
stable
strict
parallel safe
cost 10
language internal
as
-- missing source code for pg_catalog.pg_function_is_visible
;

comment on function pg_catalog.pg_function_is_visible(oid)
is 'is function visible in search path?';

create function pg_catalog.pg_operator_is_visible(oid)
stable
strict
parallel safe
cost 10
language internal
as
-- missing source code for pg_catalog.pg_operator_is_visible
;

comment on function pg_catalog.pg_operator_is_visible(oid)
is 'is operator visible in search path?';

create function pg_catalog.pg_opclass_is_visible(oid)
stable
strict
parallel safe
cost 10
language internal
as
-- missing source code for pg_catalog.pg_opclass_is_visible
;

comment on function pg_catalog.pg_opclass_is_visible(oid)
is 'is opclass visible in search path?';

create function pg_catalog.pg_show_all_settings(out name            text, out setting text, out unit text,
                                                out category        text, out short_desc text, out extra_desc text,
                                                out context         text, out vartype text, out source text,
                                                out min_val         text, out max_val text, out enumvals text [],
                                                out boot_val        text, out reset_val text, out sourcefile text,
                                                out sourceline      integer, out pending_restart boolean)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_show_all_settings
;

comment on function pg_catalog.pg_show_all_settings(out text, out text, out text, out text, out text, out text,
                                                    out text, out text, out text, out text, out text, out text [],
                                                    out text, out text, out text, out integer, out boolean)
is 'SHOW ALL as a function';

create function pg_catalog.substr(bytea, integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.substr
;

comment on function pg_catalog.substr(bytea, integer, integer)
is 'extract portion of string';

create function pg_catalog.substr(bytea, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.substr
;

comment on function pg_catalog.substr(bytea, integer)
is 'extract portion of string';

create function pg_catalog.replace(text, text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.replace
;

comment on function pg_catalog.replace(text, text, text)
is 'replace all occurrences in string of old_substr with new_substr';

create function pg_catalog.split_part(text, text, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.split_part
;

comment on function pg_catalog.split_part(text, text, integer)
is 'split string by field_sep and return field_num';

create function pg_catalog.to_hex(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.to_hex
;

comment on function pg_catalog.to_hex(integer)
is 'convert int4 number to hex';

create function pg_catalog.to_hex(bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.to_hex
;

comment on function pg_catalog.to_hex(bigint)
is 'convert int8 number to hex';

create function pg_catalog.array_lower(anyarray, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_lower
;

comment on function pg_catalog.array_lower(anyarray, integer)
is 'array lower dimension';

create function pg_catalog.array_upper(anyarray, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_upper
;

comment on function pg_catalog.array_upper(anyarray, integer)
is 'array upper dimension';

create function pg_catalog.pg_conversion_is_visible(oid)
stable
strict
parallel safe
cost 10
language internal
as
-- missing source code for pg_catalog.pg_conversion_is_visible
;

comment on function pg_catalog.pg_conversion_is_visible(oid)
is 'is conversion visible in search path?';

create function pg_catalog.pg_stat_get_backend_activity_start(integer)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_backend_activity_start
;

comment on function pg_catalog.pg_stat_get_backend_activity_start(integer)
is 'statistics: start time for current query of backend';

create function pg_catalog.pg_terminate_backend(integer)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_terminate_backend
;

comment on function pg_catalog.pg_terminate_backend(integer)
is 'terminate a server process';

create function pg_catalog.pg_get_functiondef(oid)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_get_functiondef
;

comment on function pg_catalog.pg_get_functiondef(oid)
is 'definition of a function';

create function pg_catalog.text_pattern_lt(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.text_pattern_lt
;

comment on function pg_catalog.text_pattern_lt(text, text)
is 'implementation of ~<~ operator';

create function pg_catalog.text_pattern_le(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.text_pattern_le
;

comment on function pg_catalog.text_pattern_le(text, text)
is 'implementation of ~<=~ operator';

create function pg_catalog.pg_get_function_arguments(oid)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_get_function_arguments
;

comment on function pg_catalog.pg_get_function_arguments(oid)
is 'argument list of a function';

create function pg_catalog.text_pattern_ge(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.text_pattern_ge
;

comment on function pg_catalog.text_pattern_ge(text, text)
is 'implementation of ~>=~ operator';

create function pg_catalog.text_pattern_gt(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.text_pattern_gt
;

comment on function pg_catalog.text_pattern_gt(text, text)
is 'implementation of ~>~ operator';

create function pg_catalog.pg_get_function_result(oid)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_get_function_result
;

comment on function pg_catalog.pg_get_function_result(oid)
is 'result type of a function';

create function pg_catalog.bttext_pattern_cmp(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bttext_pattern_cmp
;

comment on function pg_catalog.bttext_pattern_cmp(text, text)
is 'less-equal-greater';

create function pg_catalog.ceiling(numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ceiling
;

comment on function pg_catalog.ceiling(numeric)
is 'nearest integer >= value';

create function pg_catalog.pg_database_size(name)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_database_size
;

comment on function pg_catalog.pg_database_size(name)
is 'total disk space usage for the specified database';

create function pg_catalog.power(numeric, numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.power
;

comment on function pg_catalog.power(numeric, numeric)
is 'exponentiation';

create function pg_catalog.width_bucket(numeric, numeric, numeric, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.width_bucket
;

comment on function pg_catalog.width_bucket(numeric, numeric, numeric, integer)
is 'bucket number of operand in equal-width histogram';

create function pg_catalog.pg_cancel_backend(integer)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_cancel_backend
;

comment on function pg_catalog.pg_cancel_backend(integer)
is 'cancel a server process'' current query';

create function pg_catalog.pg_start_backup(label text, fast boolean default false, exclusive boolean default true)
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_start_backup
;

comment on function pg_catalog.pg_start_backup(text, boolean, boolean)
is 'prepare for taking an online backup';

create function pg_catalog.pg_stop_backup()
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stop_backup
;

comment on function pg_catalog.pg_stop_backup()
is 'finish taking an online backup';

create function pg_catalog.bpchar_pattern_lt(char, char)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpchar_pattern_lt
;

comment on function pg_catalog.bpchar_pattern_lt(char, char)
is 'implementation of ~<~ operator';

create function pg_catalog.bpchar_pattern_le(char, char)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpchar_pattern_le
;

comment on function pg_catalog.bpchar_pattern_le(char, char)
is 'implementation of ~<=~ operator';

create function pg_catalog.array_length(anyarray, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_length
;

comment on function pg_catalog.array_length(anyarray, integer)
is 'array length';

create function pg_catalog.bpchar_pattern_ge(char, char)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpchar_pattern_ge
;

comment on function pg_catalog.bpchar_pattern_ge(char, char)
is 'implementation of ~>=~ operator';

create function pg_catalog.bpchar_pattern_gt(char, char)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpchar_pattern_gt
;

comment on function pg_catalog.bpchar_pattern_gt(char, char)
is 'implementation of ~>~ operator';

create function pg_catalog.gist_point_consistent(internal, point, smallint, oid, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gist_point_consistent
;

comment on function pg_catalog.gist_point_consistent(internal, point, smallint, oid, internal)
is 'GiST support';

create function pg_catalog.btbpchar_pattern_cmp(char, char)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btbpchar_pattern_cmp
;

comment on function pg_catalog.btbpchar_pattern_cmp(char, char)
is 'less-equal-greater';

create function pg_catalog.has_sequence_privilege(name, text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_sequence_privilege
;

comment on function pg_catalog.has_sequence_privilege(name, text, text)
is 'user privilege on sequence by username, seq name';

create function pg_catalog.has_sequence_privilege(name, oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_sequence_privilege
;

comment on function pg_catalog.has_sequence_privilege(name, oid, text)
is 'user privilege on sequence by username, seq oid';

create function pg_catalog.has_sequence_privilege(oid, text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_sequence_privilege
;

comment on function pg_catalog.has_sequence_privilege(oid, text, text)
is 'user privilege on sequence by user oid, seq name';

create function pg_catalog.has_sequence_privilege(oid, oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_sequence_privilege
;

comment on function pg_catalog.has_sequence_privilege(oid, oid, text)
is 'user privilege on sequence by user oid, seq oid';

create function pg_catalog.has_sequence_privilege(text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_sequence_privilege
;

comment on function pg_catalog.has_sequence_privilege(text, text)
is 'current user privilege on sequence by seq name';

create function pg_catalog.has_sequence_privilege(oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_sequence_privilege
;

comment on function pg_catalog.has_sequence_privilege(oid, text)
is 'current user privilege on sequence by seq oid';

create function pg_catalog.btint48cmp(integer, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btint48cmp
;

comment on function pg_catalog.btint48cmp(integer, bigint)
is 'less-equal-greater';

create function pg_catalog.btint84cmp(bigint, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btint84cmp
;

comment on function pg_catalog.btint84cmp(bigint, integer)
is 'less-equal-greater';

create function pg_catalog.btint24cmp(smallint, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btint24cmp
;

comment on function pg_catalog.btint24cmp(smallint, integer)
is 'less-equal-greater';

create function pg_catalog.btint42cmp(integer, smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btint42cmp
;

comment on function pg_catalog.btint42cmp(integer, smallint)
is 'less-equal-greater';

create function pg_catalog.btint28cmp(smallint, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btint28cmp
;

comment on function pg_catalog.btint28cmp(smallint, bigint)
is 'less-equal-greater';

create function pg_catalog.btint82cmp(bigint, smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btint82cmp
;

comment on function pg_catalog.btint82cmp(bigint, smallint)
is 'less-equal-greater';

create function pg_catalog.btfloat48cmp(real, double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btfloat48cmp
;

comment on function pg_catalog.btfloat48cmp(real, double precision)
is 'less-equal-greater';

create function pg_catalog.btfloat84cmp(double precision, real)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btfloat84cmp
;

comment on function pg_catalog.btfloat84cmp(double precision, real)
is 'less-equal-greater';

create function pg_catalog.inet_client_addr()
stable
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.inet_client_addr
;

comment on function pg_catalog.inet_client_addr()
is 'inet address of the client';

create function pg_catalog.inet_client_port()
stable
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.inet_client_port
;

comment on function pg_catalog.inet_client_port()
is 'client''s port number for this connection';

create function pg_catalog.inet_server_addr()
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inet_server_addr
;

comment on function pg_catalog.inet_server_addr()
is 'inet address of the server';

create function pg_catalog.inet_server_port()
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inet_server_port
;

comment on function pg_catalog.inet_server_port()
is 'server''s port number for this connection';

create function pg_catalog.regprocedurein(cstring)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regprocedurein
;

comment on function pg_catalog.regprocedurein(cstring)
is 'I/O';

create function pg_catalog.regprocedureout(regprocedure)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regprocedureout
;

comment on function pg_catalog.regprocedureout(regprocedure)
is 'I/O';

create function pg_catalog.regoperin(cstring)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regoperin
;

comment on function pg_catalog.regoperin(cstring)
is 'I/O';

create function pg_catalog.regoperout(regoper)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regoperout
;

comment on function pg_catalog.regoperout(regoper)
is 'I/O';

create function pg_catalog.regoperatorin(cstring)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regoperatorin
;

comment on function pg_catalog.regoperatorin(cstring)
is 'I/O';

create function pg_catalog.regoperatorout(regoperator)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regoperatorout
;

comment on function pg_catalog.regoperatorout(regoperator)
is 'I/O';

create function pg_catalog.regclassin(cstring)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regclassin
;

comment on function pg_catalog.regclassin(cstring)
is 'I/O';

create function pg_catalog.regclassout(regclass)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regclassout
;

comment on function pg_catalog.regclassout(regclass)
is 'I/O';

create function pg_catalog.regtypein(cstring)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regtypein
;

comment on function pg_catalog.regtypein(cstring)
is 'I/O';

create function pg_catalog.regtypeout(regtype)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regtypeout
;

comment on function pg_catalog.regtypeout(regtype)
is 'I/O';

create function pg_catalog.pg_stat_clear_snapshot()
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_clear_snapshot
;

comment on function pg_catalog.pg_stat_clear_snapshot()
is 'statistics: discard current transaction''s statistics snapshot';

create function pg_catalog.pg_get_function_identity_arguments(oid)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_get_function_identity_arguments
;

comment on function pg_catalog.pg_get_function_identity_arguments(oid)
is 'identity argument list of a function';

create function pg_catalog.fmgr_internal_validator(oid)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.fmgr_internal_validator
;

comment on function pg_catalog.fmgr_internal_validator(oid)
is '(internal)';

create function pg_catalog.fmgr_c_validator(oid)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.fmgr_c_validator
;

comment on function pg_catalog.fmgr_c_validator(oid)
is '(internal)';

create function pg_catalog.fmgr_sql_validator(oid)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.fmgr_sql_validator
;

comment on function pg_catalog.fmgr_sql_validator(oid)
is '(internal)';

create function pg_catalog.has_database_privilege(name, text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_database_privilege
;

comment on function pg_catalog.has_database_privilege(name, text, text)
is 'user privilege on database by username, database name';

create function pg_catalog.has_database_privilege(name, oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_database_privilege
;

comment on function pg_catalog.has_database_privilege(name, oid, text)
is 'user privilege on database by username, database oid';

create function pg_catalog.has_database_privilege(oid, text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_database_privilege
;

comment on function pg_catalog.has_database_privilege(oid, text, text)
is 'user privilege on database by user oid, database name';

create function pg_catalog.has_database_privilege(oid, oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_database_privilege
;

comment on function pg_catalog.has_database_privilege(oid, oid, text)
is 'user privilege on database by user oid, database oid';

create function pg_catalog.has_database_privilege(text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_database_privilege
;

comment on function pg_catalog.has_database_privilege(text, text)
is 'current user privilege on database by database name';

create function pg_catalog.has_database_privilege(oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_database_privilege
;

comment on function pg_catalog.has_database_privilege(oid, text)
is 'current user privilege on database by database oid';

create function pg_catalog.has_function_privilege(name, text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_function_privilege
;

comment on function pg_catalog.has_function_privilege(name, text, text)
is 'user privilege on function by username, function name';

create function pg_catalog.has_function_privilege(name, oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_function_privilege
;

comment on function pg_catalog.has_function_privilege(name, oid, text)
is 'user privilege on function by username, function oid';

create function pg_catalog.has_function_privilege(oid, text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_function_privilege
;

comment on function pg_catalog.has_function_privilege(oid, text, text)
is 'user privilege on function by user oid, function name';

create function pg_catalog.has_function_privilege(oid, oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_function_privilege
;

comment on function pg_catalog.has_function_privilege(oid, oid, text)
is 'user privilege on function by user oid, function oid';

create function pg_catalog.has_function_privilege(text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_function_privilege
;

comment on function pg_catalog.has_function_privilege(text, text)
is 'current user privilege on function by function name';

create function pg_catalog.has_function_privilege(oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_function_privilege
;

comment on function pg_catalog.has_function_privilege(oid, text)
is 'current user privilege on function by function oid';

create function pg_catalog.has_language_privilege(name, text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_language_privilege
;

comment on function pg_catalog.has_language_privilege(name, text, text)
is 'user privilege on language by username, language name';

create function pg_catalog.has_language_privilege(name, oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_language_privilege
;

comment on function pg_catalog.has_language_privilege(name, oid, text)
is 'user privilege on language by username, language oid';

create function pg_catalog.has_language_privilege(oid, text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_language_privilege
;

comment on function pg_catalog.has_language_privilege(oid, text, text)
is 'user privilege on language by user oid, language name';

create function pg_catalog.has_language_privilege(oid, oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_language_privilege
;

comment on function pg_catalog.has_language_privilege(oid, oid, text)
is 'user privilege on language by user oid, language oid';

create function pg_catalog.has_language_privilege(text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_language_privilege
;

comment on function pg_catalog.has_language_privilege(text, text)
is 'current user privilege on language by language name';

create function pg_catalog.has_language_privilege(oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_language_privilege
;

comment on function pg_catalog.has_language_privilege(oid, text)
is 'current user privilege on language by language oid';

create function pg_catalog.has_schema_privilege(name, text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_schema_privilege
;

comment on function pg_catalog.has_schema_privilege(name, text, text)
is 'user privilege on schema by username, schema name';

create function pg_catalog.has_schema_privilege(name, oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_schema_privilege
;

comment on function pg_catalog.has_schema_privilege(name, oid, text)
is 'user privilege on schema by username, schema oid';

create function pg_catalog.has_schema_privilege(oid, text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_schema_privilege
;

comment on function pg_catalog.has_schema_privilege(oid, text, text)
is 'user privilege on schema by user oid, schema name';

create function pg_catalog.has_schema_privilege(oid, oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_schema_privilege
;

comment on function pg_catalog.has_schema_privilege(oid, oid, text)
is 'user privilege on schema by user oid, schema oid';

create function pg_catalog.has_schema_privilege(text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_schema_privilege
;

comment on function pg_catalog.has_schema_privilege(text, text)
is 'current user privilege on schema by schema name';

create function pg_catalog.has_schema_privilege(oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_schema_privilege
;

comment on function pg_catalog.has_schema_privilege(oid, text)
is 'current user privilege on schema by schema oid';

create function pg_catalog.pg_stat_reset()
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_reset
;

comment on function pg_catalog.pg_stat_reset()
is 'statistics: reset collected statistics for current database';

create function pg_catalog.regexp_replace(text, text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regexp_replace
;

comment on function pg_catalog.regexp_replace(text, text, text)
is 'replace text using regexp';

create function pg_catalog.regexp_replace(text, text, text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regexp_replace
;

comment on function pg_catalog.regexp_replace(text, text, text, text)
is 'replace text using regexp';

create function pg_catalog.pg_total_relation_size(regclass)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_total_relation_size
;

comment on function pg_catalog.pg_total_relation_size(regclass)
is 'total disk space usage for the specified table and associated indexes';

create function pg_catalog.pg_size_pretty(bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_size_pretty
;

comment on function pg_catalog.pg_size_pretty(bigint)
is 'convert a long int to a human readable text using size units';

create function pg_catalog.pg_options_to_table(options_array text [], out option_name text, out option_value text)
stable
strict
parallel safe
cost 1
rows 3
language internal
as
-- missing source code for pg_catalog.pg_options_to_table
;

comment on function pg_catalog.pg_options_to_table(text [], out text, out text)
is 'convert generic options array to name/value table';

create function pg_catalog.record_in(cstring, oid, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.record_in
;

comment on function pg_catalog.record_in(cstring, oid, integer)
is 'I/O';

create function pg_catalog.record_out(record)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.record_out
;

comment on function pg_catalog.record_out(record)
is 'I/O';

create function pg_catalog.cstring_in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cstring_in
;

comment on function pg_catalog.cstring_in(cstring)
is 'I/O';

create function pg_catalog.cstring_out(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cstring_out
;

comment on function pg_catalog.cstring_out(cstring)
is 'I/O';

create function pg_catalog.any_in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.any_in
;

comment on function pg_catalog.any_in(cstring)
is 'I/O';

create function pg_catalog.any_out("any")
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.any_out
;

comment on function pg_catalog.any_out("any")
is 'I/O';

create function pg_catalog.anyarray_in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.anyarray_in
;

comment on function pg_catalog.anyarray_in(cstring)
is 'I/O';

create function pg_catalog.anyarray_out(anyarray)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.anyarray_out
;

comment on function pg_catalog.anyarray_out(anyarray)
is 'I/O';

create function pg_catalog.void_in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.void_in
;

comment on function pg_catalog.void_in(cstring)
is 'I/O';

create function pg_catalog.void_out(void)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.void_out
;

comment on function pg_catalog.void_out(void)
is 'I/O';

create function pg_catalog.trigger_in(cstring)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.trigger_in
;

comment on function pg_catalog.trigger_in(cstring)
is 'I/O';

create function pg_catalog.trigger_out(trigger)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.trigger_out
;

comment on function pg_catalog.trigger_out(trigger)
is 'I/O';

create function pg_catalog.language_handler_in(cstring)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.language_handler_in
;

comment on function pg_catalog.language_handler_in(cstring)
is 'I/O';

create function pg_catalog.language_handler_out(language_handler)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.language_handler_out
;

comment on function pg_catalog.language_handler_out(language_handler)
is 'I/O';

create function pg_catalog.internal_in(cstring)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.internal_in
;

comment on function pg_catalog.internal_in(cstring)
is 'I/O';

create function pg_catalog.internal_out(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.internal_out
;

comment on function pg_catalog.internal_out(internal)
is 'I/O';

create function pg_catalog.opaque_in(cstring)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.opaque_in
;

comment on function pg_catalog.opaque_in(cstring)
is 'I/O';

create function pg_catalog.opaque_out(opaque)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.opaque_out
;

comment on function pg_catalog.opaque_out(opaque)
is 'I/O';

create function pg_catalog.ceil(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ceil
;

comment on function pg_catalog.ceil(double precision)
is 'nearest integer >= value';

create function pg_catalog.floor(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.floor
;

comment on function pg_catalog.floor(double precision)
is 'nearest integer <= value';

create function pg_catalog.sign(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.sign
;

comment on function pg_catalog.sign(double precision)
is 'sign of value';

create function pg_catalog.md5(text)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.md5
;

comment on function pg_catalog.md5(text)
is 'MD5 hash';

create function pg_catalog.anyelement_in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.anyelement_in
;

comment on function pg_catalog.anyelement_in(cstring)
is 'I/O';

create function pg_catalog.anyelement_out(anyelement)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.anyelement_out
;

comment on function pg_catalog.anyelement_out(anyelement)
is 'I/O';

create function pg_catalog.postgresql_fdw_validator(text [], oid)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.postgresql_fdw_validator
;

comment on function pg_catalog.postgresql_fdw_validator(text [], oid)
is '(internal)';

create function pg_catalog.pg_encoding_max_length(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_encoding_max_length
;

comment on function pg_catalog.pg_encoding_max_length(integer)
is 'maximum octet length of a character in given encoding';

create function pg_catalog.ceiling(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ceiling
;

comment on function pg_catalog.ceiling(double precision)
is 'nearest integer >= value';

create function pg_catalog.md5(bytea)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.md5
;

comment on function pg_catalog.md5(bytea)
is 'MD5 hash';

create function pg_catalog.pg_tablespace_size(oid)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_tablespace_size
;

comment on function pg_catalog.pg_tablespace_size(oid)
is 'total disk space usage for the specified tablespace';

create function pg_catalog.pg_tablespace_size(name)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_tablespace_size
;

comment on function pg_catalog.pg_tablespace_size(name)
is 'total disk space usage for the specified tablespace';

create function pg_catalog.pg_database_size(oid)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_database_size
;

comment on function pg_catalog.pg_database_size(oid)
is 'total disk space usage for the specified database';

create function pg_catalog.pg_relation_size(regclass)
  returns bigint
strict
parallel safe
cost 1
language sql
as $$
select pg_catalog.pg_relation_size($1, 'main')
$$;

comment on function pg_catalog.pg_relation_size(regclass)
is 'disk space usage for the main fork of the specified table or index';

create function pg_catalog.unnest(anyarray)
immutable
strict
parallel safe
cost 1
rows 100
language internal
as
-- missing source code for pg_catalog.unnest
;

comment on function pg_catalog.unnest(anyarray)
is 'expand array to set of rows';

create function pg_catalog.pg_relation_size(regclass, text)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_relation_size
;

comment on function pg_catalog.pg_relation_size(regclass, text)
is 'disk space usage for the specified fork of a table or index';

create function pg_catalog.array_agg_transfn(internal, anynonarray)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_agg_transfn
;

comment on function pg_catalog.array_agg_transfn(internal, anynonarray)
is 'aggregate transition function';

create function pg_catalog.array_agg_finalfn(internal, anynonarray)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_agg_finalfn
;

comment on function pg_catalog.array_agg_finalfn(internal, anynonarray)
is 'aggregate final function';

create function pg_catalog.date_lt_timestamp(date, timestamp)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_lt_timestamp
;

comment on function pg_catalog.date_lt_timestamp(date, timestamp)
is 'implementation of < operator';

create function pg_catalog.date_le_timestamp(date, timestamp)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_le_timestamp
;

comment on function pg_catalog.date_le_timestamp(date, timestamp)
is 'implementation of <= operator';

create function pg_catalog.date_eq_timestamp(date, timestamp)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_eq_timestamp
;

comment on function pg_catalog.date_eq_timestamp(date, timestamp)
is 'implementation of = operator';

create function pg_catalog.date_gt_timestamp(date, timestamp)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_gt_timestamp
;

comment on function pg_catalog.date_gt_timestamp(date, timestamp)
is 'implementation of > operator';

create function pg_catalog.date_ge_timestamp(date, timestamp)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_ge_timestamp
;

comment on function pg_catalog.date_ge_timestamp(date, timestamp)
is 'implementation of >= operator';

create function pg_catalog.date_ne_timestamp(date, timestamp)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_ne_timestamp
;

comment on function pg_catalog.date_ne_timestamp(date, timestamp)
is 'implementation of <> operator';

create function pg_catalog.date_cmp_timestamp(date, timestamp)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_cmp_timestamp
;

comment on function pg_catalog.date_cmp_timestamp(date, timestamp)
is 'less-equal-greater';

create function pg_catalog.date_lt_timestamptz(date, timestamp with time zone)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_lt_timestamptz
;

comment on function pg_catalog.date_lt_timestamptz(date, timestamp with time zone)
is 'implementation of < operator';

create function pg_catalog.date_le_timestamptz(date, timestamp with time zone)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_le_timestamptz
;

comment on function pg_catalog.date_le_timestamptz(date, timestamp with time zone)
is 'implementation of <= operator';

create function pg_catalog.date_eq_timestamptz(date, timestamp with time zone)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_eq_timestamptz
;

comment on function pg_catalog.date_eq_timestamptz(date, timestamp with time zone)
is 'implementation of = operator';

create function pg_catalog.date_gt_timestamptz(date, timestamp with time zone)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_gt_timestamptz
;

comment on function pg_catalog.date_gt_timestamptz(date, timestamp with time zone)
is 'implementation of > operator';

create function pg_catalog.date_ge_timestamptz(date, timestamp with time zone)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_ge_timestamptz
;

comment on function pg_catalog.date_ge_timestamptz(date, timestamp with time zone)
is 'implementation of >= operator';

create function pg_catalog.date_ne_timestamptz(date, timestamp with time zone)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_ne_timestamptz
;

comment on function pg_catalog.date_ne_timestamptz(date, timestamp with time zone)
is 'implementation of <> operator';

create function pg_catalog.date_cmp_timestamptz(date, timestamp with time zone)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_cmp_timestamptz
;

comment on function pg_catalog.date_cmp_timestamptz(date, timestamp with time zone)
is 'less-equal-greater';

create function pg_catalog.timestamp_lt_date(timestamp, date)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_lt_date
;

comment on function pg_catalog.timestamp_lt_date(timestamp, date)
is 'implementation of < operator';

create function pg_catalog.timestamp_le_date(timestamp, date)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_le_date
;

comment on function pg_catalog.timestamp_le_date(timestamp, date)
is 'implementation of <= operator';

create function pg_catalog.timestamp_eq_date(timestamp, date)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_eq_date
;

comment on function pg_catalog.timestamp_eq_date(timestamp, date)
is 'implementation of = operator';

create function pg_catalog.timestamp_gt_date(timestamp, date)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_gt_date
;

comment on function pg_catalog.timestamp_gt_date(timestamp, date)
is 'implementation of > operator';

create function pg_catalog.timestamp_ge_date(timestamp, date)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_ge_date
;

comment on function pg_catalog.timestamp_ge_date(timestamp, date)
is 'implementation of >= operator';

create function pg_catalog.timestamp_ne_date(timestamp, date)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_ne_date
;

comment on function pg_catalog.timestamp_ne_date(timestamp, date)
is 'implementation of <> operator';

create function pg_catalog.timestamp_cmp_date(timestamp, date)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_cmp_date
;

comment on function pg_catalog.timestamp_cmp_date(timestamp, date)
is 'less-equal-greater';

create function pg_catalog.timestamptz_lt_date(timestamp with time zone, date)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_lt_date
;

comment on function pg_catalog.timestamptz_lt_date(timestamp with time zone, date)
is 'implementation of < operator';

create function pg_catalog.timestamptz_le_date(timestamp with time zone, date)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_le_date
;

comment on function pg_catalog.timestamptz_le_date(timestamp with time zone, date)
is 'implementation of <= operator';

create function pg_catalog.timestamptz_eq_date(timestamp with time zone, date)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_eq_date
;

comment on function pg_catalog.timestamptz_eq_date(timestamp with time zone, date)
is 'implementation of = operator';

create function pg_catalog.timestamptz_gt_date(timestamp with time zone, date)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_gt_date
;

comment on function pg_catalog.timestamptz_gt_date(timestamp with time zone, date)
is 'implementation of > operator';

create function pg_catalog.timestamptz_ge_date(timestamp with time zone, date)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_ge_date
;

comment on function pg_catalog.timestamptz_ge_date(timestamp with time zone, date)
is 'implementation of >= operator';

create function pg_catalog.timestamptz_ne_date(timestamp with time zone, date)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_ne_date
;

comment on function pg_catalog.timestamptz_ne_date(timestamp with time zone, date)
is 'implementation of <> operator';

create function pg_catalog.timestamptz_cmp_date(timestamp with time zone, date)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_cmp_date
;

comment on function pg_catalog.timestamptz_cmp_date(timestamp with time zone, date)
is 'less-equal-greater';

create function pg_catalog.has_tablespace_privilege(name, text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_tablespace_privilege
;

comment on function pg_catalog.has_tablespace_privilege(name, text, text)
is 'user privilege on tablespace by username, tablespace name';

create function pg_catalog.has_tablespace_privilege(name, oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_tablespace_privilege
;

comment on function pg_catalog.has_tablespace_privilege(name, oid, text)
is 'user privilege on tablespace by username, tablespace oid';

create function pg_catalog.has_tablespace_privilege(oid, text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_tablespace_privilege
;

comment on function pg_catalog.has_tablespace_privilege(oid, text, text)
is 'user privilege on tablespace by user oid, tablespace name';

create function pg_catalog.has_tablespace_privilege(oid, oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_tablespace_privilege
;

comment on function pg_catalog.has_tablespace_privilege(oid, oid, text)
is 'user privilege on tablespace by user oid, tablespace oid';

create function pg_catalog.has_tablespace_privilege(text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_tablespace_privilege
;

comment on function pg_catalog.has_tablespace_privilege(text, text)
is 'current user privilege on tablespace by tablespace name';

create function pg_catalog.has_tablespace_privilege(oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_tablespace_privilege
;

comment on function pg_catalog.has_tablespace_privilege(oid, text)
is 'current user privilege on tablespace by tablespace oid';

create function pg_catalog.shell_in(cstring)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.shell_in
;

comment on function pg_catalog.shell_in(cstring)
is 'I/O';

create function pg_catalog.shell_out(opaque)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.shell_out
;

comment on function pg_catalog.shell_out(opaque)
is 'I/O';

create function pg_catalog.array_recv(internal, oid, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_recv
;

comment on function pg_catalog.array_recv(internal, oid, integer)
is 'I/O';

create function pg_catalog.array_send(anyarray)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_send
;

comment on function pg_catalog.array_send(anyarray)
is 'I/O';

create function pg_catalog.record_recv(internal, oid, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.record_recv
;

comment on function pg_catalog.record_recv(internal, oid, integer)
is 'I/O';

create function pg_catalog.record_send(record)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.record_send
;

comment on function pg_catalog.record_send(record)
is 'I/O';

create function pg_catalog.int2recv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2recv
;

comment on function pg_catalog.int2recv(internal)
is 'I/O';

create function pg_catalog.int2send(smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2send
;

comment on function pg_catalog.int2send(smallint)
is 'I/O';

create function pg_catalog.int4recv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4recv
;

comment on function pg_catalog.int4recv(internal)
is 'I/O';

create function pg_catalog.int4send(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4send
;

comment on function pg_catalog.int4send(integer)
is 'I/O';

create function pg_catalog.int8recv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8recv
;

comment on function pg_catalog.int8recv(internal)
is 'I/O';

create function pg_catalog.int8send(bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8send
;

comment on function pg_catalog.int8send(bigint)
is 'I/O';

create function pg_catalog.int2vectorrecv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2vectorrecv
;

comment on function pg_catalog.int2vectorrecv(internal)
is 'I/O';

create function pg_catalog.int2vectorsend(int2vector)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2vectorsend
;

comment on function pg_catalog.int2vectorsend(int2vector)
is 'I/O';

create function pg_catalog.bytearecv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bytearecv
;

comment on function pg_catalog.bytearecv(internal)
is 'I/O';

create function pg_catalog.byteasend(bytea)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.byteasend
;

comment on function pg_catalog.byteasend(bytea)
is 'I/O';

create function pg_catalog.textrecv(internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.textrecv
;

comment on function pg_catalog.textrecv(internal)
is 'I/O';

create function pg_catalog.textsend(text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.textsend
;

comment on function pg_catalog.textsend(text)
is 'I/O';

create function pg_catalog.unknownrecv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.unknownrecv
;

comment on function pg_catalog.unknownrecv(internal)
is 'I/O';

create function pg_catalog.unknownsend(unknown)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.unknownsend
;

comment on function pg_catalog.unknownsend(unknown)
is 'I/O';

create function pg_catalog.oidrecv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.oidrecv
;

comment on function pg_catalog.oidrecv(internal)
is 'I/O';

create function pg_catalog.oidsend(oid)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.oidsend
;

comment on function pg_catalog.oidsend(oid)
is 'I/O';

create function pg_catalog.oidvectorrecv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.oidvectorrecv
;

comment on function pg_catalog.oidvectorrecv(internal)
is 'I/O';

create function pg_catalog.oidvectorsend(oidvector)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.oidvectorsend
;

comment on function pg_catalog.oidvectorsend(oidvector)
is 'I/O';

create function pg_catalog.namerecv(internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.namerecv
;

comment on function pg_catalog.namerecv(internal)
is 'I/O';

create function pg_catalog.namesend(name)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.namesend
;

comment on function pg_catalog.namesend(name)
is 'I/O';

create function pg_catalog.float4recv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float4recv
;

comment on function pg_catalog.float4recv(internal)
is 'I/O';

create function pg_catalog.float4send(real)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float4send
;

comment on function pg_catalog.float4send(real)
is 'I/O';

create function pg_catalog.float8recv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8recv
;

comment on function pg_catalog.float8recv(internal)
is 'I/O';

create function pg_catalog.float8send(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8send
;

comment on function pg_catalog.float8send(double precision)
is 'I/O';

create function pg_catalog.point_recv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.point_recv
;

comment on function pg_catalog.point_recv(internal)
is 'I/O';

create function pg_catalog.point_send(point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.point_send
;

comment on function pg_catalog.point_send(point)
is 'I/O';

create function pg_catalog.bpcharrecv(internal, oid, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpcharrecv
;

comment on function pg_catalog.bpcharrecv(internal, oid, integer)
is 'I/O';

create function pg_catalog.bpcharsend(char)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpcharsend
;

comment on function pg_catalog.bpcharsend(char)
is 'I/O';

create function pg_catalog.varcharrecv(internal, oid, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.varcharrecv
;

comment on function pg_catalog.varcharrecv(internal, oid, integer)
is 'I/O';

create function pg_catalog.varcharsend(varchar)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.varcharsend
;

comment on function pg_catalog.varcharsend(varchar)
is 'I/O';

create function pg_catalog.charrecv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.charrecv
;

comment on function pg_catalog.charrecv(internal)
is 'I/O';

create function pg_catalog.charsend("char")
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.charsend
;

comment on function pg_catalog.charsend("char")
is 'I/O';

create function pg_catalog.boolrecv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.boolrecv
;

comment on function pg_catalog.boolrecv(internal)
is 'I/O';

create function pg_catalog.boolsend(boolean)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.boolsend
;

comment on function pg_catalog.boolsend(boolean)
is 'I/O';

create function pg_catalog.tidrecv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tidrecv
;

comment on function pg_catalog.tidrecv(internal)
is 'I/O';

create function pg_catalog.tidsend(tid)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tidsend
;

comment on function pg_catalog.tidsend(tid)
is 'I/O';

create function pg_catalog.xidrecv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.xidrecv
;

comment on function pg_catalog.xidrecv(internal)
is 'I/O';

create function pg_catalog.xidsend(xid)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.xidsend
;

comment on function pg_catalog.xidsend(xid)
is 'I/O';

create function pg_catalog.cidrecv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cidrecv
;

comment on function pg_catalog.cidrecv(internal)
is 'I/O';

create function pg_catalog.cidsend(cid)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cidsend
;

comment on function pg_catalog.cidsend(cid)
is 'I/O';

create function pg_catalog.regprocrecv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regprocrecv
;

comment on function pg_catalog.regprocrecv(internal)
is 'I/O';

create function pg_catalog.regprocsend(regproc)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regprocsend
;

comment on function pg_catalog.regprocsend(regproc)
is 'I/O';

create function pg_catalog.regprocedurerecv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regprocedurerecv
;

comment on function pg_catalog.regprocedurerecv(internal)
is 'I/O';

create function pg_catalog.regproceduresend(regprocedure)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regproceduresend
;

comment on function pg_catalog.regproceduresend(regprocedure)
is 'I/O';

create function pg_catalog.regoperrecv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regoperrecv
;

comment on function pg_catalog.regoperrecv(internal)
is 'I/O';

create function pg_catalog.regopersend(regoper)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regopersend
;

comment on function pg_catalog.regopersend(regoper)
is 'I/O';

create function pg_catalog.regoperatorrecv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regoperatorrecv
;

comment on function pg_catalog.regoperatorrecv(internal)
is 'I/O';

create function pg_catalog.regoperatorsend(regoperator)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regoperatorsend
;

comment on function pg_catalog.regoperatorsend(regoperator)
is 'I/O';

create function pg_catalog.regclassrecv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regclassrecv
;

comment on function pg_catalog.regclassrecv(internal)
is 'I/O';

create function pg_catalog.regclasssend(regclass)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regclasssend
;

comment on function pg_catalog.regclasssend(regclass)
is 'I/O';

create function pg_catalog.regtyperecv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regtyperecv
;

comment on function pg_catalog.regtyperecv(internal)
is 'I/O';

create function pg_catalog.regtypesend(regtype)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regtypesend
;

comment on function pg_catalog.regtypesend(regtype)
is 'I/O';

create function pg_catalog.bit_recv(internal, oid, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bit_recv
;

comment on function pg_catalog.bit_recv(internal, oid, integer)
is 'I/O';

create function pg_catalog.bit_send(bit)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bit_send
;

comment on function pg_catalog.bit_send(bit)
is 'I/O';

create function pg_catalog.varbit_recv(internal, oid, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.varbit_recv
;

comment on function pg_catalog.varbit_recv(internal, oid, integer)
is 'I/O';

create function pg_catalog.varbit_send(bit varying)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.varbit_send
;

comment on function pg_catalog.varbit_send(bit varying)
is 'I/O';

create function pg_catalog.numeric_recv(internal, oid, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_recv
;

comment on function pg_catalog.numeric_recv(internal, oid, integer)
is 'I/O';

create function pg_catalog.numeric_send(numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_send
;

comment on function pg_catalog.numeric_send(numeric)
is 'I/O';

create function pg_catalog.abstimerecv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.abstimerecv
;

comment on function pg_catalog.abstimerecv(internal)
is 'I/O';

create function pg_catalog.abstimesend(abstime)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.abstimesend
;

comment on function pg_catalog.abstimesend(abstime)
is 'I/O';

create function pg_catalog.reltimerecv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.reltimerecv
;

comment on function pg_catalog.reltimerecv(internal)
is 'I/O';

create function pg_catalog.reltimesend(reltime)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.reltimesend
;

comment on function pg_catalog.reltimesend(reltime)
is 'I/O';

create function pg_catalog.tintervalrecv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tintervalrecv
;

comment on function pg_catalog.tintervalrecv(internal)
is 'I/O';

create function pg_catalog.tintervalsend(tinterval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tintervalsend
;

comment on function pg_catalog.tintervalsend(tinterval)
is 'I/O';

create function pg_catalog.date_recv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_recv
;

comment on function pg_catalog.date_recv(internal)
is 'I/O';

create function pg_catalog.date_send(date)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_send
;

comment on function pg_catalog.date_send(date)
is 'I/O';

create function pg_catalog.time_recv(internal, oid, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.time_recv
;

comment on function pg_catalog.time_recv(internal, oid, integer)
is 'I/O';

create function pg_catalog.time_send(time)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.time_send
;

comment on function pg_catalog.time_send(time)
is 'I/O';

create function pg_catalog.timetz_recv(internal, oid, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timetz_recv
;

comment on function pg_catalog.timetz_recv(internal, oid, integer)
is 'I/O';

create function pg_catalog.timetz_send(time with time zone)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timetz_send
;

comment on function pg_catalog.timetz_send(time with time zone)
is 'I/O';

create function pg_catalog.timestamp_recv(internal, oid, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_recv
;

comment on function pg_catalog.timestamp_recv(internal, oid, integer)
is 'I/O';

create function pg_catalog.timestamp_send(timestamp)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_send
;

comment on function pg_catalog.timestamp_send(timestamp)
is 'I/O';

create function pg_catalog.timestamptz_recv(internal, oid, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_recv
;

comment on function pg_catalog.timestamptz_recv(internal, oid, integer)
is 'I/O';

create function pg_catalog.timestamptz_send(timestamp with time zone)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_send
;

comment on function pg_catalog.timestamptz_send(timestamp with time zone)
is 'I/O';

create function pg_catalog.interval_recv(internal, oid, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.interval_recv
;

comment on function pg_catalog.interval_recv(internal, oid, integer)
is 'I/O';

create function pg_catalog.interval_send(interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.interval_send
;

comment on function pg_catalog.interval_send(interval)
is 'I/O';

create function pg_catalog.lseg_recv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lseg_recv
;

comment on function pg_catalog.lseg_recv(internal)
is 'I/O';

create function pg_catalog.lseg_send(lseg)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lseg_send
;

comment on function pg_catalog.lseg_send(lseg)
is 'I/O';

create function pg_catalog.path_recv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.path_recv
;

comment on function pg_catalog.path_recv(internal)
is 'I/O';

create function pg_catalog.path_send(path)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.path_send
;

comment on function pg_catalog.path_send(path)
is 'I/O';

create function pg_catalog.box_recv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_recv
;

comment on function pg_catalog.box_recv(internal)
is 'I/O';

create function pg_catalog.box_send(box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_send
;

comment on function pg_catalog.box_send(box)
is 'I/O';

create function pg_catalog.poly_recv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.poly_recv
;

comment on function pg_catalog.poly_recv(internal)
is 'I/O';

create function pg_catalog.poly_send(polygon)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.poly_send
;

comment on function pg_catalog.poly_send(polygon)
is 'I/O';

create function pg_catalog.line_recv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.line_recv
;

comment on function pg_catalog.line_recv(internal)
is 'I/O';

create function pg_catalog.line_send(line)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.line_send
;

comment on function pg_catalog.line_send(line)
is 'I/O';

create function pg_catalog.circle_recv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_recv
;

comment on function pg_catalog.circle_recv(internal)
is 'I/O';

create function pg_catalog.circle_send(circle)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_send
;

comment on function pg_catalog.circle_send(circle)
is 'I/O';

create function pg_catalog.cash_recv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cash_recv
;

comment on function pg_catalog.cash_recv(internal)
is 'I/O';

create function pg_catalog.cash_send(money)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cash_send
;

comment on function pg_catalog.cash_send(money)
is 'I/O';

create function pg_catalog.macaddr_recv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr_recv
;

comment on function pg_catalog.macaddr_recv(internal)
is 'I/O';

create function pg_catalog.macaddr_send(macaddr)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr_send
;

comment on function pg_catalog.macaddr_send(macaddr)
is 'I/O';

create function pg_catalog.inet_recv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inet_recv
;

comment on function pg_catalog.inet_recv(internal)
is 'I/O';

create function pg_catalog.inet_send(inet)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inet_send
;

comment on function pg_catalog.inet_send(inet)
is 'I/O';

create function pg_catalog.cidr_recv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cidr_recv
;

comment on function pg_catalog.cidr_recv(internal)
is 'I/O';

create function pg_catalog.cidr_send(cidr)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cidr_send
;

comment on function pg_catalog.cidr_send(cidr)
is 'I/O';

create function pg_catalog.cstring_recv(internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cstring_recv
;

comment on function pg_catalog.cstring_recv(internal)
is 'I/O';

create function pg_catalog.cstring_send(cstring)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cstring_send
;

comment on function pg_catalog.cstring_send(cstring)
is 'I/O';

create function pg_catalog.anyarray_recv(internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.anyarray_recv
;

comment on function pg_catalog.anyarray_recv(internal)
is 'I/O';

create function pg_catalog.anyarray_send(anyarray)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.anyarray_send
;

comment on function pg_catalog.anyarray_send(anyarray)
is 'I/O';

create function pg_catalog.pg_get_ruledef(oid, boolean)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_get_ruledef
;

comment on function pg_catalog.pg_get_ruledef(oid, boolean)
is 'source text of a rule with pretty-print option';

create function pg_catalog.pg_get_viewdef(text, boolean)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_get_viewdef
;

comment on function pg_catalog.pg_get_viewdef(text, boolean)
is 'select statement of a view with pretty-print option';

create function pg_catalog.pg_get_viewdef(oid, boolean)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_get_viewdef
;

comment on function pg_catalog.pg_get_viewdef(oid, boolean)
is 'select statement of a view with pretty-print option';

create function pg_catalog.pg_get_indexdef(oid, integer, boolean)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_get_indexdef
;

comment on function pg_catalog.pg_get_indexdef(oid, integer, boolean)
is 'index description (full create statement or single expression) with pretty-print option';

create function pg_catalog.pg_get_constraintdef(oid, boolean)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_get_constraintdef
;

comment on function pg_catalog.pg_get_constraintdef(oid, boolean)
is 'constraint description with pretty-print option';

create function pg_catalog.pg_get_expr(pg_node_tree, oid, boolean)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_get_expr
;

comment on function pg_catalog.pg_get_expr(pg_node_tree, oid, boolean)
is 'deparse an encoded expression with pretty-print option';

create function pg_catalog.pg_prepared_statement(out name            text, out statement text,
                                                 out prepare_time    timestamp with time zone,
                                                 out parameter_types regtype [], out from_sql boolean)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_prepared_statement
;

comment on function pg_catalog.pg_prepared_statement(out text, out text, out timestamp with time zone, out regtype [],
                                                     out boolean)
is 'get the prepared statements for this session';

create function pg_catalog.pg_cursor(out name          text, out statement text, out is_holdable boolean,
                                     out is_binary     boolean, out is_scrollable boolean,
                                     out creation_time timestamp with time zone)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_cursor
;

comment on function pg_catalog.pg_cursor(out text, out text, out boolean, out boolean, out boolean,
                                         out timestamp with time zone)
is 'get the open cursors for this session';

create function pg_catalog.float8_var_pop(double precision [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8_var_pop
;

comment on function pg_catalog.float8_var_pop(double precision [])
is 'aggregate final function';

create function pg_catalog.float8_stddev_pop(double precision [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8_stddev_pop
;

comment on function pg_catalog.float8_stddev_pop(double precision [])
is 'aggregate final function';

create function pg_catalog.numeric_var_pop(internal)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_var_pop
;

comment on function pg_catalog.numeric_var_pop(internal)
is 'aggregate final function';

create function pg_catalog.booland_statefunc(boolean, boolean)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.booland_statefunc
;

comment on function pg_catalog.booland_statefunc(boolean, boolean)
is 'aggregate transition function';

create function pg_catalog.boolor_statefunc(boolean, boolean)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.boolor_statefunc
;

comment on function pg_catalog.boolor_statefunc(boolean, boolean)
is 'aggregate transition function';

create function pg_catalog.timestamp_lt_timestamptz(timestamp, timestamp with time zone)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_lt_timestamptz
;

comment on function pg_catalog.timestamp_lt_timestamptz(timestamp, timestamp with time zone)
is 'implementation of < operator';

create function pg_catalog.timestamp_le_timestamptz(timestamp, timestamp with time zone)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_le_timestamptz
;

comment on function pg_catalog.timestamp_le_timestamptz(timestamp, timestamp with time zone)
is 'implementation of <= operator';

create function pg_catalog.timestamp_eq_timestamptz(timestamp, timestamp with time zone)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_eq_timestamptz
;

comment on function pg_catalog.timestamp_eq_timestamptz(timestamp, timestamp with time zone)
is 'implementation of = operator';

create function pg_catalog.timestamp_gt_timestamptz(timestamp, timestamp with time zone)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_gt_timestamptz
;

comment on function pg_catalog.timestamp_gt_timestamptz(timestamp, timestamp with time zone)
is 'implementation of > operator';

create function pg_catalog.timestamp_ge_timestamptz(timestamp, timestamp with time zone)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_ge_timestamptz
;

comment on function pg_catalog.timestamp_ge_timestamptz(timestamp, timestamp with time zone)
is 'implementation of >= operator';

create function pg_catalog.timestamp_ne_timestamptz(timestamp, timestamp with time zone)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_ne_timestamptz
;

comment on function pg_catalog.timestamp_ne_timestamptz(timestamp, timestamp with time zone)
is 'implementation of <> operator';

create function pg_catalog.timestamp_cmp_timestamptz(timestamp, timestamp with time zone)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_cmp_timestamptz
;

comment on function pg_catalog.timestamp_cmp_timestamptz(timestamp, timestamp with time zone)
is 'less-equal-greater';

create function pg_catalog.timestamptz_lt_timestamp(timestamp with time zone, timestamp)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_lt_timestamp
;

comment on function pg_catalog.timestamptz_lt_timestamp(timestamp with time zone, timestamp)
is 'implementation of < operator';

create function pg_catalog.timestamptz_le_timestamp(timestamp with time zone, timestamp)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_le_timestamp
;

comment on function pg_catalog.timestamptz_le_timestamp(timestamp with time zone, timestamp)
is 'implementation of <= operator';

create function pg_catalog.timestamptz_eq_timestamp(timestamp with time zone, timestamp)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_eq_timestamp
;

comment on function pg_catalog.timestamptz_eq_timestamp(timestamp with time zone, timestamp)
is 'implementation of = operator';

create function pg_catalog.timestamptz_gt_timestamp(timestamp with time zone, timestamp)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_gt_timestamp
;

comment on function pg_catalog.timestamptz_gt_timestamp(timestamp with time zone, timestamp)
is 'implementation of > operator';

create function pg_catalog.timestamptz_ge_timestamp(timestamp with time zone, timestamp)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_ge_timestamp
;

comment on function pg_catalog.timestamptz_ge_timestamp(timestamp with time zone, timestamp)
is 'implementation of >= operator';

create function pg_catalog.timestamptz_ne_timestamp(timestamp with time zone, timestamp)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_ne_timestamp
;

comment on function pg_catalog.timestamptz_ne_timestamp(timestamp with time zone, timestamp)
is 'implementation of <> operator';

create function pg_catalog.timestamptz_cmp_timestamp(timestamp with time zone, timestamp)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptz_cmp_timestamp
;

comment on function pg_catalog.timestamptz_cmp_timestamp(timestamp with time zone, timestamp)
is 'less-equal-greater';

create function pg_catalog.interval_pl_date(interval, date)
  returns timestamp without time zone
immutable
strict
parallel safe
cost 1
language sql
as $$
select $2 + $1
$$;

comment on function pg_catalog.interval_pl_date(interval, date)
is 'implementation of + operator';

create function pg_catalog.interval_pl_timetz(interval, time with time zone)
  returns time with time zone
immutable
strict
parallel safe
cost 1
language sql
as $$
select $2 + $1
$$;

comment on function pg_catalog.interval_pl_timetz(interval, time with time zone)
is 'implementation of + operator';

create function pg_catalog.interval_pl_timestamp(interval, timestamp without time zone)
  returns timestamp without time zone
immutable
strict
parallel safe
cost 1
language sql
as $$
select $2 + $1
$$;

comment on function pg_catalog.interval_pl_timestamp(interval, timestamp)
is 'implementation of + operator';

create function pg_catalog.interval_pl_timestamptz(interval, timestamp with time zone)
  returns timestamp with time zone
stable
strict
parallel safe
cost 1
language sql
as $$
select $2 + $1
$$;

comment on function pg_catalog.interval_pl_timestamptz(interval, timestamp with time zone)
is 'implementation of + operator';

create function pg_catalog.integer_pl_date(integer, date)
  returns date
immutable
strict
parallel safe
cost 1
language sql
as $$
select $2 + $1
$$;

comment on function pg_catalog.integer_pl_date(integer, date)
is 'implementation of + operator';

create function pg_catalog.pg_tablespace_databases(oid)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_tablespace_databases
;

comment on function pg_catalog.pg_tablespace_databases(oid)
is 'get OIDs of databases in a tablespace';

create function pg_catalog.bool(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bool
;

comment on function pg_catalog.bool(integer)
is 'convert int4 to boolean';

create function pg_catalog.int4(boolean)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4
;

comment on function pg_catalog.int4(boolean)
is 'convert boolean to int4';

create function pg_catalog.lastval()
strict
cost 1
language internal
as
-- missing source code for pg_catalog.lastval
;

comment on function pg_catalog.lastval()
is 'current value from last used sequence';

create function pg_catalog.pg_postmaster_start_time()
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_postmaster_start_time
;

comment on function pg_catalog.pg_postmaster_start_time()
is 'postmaster start time';

create function pg_catalog.pg_blocking_pids(integer)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_blocking_pids
;

comment on function pg_catalog.pg_blocking_pids(integer)
is 'get array of PIDs of sessions blocking specified backend PID from acquiring a heavyweight lock';

create function pg_catalog.box_below(box, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_below
;

comment on function pg_catalog.box_below(box, box)
is 'implementation of <<| operator';

create function pg_catalog.box_overbelow(box, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_overbelow
;

comment on function pg_catalog.box_overbelow(box, box)
is 'implementation of &<| operator';

create function pg_catalog.box_overabove(box, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_overabove
;

comment on function pg_catalog.box_overabove(box, box)
is 'implementation of |&> operator';

create function pg_catalog.box_above(box, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box_above
;

comment on function pg_catalog.box_above(box, box)
is 'implementation of |>> operator';

create function pg_catalog.poly_below(polygon, polygon)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.poly_below
;

comment on function pg_catalog.poly_below(polygon, polygon)
is 'implementation of <<| operator';

create function pg_catalog.poly_overbelow(polygon, polygon)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.poly_overbelow
;

comment on function pg_catalog.poly_overbelow(polygon, polygon)
is 'implementation of &<| operator';

create function pg_catalog.poly_overabove(polygon, polygon)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.poly_overabove
;

comment on function pg_catalog.poly_overabove(polygon, polygon)
is 'implementation of |&> operator';

create function pg_catalog.poly_above(polygon, polygon)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.poly_above
;

comment on function pg_catalog.poly_above(polygon, polygon)
is 'implementation of |>> operator';

create function pg_catalog.gist_box_consistent(internal, box, smallint, oid, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gist_box_consistent
;

comment on function pg_catalog.gist_box_consistent(internal, box, smallint, oid, internal)
is 'GiST support';

create function pg_catalog.float8(jsonb)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8
;

comment on function pg_catalog.float8(jsonb)
is 'convert jsonb to float8';

create function pg_catalog.gist_box_penalty(internal, internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gist_box_penalty
;

comment on function pg_catalog.gist_box_penalty(internal, internal, internal)
is 'GiST support';

create function pg_catalog.gist_box_picksplit(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gist_box_picksplit
;

comment on function pg_catalog.gist_box_picksplit(internal, internal)
is 'GiST support';

create function pg_catalog.gist_box_union(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gist_box_union
;

comment on function pg_catalog.gist_box_union(internal, internal)
is 'GiST support';

create function pg_catalog.gist_box_same(box, box, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gist_box_same
;

comment on function pg_catalog.gist_box_same(box, box, internal)
is 'GiST support';

create function pg_catalog.gist_poly_consistent(internal, polygon, smallint, oid, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gist_poly_consistent
;

comment on function pg_catalog.gist_poly_consistent(internal, polygon, smallint, oid, internal)
is 'GiST support';

create function pg_catalog.gist_poly_compress(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gist_poly_compress
;

comment on function pg_catalog.gist_poly_compress(internal)
is 'GiST support';

create function pg_catalog.circle_overbelow(circle, circle)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_overbelow
;

comment on function pg_catalog.circle_overbelow(circle, circle)
is 'implementation of &<| operator';

create function pg_catalog.circle_overabove(circle, circle)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.circle_overabove
;

comment on function pg_catalog.circle_overabove(circle, circle)
is 'implementation of |&> operator';

create function pg_catalog.gist_circle_consistent(internal, circle, smallint, oid, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gist_circle_consistent
;

comment on function pg_catalog.gist_circle_consistent(internal, circle, smallint, oid, internal)
is 'GiST support';

create function pg_catalog.gist_circle_compress(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gist_circle_compress
;

comment on function pg_catalog.gist_circle_compress(internal)
is 'GiST support';

create function pg_catalog.numeric_stddev_pop(internal)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_stddev_pop
;

comment on function pg_catalog.numeric_stddev_pop(internal)
is 'aggregate final function';

create function pg_catalog.domain_in(cstring, oid, integer)
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.domain_in
;

comment on function pg_catalog.domain_in(cstring, oid, integer)
is 'I/O';

create function pg_catalog.domain_recv(internal, oid, integer)
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.domain_recv
;

comment on function pg_catalog.domain_recv(internal, oid, integer)
is 'I/O';

create function pg_catalog.pg_timezone_abbrevs(out abbrev text, out utc_offset interval, out is_dst boolean)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_timezone_abbrevs
;

comment on function pg_catalog.pg_timezone_abbrevs(out text, out interval, out boolean)
is 'get the available time zone abbreviations';

create function pg_catalog.xmlexists(text, xml)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.xmlexists
;

comment on function pg_catalog.xmlexists(text, xml)
is 'test XML value against XPath expression';

create function pg_catalog.pg_reload_conf()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_reload_conf
;

comment on function pg_catalog.pg_reload_conf()
is 'reload configuration files';

create function pg_catalog.pg_rotate_logfile()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_rotate_logfile
;

comment on function pg_catalog.pg_rotate_logfile()
is 'rotate log file';

create function pg_catalog.pg_stat_file(filename text, out size bigint, out access timestamp with time zone,
                                                       out modification timestamp with time zone,
                                                       out change timestamp with time zone,
                                                       out creation timestamp with time zone, out isdir boolean)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_file
;

comment on function pg_catalog.pg_stat_file(text, out bigint, out timestamp with time zone,
                                                  out timestamp with time zone, out timestamp with time zone,
                                                  out timestamp with time zone, out boolean)
is 'get information about file';

create function pg_catalog.pg_read_file(text, bigint, bigint)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_read_file
;

comment on function pg_catalog.pg_read_file(text, bigint, bigint)
is 'read text from a file';

create function pg_catalog.pg_ls_dir(text)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_ls_dir
;

comment on function pg_catalog.pg_ls_dir(text)
is 'list all files in a directory';

create function pg_catalog.pg_sleep(double precision)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_sleep
;

comment on function pg_catalog.pg_sleep(double precision)
is 'sleep for the specified time in seconds';

create function pg_catalog.inetnot(inet)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inetnot
;

comment on function pg_catalog.inetnot(inet)
is 'implementation of ~ operator';

create function pg_catalog.inetand(inet, inet)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inetand
;

comment on function pg_catalog.inetand(inet, inet)
is 'implementation of & operator';

create function pg_catalog.inetor(inet, inet)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inetor
;

comment on function pg_catalog.inetor(inet, inet)
is 'implementation of | operator';

create function pg_catalog.inetpl(inet, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inetpl
;

comment on function pg_catalog.inetpl(inet, bigint)
is 'implementation of + operator';

create function pg_catalog.int8pl_inet(bigint, inet)
  returns inet
immutable
strict
parallel safe
cost 1
language sql
as $$
select $2 + $1
$$;

comment on function pg_catalog.int8pl_inet(bigint, inet)
is 'implementation of + operator';

create function pg_catalog.inetmi_int8(inet, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inetmi_int8
;

comment on function pg_catalog.inetmi_int8(inet, bigint)
is 'implementation of - operator';

create function pg_catalog.inetmi(inet, inet)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inetmi
;

comment on function pg_catalog.inetmi(inet, inet)
is 'implementation of - operator';

create function pg_catalog.transaction_timestamp()
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.transaction_timestamp
;

comment on function pg_catalog.transaction_timestamp()
is 'current transaction time';

create function pg_catalog.statement_timestamp()
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.statement_timestamp
;

comment on function pg_catalog.statement_timestamp()
is 'current statement time';

create function pg_catalog.clock_timestamp()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.clock_timestamp
;

comment on function pg_catalog.clock_timestamp()
is 'current clock time';

create function pg_catalog.gin_cmp_prefix(text, text, smallint, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gin_cmp_prefix
;

comment on function pg_catalog.gin_cmp_prefix(text, text, smallint, internal)
is 'GIN tsvector support';

create function pg_catalog.pg_has_role(name, name, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_has_role
;

comment on function pg_catalog.pg_has_role(name, name, text)
is 'user privilege on role by username, role name';

create function pg_catalog.pg_has_role(name, oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_has_role
;

comment on function pg_catalog.pg_has_role(name, oid, text)
is 'user privilege on role by username, role oid';

create function pg_catalog.pg_has_role(oid, name, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_has_role
;

comment on function pg_catalog.pg_has_role(oid, name, text)
is 'user privilege on role by user oid, role name';

create function pg_catalog.pg_has_role(oid, oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_has_role
;

comment on function pg_catalog.pg_has_role(oid, oid, text)
is 'user privilege on role by user oid, role oid';

create function pg_catalog.pg_has_role(name, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_has_role
;

comment on function pg_catalog.pg_has_role(name, text)
is 'current user privilege on role by role name';

create function pg_catalog.pg_has_role(oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_has_role
;

comment on function pg_catalog.pg_has_role(oid, text)
is 'current user privilege on role by role oid';

create function pg_catalog.justify_interval(interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.justify_interval
;

comment on function pg_catalog.justify_interval(interval)
is 'promote groups of 24 hours to numbers of days and promote groups of 30 days to numbers of months';

create function pg_catalog.pg_get_triggerdef(oid, boolean)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_get_triggerdef
;

comment on function pg_catalog.pg_get_triggerdef(oid, boolean)
is 'trigger description with pretty-print option';

create function pg_catalog.asind(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.asind
;

comment on function pg_catalog.asind(double precision)
is 'arcsine, degrees';

create function pg_catalog.acosd(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.acosd
;

comment on function pg_catalog.acosd(double precision)
is 'arccosine, degrees';

create function pg_catalog.atand(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.atand
;

comment on function pg_catalog.atand(double precision)
is 'arctangent, degrees';

create function pg_catalog.atan2d(double precision, double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.atan2d
;

comment on function pg_catalog.atan2d(double precision, double precision)
is 'arctangent, two arguments, degrees';

create function pg_catalog.sind(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.sind
;

comment on function pg_catalog.sind(double precision)
is 'sine, degrees';

create function pg_catalog.cosd(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cosd
;

comment on function pg_catalog.cosd(double precision)
is 'cosine, degrees';

create function pg_catalog.tand(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tand
;

comment on function pg_catalog.tand(double precision)
is 'tangent, degrees';

create function pg_catalog.cotd(double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cotd
;

comment on function pg_catalog.cotd(double precision)
is 'cotangent, degrees';

create function pg_catalog.pg_stop_backup(exclusive boolean, wait_for_archive boolean default true, out lsn pg_lsn,
                                                                                                    out labelfile text,
                                                                                                    out spcmapfile text)
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stop_backup
;

comment on function pg_catalog.pg_stop_backup(boolean, boolean, out pg_lsn, out text, out text)
is 'finish taking an online backup';

create function pg_catalog.numeric_avg_serialize(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_avg_serialize
;

comment on function pg_catalog.numeric_avg_serialize(internal)
is 'aggregate serial function';

create function pg_catalog.numeric_avg_deserialize(bytea, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_avg_deserialize
;

comment on function pg_catalog.numeric_avg_deserialize(bytea, internal)
is 'aggregate deserial function';

create function pg_catalog.ginarrayextract(anyarray, internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ginarrayextract
;

comment on function pg_catalog.ginarrayextract(anyarray, internal, internal)
is 'GIN array support';

create function pg_catalog.ginarrayconsistent(internal, smallint, anyarray, integer, internal, internal, internal,
                                              internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ginarrayconsistent
;

comment on function pg_catalog.ginarrayconsistent(internal, smallint, anyarray, integer, internal, internal, internal,
                                                  internal)
is 'GIN array support';

create function pg_catalog.int8_avg_accum(internal, bigint)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8_avg_accum
;

comment on function pg_catalog.int8_avg_accum(internal, bigint)
is 'aggregate transition function';

create function pg_catalog.arrayoverlap(anyarray, anyarray)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.arrayoverlap
;

comment on function pg_catalog.arrayoverlap(anyarray, anyarray)
is 'implementation of && operator';

create function pg_catalog.arraycontains(anyarray, anyarray)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.arraycontains
;

comment on function pg_catalog.arraycontains(anyarray, anyarray)
is 'implementation of @> operator';

create function pg_catalog.arraycontained(anyarray, anyarray)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.arraycontained
;

comment on function pg_catalog.arraycontained(anyarray, anyarray)
is 'implementation of <@ operator';

create function pg_catalog.pg_stat_get_db_tuples_returned(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_db_tuples_returned
;

comment on function pg_catalog.pg_stat_get_db_tuples_returned(oid)
is 'statistics: tuples returned for database';

create function pg_catalog.pg_stat_get_db_tuples_fetched(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_db_tuples_fetched
;

comment on function pg_catalog.pg_stat_get_db_tuples_fetched(oid)
is 'statistics: tuples fetched for database';

create function pg_catalog.pg_stat_get_db_tuples_inserted(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_db_tuples_inserted
;

comment on function pg_catalog.pg_stat_get_db_tuples_inserted(oid)
is 'statistics: tuples inserted in database';

create function pg_catalog.pg_stat_get_db_tuples_updated(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_db_tuples_updated
;

comment on function pg_catalog.pg_stat_get_db_tuples_updated(oid)
is 'statistics: tuples updated in database';

create function pg_catalog.pg_stat_get_db_tuples_deleted(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_db_tuples_deleted
;

comment on function pg_catalog.pg_stat_get_db_tuples_deleted(oid)
is 'statistics: tuples deleted in database';

create function pg_catalog.regexp_matches(text, text)
immutable
strict
parallel safe
cost 1
rows 1
language internal
as
-- missing source code for pg_catalog.regexp_matches
;

comment on function pg_catalog.regexp_matches(text, text)
is 'find match(es) for regexp';

create function pg_catalog.regexp_matches(text, text, text)
immutable
strict
parallel safe
cost 1
rows 10
language internal
as
-- missing source code for pg_catalog.regexp_matches
;

comment on function pg_catalog.regexp_matches(text, text, text)
is 'find match(es) for regexp';

create function pg_catalog.regexp_split_to_table(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regexp_split_to_table
;

comment on function pg_catalog.regexp_split_to_table(text, text)
is 'split string by pattern';

create function pg_catalog.regexp_split_to_table(text, text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regexp_split_to_table
;

comment on function pg_catalog.regexp_split_to_table(text, text, text)
is 'split string by pattern';

create function pg_catalog.regexp_split_to_array(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regexp_split_to_array
;

comment on function pg_catalog.regexp_split_to_array(text, text)
is 'split string by pattern';

create function pg_catalog.regexp_split_to_array(text, text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regexp_split_to_array
;

comment on function pg_catalog.regexp_split_to_array(text, text, text)
is 'split string by pattern';

create function pg_catalog.pg_stat_get_bgwriter_timed_checkpoints()
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_bgwriter_timed_checkpoints
;

comment on function pg_catalog.pg_stat_get_bgwriter_timed_checkpoints()
is 'statistics: number of timed checkpoints started by the bgwriter';

create function pg_catalog.pg_stat_get_bgwriter_requested_checkpoints()
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_bgwriter_requested_checkpoints
;

comment on function pg_catalog.pg_stat_get_bgwriter_requested_checkpoints()
is 'statistics: number of backend requested checkpoints started by the bgwriter';

create function pg_catalog.pg_stat_get_bgwriter_buf_written_checkpoints()
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_bgwriter_buf_written_checkpoints
;

comment on function pg_catalog.pg_stat_get_bgwriter_buf_written_checkpoints()
is 'statistics: number of buffers written by the bgwriter during checkpoints';

create function pg_catalog.pg_stat_get_bgwriter_buf_written_clean()
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_bgwriter_buf_written_clean
;

comment on function pg_catalog.pg_stat_get_bgwriter_buf_written_clean()
is 'statistics: number of buffers written by the bgwriter for cleaning dirty buffers';

create function pg_catalog.pg_stat_get_bgwriter_maxwritten_clean()
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_bgwriter_maxwritten_clean
;

comment on function pg_catalog.pg_stat_get_bgwriter_maxwritten_clean()
is 'statistics: number of times the bgwriter stopped processing when it had written too many buffers while cleaning';

create function pg_catalog.ginqueryarrayextract(anyarray, internal, smallint, internal, internal, internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ginqueryarrayextract
;

comment on function pg_catalog.ginqueryarrayextract(anyarray, internal, smallint, internal, internal, internal,
                                                    internal)
is 'GIN array support';

create function pg_catalog.pg_stat_get_buf_written_backend()
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_buf_written_backend
;

comment on function pg_catalog.pg_stat_get_buf_written_backend()
is 'statistics: number of buffers written by backends';

create function pg_catalog.anynonarray_in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.anynonarray_in
;

comment on function pg_catalog.anynonarray_in(cstring)
is 'I/O';

create function pg_catalog.anynonarray_out(anynonarray)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.anynonarray_out
;

comment on function pg_catalog.anynonarray_out(anynonarray)
is 'I/O';

create function pg_catalog.pg_stat_get_last_vacuum_time(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_last_vacuum_time
;

comment on function pg_catalog.pg_stat_get_last_vacuum_time(oid)
is 'statistics: last manual vacuum time for a table';

create function pg_catalog.pg_stat_get_last_autovacuum_time(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_last_autovacuum_time
;

comment on function pg_catalog.pg_stat_get_last_autovacuum_time(oid)
is 'statistics: last auto vacuum time for a table';

create function pg_catalog.pg_stat_get_last_analyze_time(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_last_analyze_time
;

comment on function pg_catalog.pg_stat_get_last_analyze_time(oid)
is 'statistics: last manual analyze time for a table';

create function pg_catalog.pg_stat_get_last_autoanalyze_time(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_last_autoanalyze_time
;

comment on function pg_catalog.pg_stat_get_last_autoanalyze_time(oid)
is 'statistics: last auto analyze time for a table';

create function pg_catalog.int8_avg_combine(internal, internal)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8_avg_combine
;

comment on function pg_catalog.int8_avg_combine(internal, internal)
is 'aggregate combine function';

create function pg_catalog.int8_avg_serialize(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8_avg_serialize
;

comment on function pg_catalog.int8_avg_serialize(internal)
is 'aggregate serial function';

create function pg_catalog.int8_avg_deserialize(bytea, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8_avg_deserialize
;

comment on function pg_catalog.int8_avg_deserialize(bytea, internal)
is 'aggregate deserial function';

create function pg_catalog.pg_stat_get_backend_wait_event_type(integer)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_backend_wait_event_type
;

comment on function pg_catalog.pg_stat_get_backend_wait_event_type(integer)
is 'statistics: wait event type on which backend is currently waiting';

create function pg_catalog.tidgt(tid, tid)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tidgt
;

comment on function pg_catalog.tidgt(tid, tid)
is 'implementation of > operator';

create function pg_catalog.tidlt(tid, tid)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tidlt
;

comment on function pg_catalog.tidlt(tid, tid)
is 'implementation of < operator';

create function pg_catalog.tidge(tid, tid)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tidge
;

comment on function pg_catalog.tidge(tid, tid)
is 'implementation of >= operator';

create function pg_catalog.tidle(tid, tid)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tidle
;

comment on function pg_catalog.tidle(tid, tid)
is 'implementation of <= operator';

create function pg_catalog.bttidcmp(tid, tid)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bttidcmp
;

comment on function pg_catalog.bttidcmp(tid, tid)
is 'less-equal-greater';

create function pg_catalog.tidlarger(tid, tid)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tidlarger
;

comment on function pg_catalog.tidlarger(tid, tid)
is 'larger of two';

create function pg_catalog.tidsmaller(tid, tid)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tidsmaller
;

comment on function pg_catalog.tidsmaller(tid, tid)
is 'smaller of two';

create function pg_catalog.int8inc_any(bigint, "any")
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8inc_any
;

comment on function pg_catalog.int8inc_any(bigint, "any")
is 'increment, ignores second argument';

create function pg_catalog.int8inc_float8_float8(bigint, double precision, double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8inc_float8_float8
;

comment on function pg_catalog.int8inc_float8_float8(bigint, double precision, double precision)
is 'aggregate transition function';

create function pg_catalog.float8_regr_accum(double precision [], double precision, double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8_regr_accum
;

comment on function pg_catalog.float8_regr_accum(double precision [], double precision, double precision)
is 'aggregate transition function';

create function pg_catalog.float8_regr_sxx(double precision [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8_regr_sxx
;

comment on function pg_catalog.float8_regr_sxx(double precision [])
is 'aggregate final function';

create function pg_catalog.float8_regr_syy(double precision [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8_regr_syy
;

comment on function pg_catalog.float8_regr_syy(double precision [])
is 'aggregate final function';

create function pg_catalog.float8_regr_sxy(double precision [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8_regr_sxy
;

comment on function pg_catalog.float8_regr_sxy(double precision [])
is 'aggregate final function';

create function pg_catalog.float8_regr_avgx(double precision [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8_regr_avgx
;

comment on function pg_catalog.float8_regr_avgx(double precision [])
is 'aggregate final function';

create function pg_catalog.float8_regr_avgy(double precision [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8_regr_avgy
;

comment on function pg_catalog.float8_regr_avgy(double precision [])
is 'aggregate final function';

create function pg_catalog.float8_regr_r2(double precision [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8_regr_r2
;

comment on function pg_catalog.float8_regr_r2(double precision [])
is 'aggregate final function';

create function pg_catalog.float8_regr_slope(double precision [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8_regr_slope
;

comment on function pg_catalog.float8_regr_slope(double precision [])
is 'aggregate final function';

create function pg_catalog.float8_regr_intercept(double precision [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8_regr_intercept
;

comment on function pg_catalog.float8_regr_intercept(double precision [])
is 'aggregate final function';

create function pg_catalog.float8_covar_pop(double precision [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8_covar_pop
;

comment on function pg_catalog.float8_covar_pop(double precision [])
is 'aggregate final function';

create function pg_catalog.float8_covar_samp(double precision [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8_covar_samp
;

comment on function pg_catalog.float8_covar_samp(double precision [])
is 'aggregate final function';

create function pg_catalog.float8_corr(double precision [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8_corr
;

comment on function pg_catalog.float8_corr(double precision [])
is 'aggregate final function';

create function pg_catalog.pg_stat_get_db_blk_read_time(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_db_blk_read_time
;

comment on function pg_catalog.pg_stat_get_db_blk_read_time(oid)
is 'statistics: block read time, in milliseconds';

create function pg_catalog.pg_stat_get_db_blk_write_time(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_db_blk_write_time
;

comment on function pg_catalog.pg_stat_get_db_blk_write_time(oid)
is 'statistics: block write time, in milliseconds';

create function pg_catalog.pg_switch_wal()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_switch_wal
;

comment on function pg_catalog.pg_switch_wal()
is 'switch to new wal file';

create function pg_catalog.pg_current_wal_lsn()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_current_wal_lsn
;

comment on function pg_catalog.pg_current_wal_lsn()
is 'current wal write location';

create function pg_catalog.pg_walfile_name_offset(lsn pg_lsn, out file_name text, out file_offset integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_walfile_name_offset
;

comment on function pg_catalog.pg_walfile_name_offset(pg_lsn, out text, out integer)
is 'wal filename and byte offset, given a wal location';

create function pg_catalog.pg_walfile_name(pg_lsn)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_walfile_name
;

comment on function pg_catalog.pg_walfile_name(pg_lsn)
is 'wal filename, given a wal location';

create function pg_catalog.pg_current_wal_insert_lsn()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_current_wal_insert_lsn
;

comment on function pg_catalog.pg_current_wal_insert_lsn()
is 'current wal insert location';

create function pg_catalog.pg_stat_get_backend_wait_event(integer)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_backend_wait_event
;

comment on function pg_catalog.pg_stat_get_backend_wait_event(integer)
is 'statistics: wait event on which backend is currently waiting';

create function pg_catalog.pg_my_temp_schema()
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_my_temp_schema
;

comment on function pg_catalog.pg_my_temp_schema()
is 'get OID of current session''s temp schema, if any';

create function pg_catalog.pg_is_other_temp_schema(oid)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_is_other_temp_schema
;

comment on function pg_catalog.pg_is_other_temp_schema(oid)
is 'is schema another session''s temp schema?';

create function pg_catalog.pg_timezone_names(out name   text, out abbrev text, out utc_offset interval,
                                             out is_dst boolean)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_timezone_names
;

comment on function pg_catalog.pg_timezone_names(out text, out text, out interval, out boolean)
is 'get the available time zone names';

create function pg_catalog.pg_stat_get_backend_xact_start(integer)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_backend_xact_start
;

comment on function pg_catalog.pg_stat_get_backend_xact_start(integer)
is 'statistics: start time for backend''s current transaction';

create function pg_catalog.numeric_avg_accum(internal, numeric)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_avg_accum
;

comment on function pg_catalog.numeric_avg_accum(internal, numeric)
is 'aggregate transition function';

create function pg_catalog.pg_stat_get_buf_alloc()
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_buf_alloc
;

comment on function pg_catalog.pg_stat_get_buf_alloc()
is 'statistics: number of buffer allocations';

create function pg_catalog.pg_stat_get_live_tuples(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_live_tuples
;

comment on function pg_catalog.pg_stat_get_live_tuples(oid)
is 'statistics: number of live tuples';

create function pg_catalog.pg_stat_get_dead_tuples(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_dead_tuples
;

comment on function pg_catalog.pg_stat_get_dead_tuples(oid)
is 'statistics: number of dead tuples';

create function pg_catalog.pg_advisory_lock(bigint)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_advisory_lock
;

comment on function pg_catalog.pg_advisory_lock(bigint)
is 'obtain exclusive advisory lock';

create function pg_catalog.pg_advisory_lock_shared(bigint)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_advisory_lock_shared
;

comment on function pg_catalog.pg_advisory_lock_shared(bigint)
is 'obtain shared advisory lock';

create function pg_catalog.pg_try_advisory_lock(bigint)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_try_advisory_lock
;

comment on function pg_catalog.pg_try_advisory_lock(bigint)
is 'obtain exclusive advisory lock if available';

create function pg_catalog.pg_try_advisory_lock_shared(bigint)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_try_advisory_lock_shared
;

comment on function pg_catalog.pg_try_advisory_lock_shared(bigint)
is 'obtain shared advisory lock if available';

create function pg_catalog.pg_advisory_unlock(bigint)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_advisory_unlock
;

comment on function pg_catalog.pg_advisory_unlock(bigint)
is 'release exclusive advisory lock';

create function pg_catalog.pg_advisory_unlock_shared(bigint)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_advisory_unlock_shared
;

comment on function pg_catalog.pg_advisory_unlock_shared(bigint)
is 'release shared advisory lock';

create function pg_catalog.pg_advisory_lock(integer, integer)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_advisory_lock
;

comment on function pg_catalog.pg_advisory_lock(integer, integer)
is 'obtain exclusive advisory lock';

create function pg_catalog.pg_advisory_lock_shared(integer, integer)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_advisory_lock_shared
;

comment on function pg_catalog.pg_advisory_lock_shared(integer, integer)
is 'obtain shared advisory lock';

create function pg_catalog.pg_try_advisory_lock(integer, integer)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_try_advisory_lock
;

comment on function pg_catalog.pg_try_advisory_lock(integer, integer)
is 'obtain exclusive advisory lock if available';

create function pg_catalog.pg_try_advisory_lock_shared(integer, integer)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_try_advisory_lock_shared
;

comment on function pg_catalog.pg_try_advisory_lock_shared(integer, integer)
is 'obtain shared advisory lock if available';

create function pg_catalog.pg_advisory_unlock(integer, integer)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_advisory_unlock
;

comment on function pg_catalog.pg_advisory_unlock(integer, integer)
is 'release exclusive advisory lock';

create function pg_catalog.pg_advisory_unlock_shared(integer, integer)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_advisory_unlock_shared
;

comment on function pg_catalog.pg_advisory_unlock_shared(integer, integer)
is 'release shared advisory lock';

create function pg_catalog.pg_advisory_unlock_all()
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_advisory_unlock_all
;

comment on function pg_catalog.pg_advisory_unlock_all()
is 'release all advisory locks';

create function pg_catalog.xml_in(cstring)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.xml_in
;

comment on function pg_catalog.xml_in(cstring)
is 'I/O';

create function pg_catalog.xml_out(xml)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.xml_out
;

comment on function pg_catalog.xml_out(xml)
is 'I/O';

create function pg_catalog.xmlcomment(text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.xmlcomment
;

comment on function pg_catalog.xmlcomment(text)
is 'generate XML comment';

create function pg_catalog.xml(text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.xml
;

comment on function pg_catalog.xml(text)
is 'perform a non-validating parse of a character string to produce an XML value';

create function pg_catalog.xmlvalidate(xml, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.xmlvalidate
;

comment on function pg_catalog.xmlvalidate(xml, text)
is 'validate an XML value';

create function pg_catalog.xml_recv(internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.xml_recv
;

comment on function pg_catalog.xml_recv(internal)
is 'I/O';

create function pg_catalog.xml_send(xml)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.xml_send
;

comment on function pg_catalog.xml_send(xml)
is 'I/O';

create function pg_catalog.xmlconcat2(xml, xml)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.xmlconcat2
;

comment on function pg_catalog.xmlconcat2(xml, xml)
is 'aggregate transition function';

create function pg_catalog.varbittypmodin(cstring [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.varbittypmodin
;

comment on function pg_catalog.varbittypmodin(cstring [])
is 'I/O typmod';

create function pg_catalog.intervaltypmodin(cstring [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.intervaltypmodin
;

comment on function pg_catalog.intervaltypmodin(cstring [])
is 'I/O typmod';

create function pg_catalog.intervaltypmodout(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.intervaltypmodout
;

comment on function pg_catalog.intervaltypmodout(integer)
is 'I/O typmod';

create function pg_catalog.timestamptypmodin(cstring [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptypmodin
;

comment on function pg_catalog.timestamptypmodin(cstring [])
is 'I/O typmod';

create function pg_catalog.timestamptypmodout(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptypmodout
;

comment on function pg_catalog.timestamptypmodout(integer)
is 'I/O typmod';

create function pg_catalog.timestamptztypmodin(cstring [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptztypmodin
;

comment on function pg_catalog.timestamptztypmodin(cstring [])
is 'I/O typmod';

create function pg_catalog.timestamptztypmodout(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamptztypmodout
;

comment on function pg_catalog.timestamptztypmodout(integer)
is 'I/O typmod';

create function pg_catalog.timetypmodin(cstring [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timetypmodin
;

comment on function pg_catalog.timetypmodin(cstring [])
is 'I/O typmod';

create function pg_catalog.timetypmodout(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timetypmodout
;

comment on function pg_catalog.timetypmodout(integer)
is 'I/O typmod';

create function pg_catalog.timetztypmodin(cstring [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timetztypmodin
;

comment on function pg_catalog.timetztypmodin(cstring [])
is 'I/O typmod';

create function pg_catalog.timetztypmodout(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timetztypmodout
;

comment on function pg_catalog.timetztypmodout(integer)
is 'I/O typmod';

create function pg_catalog.bpchartypmodin(cstring [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpchartypmodin
;

comment on function pg_catalog.bpchartypmodin(cstring [])
is 'I/O typmod';

create function pg_catalog.bpchartypmodout(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpchartypmodout
;

comment on function pg_catalog.bpchartypmodout(integer)
is 'I/O typmod';

create function pg_catalog.varchartypmodin(cstring [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.varchartypmodin
;

comment on function pg_catalog.varchartypmodin(cstring [])
is 'I/O typmod';

create function pg_catalog.varchartypmodout(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.varchartypmodout
;

comment on function pg_catalog.varchartypmodout(integer)
is 'I/O typmod';

create function pg_catalog.numerictypmodin(cstring [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numerictypmodin
;

comment on function pg_catalog.numerictypmodin(cstring [])
is 'I/O typmod';

create function pg_catalog.numerictypmodout(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numerictypmodout
;

comment on function pg_catalog.numerictypmodout(integer)
is 'I/O typmod';

create function pg_catalog.bittypmodin(cstring [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bittypmodin
;

comment on function pg_catalog.bittypmodin(cstring [])
is 'I/O typmod';

create function pg_catalog.bittypmodout(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bittypmodout
;

comment on function pg_catalog.bittypmodout(integer)
is 'I/O typmod';

create function pg_catalog.varbittypmodout(integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.varbittypmodout
;

comment on function pg_catalog.varbittypmodout(integer)
is 'I/O typmod';

create function pg_catalog.text(xml)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.text
;

comment on function pg_catalog.text(xml)
is 'serialize an XML value to a character string';

create function pg_catalog.table_to_xml(tbl regclass, nulls boolean, tableforest boolean, targetns text)
stable
strict
parallel restricted
language internal
as
-- missing source code for pg_catalog.table_to_xml
;

comment on function pg_catalog.table_to_xml(regclass, boolean, boolean, text)
is 'map table contents to XML';

create function pg_catalog.query_to_xml(query text, nulls boolean, tableforest boolean, targetns text)
strict
language internal
as
-- missing source code for pg_catalog.query_to_xml
;

comment on function pg_catalog.query_to_xml(text, boolean, boolean, text)
is 'map query result to XML';

create function pg_catalog.cursor_to_xml(cursor   refcursor, count integer, nulls boolean, tableforest boolean,
                                         targetns text)
strict
language internal
as
-- missing source code for pg_catalog.cursor_to_xml
;

comment on function pg_catalog.cursor_to_xml(refcursor, integer, boolean, boolean, text)
is 'map rows from cursor to XML';

create function pg_catalog.table_to_xmlschema(tbl regclass, nulls boolean, tableforest boolean, targetns text)
stable
strict
parallel restricted
language internal
as
-- missing source code for pg_catalog.table_to_xmlschema
;

comment on function pg_catalog.table_to_xmlschema(regclass, boolean, boolean, text)
is 'map table structure to XML Schema';

create function pg_catalog.query_to_xmlschema(query text, nulls boolean, tableforest boolean, targetns text)
strict
language internal
as
-- missing source code for pg_catalog.query_to_xmlschema
;

comment on function pg_catalog.query_to_xmlschema(text, boolean, boolean, text)
is 'map query result structure to XML Schema';

create function pg_catalog.cursor_to_xmlschema(cursor refcursor, nulls boolean, tableforest boolean, targetns text)
strict
language internal
as
-- missing source code for pg_catalog.cursor_to_xmlschema
;

comment on function pg_catalog.cursor_to_xmlschema(refcursor, boolean, boolean, text)
is 'map cursor structure to XML Schema';

create function pg_catalog.table_to_xml_and_xmlschema(tbl regclass, nulls boolean, tableforest boolean, targetns text)
stable
strict
parallel restricted
language internal
as
-- missing source code for pg_catalog.table_to_xml_and_xmlschema
;

comment on function pg_catalog.table_to_xml_and_xmlschema(regclass, boolean, boolean, text)
is 'map table contents and structure to XML and XML Schema';

create function pg_catalog.query_to_xml_and_xmlschema(query text, nulls boolean, tableforest boolean, targetns text)
strict
language internal
as
-- missing source code for pg_catalog.query_to_xml_and_xmlschema
;

comment on function pg_catalog.query_to_xml_and_xmlschema(text, boolean, boolean, text)
is 'map query result and structure to XML and XML Schema';

create function pg_catalog.xpath(text, xml, text [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.xpath
;

comment on function pg_catalog.xpath(text, xml, text [])
is 'evaluate XPath expression, with namespaces support';

create function pg_catalog.xpath(text, xml)
  returns xml []
immutable
strict
parallel safe
cost 1
language sql
as $$
select pg_catalog.xpath($1, $2, '{}' :: pg_catalog.text [])
$$;

comment on function pg_catalog.xpath(text, xml)
is 'evaluate XPath expression';

create function pg_catalog.schema_to_xml(schema name, nulls boolean, tableforest boolean, targetns text)
stable
strict
parallel restricted
language internal
as
-- missing source code for pg_catalog.schema_to_xml
;

comment on function pg_catalog.schema_to_xml(name, boolean, boolean, text)
is 'map schema contents to XML';

create function pg_catalog.schema_to_xmlschema(schema name, nulls boolean, tableforest boolean, targetns text)
stable
strict
parallel restricted
language internal
as
-- missing source code for pg_catalog.schema_to_xmlschema
;

comment on function pg_catalog.schema_to_xmlschema(name, boolean, boolean, text)
is 'map schema structure to XML Schema';

create function pg_catalog.schema_to_xml_and_xmlschema(schema name, nulls boolean, tableforest boolean, targetns text)
stable
strict
parallel restricted
language internal
as
-- missing source code for pg_catalog.schema_to_xml_and_xmlschema
;

comment on function pg_catalog.schema_to_xml_and_xmlschema(name, boolean, boolean, text)
is 'map schema contents and structure to XML and XML Schema';

create function pg_catalog.database_to_xml(nulls boolean, tableforest boolean, targetns text)
stable
strict
parallel restricted
language internal
as
-- missing source code for pg_catalog.database_to_xml
;

comment on function pg_catalog.database_to_xml(boolean, boolean, text)
is 'map database contents to XML';

create function pg_catalog.database_to_xmlschema(nulls boolean, tableforest boolean, targetns text)
stable
strict
parallel restricted
language internal
as
-- missing source code for pg_catalog.database_to_xmlschema
;

comment on function pg_catalog.database_to_xmlschema(boolean, boolean, text)
is 'map database structure to XML Schema';

create function pg_catalog.database_to_xml_and_xmlschema(nulls boolean, tableforest boolean, targetns text)
stable
strict
parallel restricted
language internal
as
-- missing source code for pg_catalog.database_to_xml_and_xmlschema
;

comment on function pg_catalog.database_to_xml_and_xmlschema(boolean, boolean, text)
is 'map database contents and structure to XML and XML Schema';

create function pg_catalog.txid_snapshot_in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.txid_snapshot_in
;

comment on function pg_catalog.txid_snapshot_in(cstring)
is 'I/O';

create function pg_catalog.txid_snapshot_out(txid_snapshot)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.txid_snapshot_out
;

comment on function pg_catalog.txid_snapshot_out(txid_snapshot)
is 'I/O';

create function pg_catalog.txid_snapshot_recv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.txid_snapshot_recv
;

comment on function pg_catalog.txid_snapshot_recv(internal)
is 'I/O';

create function pg_catalog.txid_snapshot_send(txid_snapshot)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.txid_snapshot_send
;

comment on function pg_catalog.txid_snapshot_send(txid_snapshot)
is 'I/O';

create function pg_catalog.txid_current()
stable
strict
cost 1
language internal
as
-- missing source code for pg_catalog.txid_current
;

comment on function pg_catalog.txid_current()
is 'get current transaction ID';

create function pg_catalog.txid_current_snapshot()
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.txid_current_snapshot
;

comment on function pg_catalog.txid_current_snapshot()
is 'get current snapshot';

create function pg_catalog.txid_snapshot_xmin(txid_snapshot)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.txid_snapshot_xmin
;

comment on function pg_catalog.txid_snapshot_xmin(txid_snapshot)
is 'get xmin of snapshot';

create function pg_catalog.txid_snapshot_xmax(txid_snapshot)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.txid_snapshot_xmax
;

comment on function pg_catalog.txid_snapshot_xmax(txid_snapshot)
is 'get xmax of snapshot';

create function pg_catalog.txid_snapshot_xip(txid_snapshot)
immutable
strict
parallel safe
cost 1
rows 50
language internal
as
-- missing source code for pg_catalog.txid_snapshot_xip
;

comment on function pg_catalog.txid_snapshot_xip(txid_snapshot)
is 'get set of in-progress txids in snapshot';

create function pg_catalog.txid_visible_in_snapshot(bigint, txid_snapshot)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.txid_visible_in_snapshot
;

comment on function pg_catalog.txid_visible_in_snapshot(bigint, txid_snapshot)
is 'is txid visible in snapshot?';

create function pg_catalog.uuid_in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.uuid_in
;

comment on function pg_catalog.uuid_in(cstring)
is 'I/O';

create function pg_catalog.uuid_out(uuid)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.uuid_out
;

comment on function pg_catalog.uuid_out(uuid)
is 'I/O';

create function pg_catalog.uuid_lt(uuid, uuid)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.uuid_lt
;

comment on function pg_catalog.uuid_lt(uuid, uuid)
is 'implementation of < operator';

create function pg_catalog.uuid_le(uuid, uuid)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.uuid_le
;

comment on function pg_catalog.uuid_le(uuid, uuid)
is 'implementation of <= operator';

create function pg_catalog.uuid_eq(uuid, uuid)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.uuid_eq
;

comment on function pg_catalog.uuid_eq(uuid, uuid)
is 'implementation of = operator';

create function pg_catalog.uuid_ge(uuid, uuid)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.uuid_ge
;

comment on function pg_catalog.uuid_ge(uuid, uuid)
is 'implementation of >= operator';

create function pg_catalog.uuid_gt(uuid, uuid)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.uuid_gt
;

comment on function pg_catalog.uuid_gt(uuid, uuid)
is 'implementation of > operator';

create function pg_catalog.uuid_ne(uuid, uuid)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.uuid_ne
;

comment on function pg_catalog.uuid_ne(uuid, uuid)
is 'implementation of <> operator';

create function pg_catalog.uuid_cmp(uuid, uuid)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.uuid_cmp
;

comment on function pg_catalog.uuid_cmp(uuid, uuid)
is 'less-equal-greater';

create function pg_catalog.uuid_recv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.uuid_recv
;

comment on function pg_catalog.uuid_recv(internal)
is 'I/O';

create function pg_catalog.uuid_send(uuid)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.uuid_send
;

comment on function pg_catalog.uuid_send(uuid)
is 'I/O';

create function pg_catalog.uuid_hash(uuid)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.uuid_hash
;

comment on function pg_catalog.uuid_hash(uuid)
is 'hash';

create function pg_catalog.text(boolean)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.text
;

comment on function pg_catalog.text(boolean)
is 'convert boolean to text';

create function pg_catalog.pg_stat_get_function_calls(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_function_calls
;

comment on function pg_catalog.pg_stat_get_function_calls(oid)
is 'statistics: number of function calls';

create function pg_catalog.pg_stat_get_function_total_time(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_function_total_time
;

comment on function pg_catalog.pg_stat_get_function_total_time(oid)
is 'statistics: total execution time of function, in milliseconds';

create function pg_catalog.pg_stat_get_function_self_time(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_function_self_time
;

comment on function pg_catalog.pg_stat_get_function_self_time(oid)
is 'statistics: self execution time of function, in milliseconds';

create function pg_catalog.record_eq(record, record)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.record_eq
;

comment on function pg_catalog.record_eq(record, record)
is 'implementation of = operator';

create function pg_catalog.record_ne(record, record)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.record_ne
;

comment on function pg_catalog.record_ne(record, record)
is 'implementation of <> operator';

create function pg_catalog.record_lt(record, record)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.record_lt
;

comment on function pg_catalog.record_lt(record, record)
is 'implementation of < operator';

create function pg_catalog.record_gt(record, record)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.record_gt
;

comment on function pg_catalog.record_gt(record, record)
is 'implementation of > operator';

create function pg_catalog.record_le(record, record)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.record_le
;

comment on function pg_catalog.record_le(record, record)
is 'implementation of <= operator';

create function pg_catalog.record_ge(record, record)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.record_ge
;

comment on function pg_catalog.record_ge(record, record)
is 'implementation of >= operator';

create function pg_catalog.btrecordcmp(record, record)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btrecordcmp
;

comment on function pg_catalog.btrecordcmp(record, record)
is 'less-equal-greater';

create function pg_catalog.pg_table_size(regclass)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_table_size
;

comment on function pg_catalog.pg_table_size(regclass)
is 'disk space usage for the specified table, including TOAST, free space and visibility map';

create function pg_catalog.pg_indexes_size(regclass)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_indexes_size
;

comment on function pg_catalog.pg_indexes_size(regclass)
is 'disk space usage for all indexes attached to the specified table';

create function pg_catalog.pg_relation_filenode(regclass)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_relation_filenode
;

comment on function pg_catalog.pg_relation_filenode(regclass)
is 'filenode identifier of relation';

create function pg_catalog.has_foreign_data_wrapper_privilege(name, text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_foreign_data_wrapper_privilege
;

comment on function pg_catalog.has_foreign_data_wrapper_privilege(name, text, text)
is 'user privilege on foreign data wrapper by username, foreign data wrapper name';

create function pg_catalog.has_foreign_data_wrapper_privilege(name, oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_foreign_data_wrapper_privilege
;

comment on function pg_catalog.has_foreign_data_wrapper_privilege(name, oid, text)
is 'user privilege on foreign data wrapper by username, foreign data wrapper oid';

create function pg_catalog.has_foreign_data_wrapper_privilege(oid, text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_foreign_data_wrapper_privilege
;

comment on function pg_catalog.has_foreign_data_wrapper_privilege(oid, text, text)
is 'user privilege on foreign data wrapper by user oid, foreign data wrapper name';

create function pg_catalog.has_foreign_data_wrapper_privilege(oid, oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_foreign_data_wrapper_privilege
;

comment on function pg_catalog.has_foreign_data_wrapper_privilege(oid, oid, text)
is 'user privilege on foreign data wrapper by user oid, foreign data wrapper oid';

create function pg_catalog.has_foreign_data_wrapper_privilege(text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_foreign_data_wrapper_privilege
;

comment on function pg_catalog.has_foreign_data_wrapper_privilege(text, text)
is 'current user privilege on foreign data wrapper by foreign data wrapper name';

create function pg_catalog.has_foreign_data_wrapper_privilege(oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_foreign_data_wrapper_privilege
;

comment on function pg_catalog.has_foreign_data_wrapper_privilege(oid, text)
is 'current user privilege on foreign data wrapper by foreign data wrapper oid';

create function pg_catalog.has_server_privilege(name, text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_server_privilege
;

comment on function pg_catalog.has_server_privilege(name, text, text)
is 'user privilege on server by username, server name';

create function pg_catalog.has_server_privilege(name, oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_server_privilege
;

comment on function pg_catalog.has_server_privilege(name, oid, text)
is 'user privilege on server by username, server oid';

create function pg_catalog.has_server_privilege(oid, text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_server_privilege
;

comment on function pg_catalog.has_server_privilege(oid, text, text)
is 'user privilege on server by user oid, server name';

create function pg_catalog.has_server_privilege(oid, oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_server_privilege
;

comment on function pg_catalog.has_server_privilege(oid, oid, text)
is 'user privilege on server by user oid, server oid';

create function pg_catalog.has_server_privilege(text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_server_privilege
;

comment on function pg_catalog.has_server_privilege(text, text)
is 'current user privilege on server by server name';

create function pg_catalog.has_server_privilege(oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_server_privilege
;

comment on function pg_catalog.has_server_privilege(oid, text)
is 'current user privilege on server by server oid';

create function pg_catalog.has_column_privilege(name, text, text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_column_privilege
;

comment on function pg_catalog.has_column_privilege(name, text, text, text)
is 'user privilege on column by username, rel name, col name';

create function pg_catalog.has_column_privilege(name, text, smallint, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_column_privilege
;

comment on function pg_catalog.has_column_privilege(name, text, smallint, text)
is 'user privilege on column by username, rel name, col attnum';

create function pg_catalog.has_column_privilege(name, oid, text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_column_privilege
;

comment on function pg_catalog.has_column_privilege(name, oid, text, text)
is 'user privilege on column by username, rel oid, col name';

create function pg_catalog.has_column_privilege(name, oid, smallint, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_column_privilege
;

comment on function pg_catalog.has_column_privilege(name, oid, smallint, text)
is 'user privilege on column by username, rel oid, col attnum';

create function pg_catalog.has_column_privilege(oid, text, text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_column_privilege
;

comment on function pg_catalog.has_column_privilege(oid, text, text, text)
is 'user privilege on column by user oid, rel name, col name';

create function pg_catalog.has_column_privilege(oid, text, smallint, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_column_privilege
;

comment on function pg_catalog.has_column_privilege(oid, text, smallint, text)
is 'user privilege on column by user oid, rel name, col attnum';

create function pg_catalog.has_column_privilege(oid, oid, text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_column_privilege
;

comment on function pg_catalog.has_column_privilege(oid, oid, text, text)
is 'user privilege on column by user oid, rel oid, col name';

create function pg_catalog.has_column_privilege(oid, oid, smallint, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_column_privilege
;

comment on function pg_catalog.has_column_privilege(oid, oid, smallint, text)
is 'user privilege on column by user oid, rel oid, col attnum';

create function pg_catalog.has_column_privilege(text, text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_column_privilege
;

comment on function pg_catalog.has_column_privilege(text, text, text)
is 'current user privilege on column by rel name, col name';

create function pg_catalog.has_column_privilege(text, smallint, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_column_privilege
;

comment on function pg_catalog.has_column_privilege(text, smallint, text)
is 'current user privilege on column by rel name, col attnum';

create function pg_catalog.has_column_privilege(oid, text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_column_privilege
;

comment on function pg_catalog.has_column_privilege(oid, text, text)
is 'current user privilege on column by rel oid, col name';

create function pg_catalog.has_column_privilege(oid, smallint, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_column_privilege
;

comment on function pg_catalog.has_column_privilege(oid, smallint, text)
is 'current user privilege on column by rel oid, col attnum';

create function pg_catalog.has_any_column_privilege(name, text, text)
stable
strict
parallel safe
cost 10
language internal
as
-- missing source code for pg_catalog.has_any_column_privilege
;

comment on function pg_catalog.has_any_column_privilege(name, text, text)
is 'user privilege on any column by username, rel name';

create function pg_catalog.has_any_column_privilege(name, oid, text)
stable
strict
parallel safe
cost 10
language internal
as
-- missing source code for pg_catalog.has_any_column_privilege
;

comment on function pg_catalog.has_any_column_privilege(name, oid, text)
is 'user privilege on any column by username, rel oid';

create function pg_catalog.has_any_column_privilege(oid, text, text)
stable
strict
parallel safe
cost 10
language internal
as
-- missing source code for pg_catalog.has_any_column_privilege
;

comment on function pg_catalog.has_any_column_privilege(oid, text, text)
is 'user privilege on any column by user oid, rel name';

create function pg_catalog.has_any_column_privilege(oid, oid, text)
stable
strict
parallel safe
cost 10
language internal
as
-- missing source code for pg_catalog.has_any_column_privilege
;

comment on function pg_catalog.has_any_column_privilege(oid, oid, text)
is 'user privilege on any column by user oid, rel oid';

create function pg_catalog.has_any_column_privilege(text, text)
stable
strict
parallel safe
cost 10
language internal
as
-- missing source code for pg_catalog.has_any_column_privilege
;

comment on function pg_catalog.has_any_column_privilege(text, text)
is 'current user privilege on any column by rel name';

create function pg_catalog.has_any_column_privilege(oid, text)
stable
strict
parallel safe
cost 10
language internal
as
-- missing source code for pg_catalog.has_any_column_privilege
;

comment on function pg_catalog.has_any_column_privilege(oid, text)
is 'current user privilege on any column by rel oid';

create function pg_catalog.overlay(bit, bit, integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.overlay
;

comment on function pg_catalog.overlay(bit, bit, integer, integer)
is 'substitute portion of bitstring';

create function pg_catalog.overlay(bit, bit, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.overlay
;

comment on function pg_catalog.overlay(bit, bit, integer)
is 'substitute portion of bitstring';

create function pg_catalog.get_bit(bit, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.get_bit
;

comment on function pg_catalog.get_bit(bit, integer)
is 'get bit';

create function pg_catalog.set_bit(bit, integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.set_bit
;

comment on function pg_catalog.set_bit(bit, integer, integer)
is 'set bit';

create function pg_catalog.pg_relation_filepath(regclass)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_relation_filepath
;

comment on function pg_catalog.pg_relation_filepath(regclass)
is 'file path of relation';

create function pg_catalog.pg_listening_channels()
stable
strict
parallel restricted
cost 1
rows 10
language internal
as
-- missing source code for pg_catalog.pg_listening_channels
;

comment on function pg_catalog.pg_listening_channels()
is 'get the channels that the current backend listens to';

create function pg_catalog.pg_notify(text, text)
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_notify
;

comment on function pg_catalog.pg_notify(text, text)
is 'send a notification event';

create function pg_catalog.pg_stat_get_xact_numscans(oid)
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_xact_numscans
;

comment on function pg_catalog.pg_stat_get_xact_numscans(oid)
is 'statistics: number of scans done for table/index in current transaction';

create function pg_catalog.pg_stat_get_xact_tuples_returned(oid)
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_xact_tuples_returned
;

comment on function pg_catalog.pg_stat_get_xact_tuples_returned(oid)
is 'statistics: number of tuples read by seqscan in current transaction';

create function pg_catalog.pg_stat_get_xact_tuples_fetched(oid)
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_xact_tuples_fetched
;

comment on function pg_catalog.pg_stat_get_xact_tuples_fetched(oid)
is 'statistics: number of tuples fetched by idxscan in current transaction';

create function pg_catalog.pg_stat_get_xact_tuples_inserted(oid)
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_xact_tuples_inserted
;

comment on function pg_catalog.pg_stat_get_xact_tuples_inserted(oid)
is 'statistics: number of tuples inserted in current transaction';

create function pg_catalog.pg_stat_get_xact_tuples_updated(oid)
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_xact_tuples_updated
;

comment on function pg_catalog.pg_stat_get_xact_tuples_updated(oid)
is 'statistics: number of tuples updated in current transaction';

create function pg_catalog.pg_stat_get_xact_tuples_deleted(oid)
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_xact_tuples_deleted
;

comment on function pg_catalog.pg_stat_get_xact_tuples_deleted(oid)
is 'statistics: number of tuples deleted in current transaction';

create function pg_catalog.pg_stat_get_xact_tuples_hot_updated(oid)
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_xact_tuples_hot_updated
;

comment on function pg_catalog.pg_stat_get_xact_tuples_hot_updated(oid)
is 'statistics: number of tuples hot updated in current transaction';

create function pg_catalog.pg_stat_get_xact_blocks_fetched(oid)
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_xact_blocks_fetched
;

comment on function pg_catalog.pg_stat_get_xact_blocks_fetched(oid)
is 'statistics: number of blocks fetched in current transaction';

create function pg_catalog.pg_stat_get_xact_blocks_hit(oid)
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_xact_blocks_hit
;

comment on function pg_catalog.pg_stat_get_xact_blocks_hit(oid)
is 'statistics: number of blocks found in cache in current transaction';

create function pg_catalog.pg_stat_get_xact_function_calls(oid)
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_xact_function_calls
;

comment on function pg_catalog.pg_stat_get_xact_function_calls(oid)
is 'statistics: number of function calls in current transaction';

create function pg_catalog.pg_stat_get_xact_function_total_time(oid)
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_xact_function_total_time
;

comment on function pg_catalog.pg_stat_get_xact_function_total_time(oid)
is 'statistics: total execution time of function in current transaction, in milliseconds';

create function pg_catalog.pg_stat_get_xact_function_self_time(oid)
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_xact_function_self_time
;

comment on function pg_catalog.pg_stat_get_xact_function_self_time(oid)
is 'statistics: self execution time of function in current transaction, in milliseconds';

create function pg_catalog.xpath_exists(text, xml, text [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.xpath_exists
;

comment on function pg_catalog.xpath_exists(text, xml, text [])
is 'test XML value against XPath expression, with namespace support';

create function pg_catalog.xpath_exists(text, xml)
  returns boolean
immutable
strict
parallel safe
cost 1
language sql
as $$
select pg_catalog.xpath_exists($1, $2, '{}' :: pg_catalog.text [])
$$;

comment on function pg_catalog.xpath_exists(text, xml)
is 'test XML value against XPath expression';

create function pg_catalog.xml_is_well_formed(text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.xml_is_well_formed
;

comment on function pg_catalog.xml_is_well_formed(text)
is 'determine if a string is well formed XML';

create function pg_catalog.xml_is_well_formed_document(text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.xml_is_well_formed_document
;

comment on function pg_catalog.xml_is_well_formed_document(text)
is 'determine if a string is well formed XML document';

create function pg_catalog.xml_is_well_formed_content(text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.xml_is_well_formed_content
;

comment on function pg_catalog.xml_is_well_formed_content(text)
is 'determine if a string is well formed XML content';

create function pg_catalog.pg_stat_get_vacuum_count(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_vacuum_count
;

comment on function pg_catalog.pg_stat_get_vacuum_count(oid)
is 'statistics: number of manual vacuums for a table';

create function pg_catalog.pg_stat_get_autovacuum_count(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_autovacuum_count
;

comment on function pg_catalog.pg_stat_get_autovacuum_count(oid)
is 'statistics: number of auto vacuums for a table';

create function pg_catalog.pg_stat_get_analyze_count(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_analyze_count
;

comment on function pg_catalog.pg_stat_get_analyze_count(oid)
is 'statistics: number of manual analyzes for a table';

create function pg_catalog.pg_stat_get_autoanalyze_count(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_autoanalyze_count
;

comment on function pg_catalog.pg_stat_get_autoanalyze_count(oid)
is 'statistics: number of auto analyzes for a table';

create function pg_catalog.concat("any")
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.concat
;

comment on function pg_catalog.concat("any")
is 'concatenate values';

create function pg_catalog.concat_ws(text, "any")
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.concat_ws
;

comment on function pg_catalog.concat_ws(text, "any")
is 'concatenate values with separators';

create function pg_catalog."left"(text, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog."left"
;

comment on function pg_catalog."left"(text, integer)
is 'extract the first n characters';

create function pg_catalog."right"(text, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog."right"
;

comment on function pg_catalog."right"(text, integer)
is 'extract the last n characters';

create function pg_catalog.reverse(text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.reverse
;

comment on function pg_catalog.reverse(text)
is 'reverse text';

create function pg_catalog.pg_stat_get_buf_fsync_backend()
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_buf_fsync_backend
;

comment on function pg_catalog.pg_stat_get_buf_fsync_backend()
is 'statistics: number of backend buffer writes that did their own fsync';

create function pg_catalog.gist_point_distance(internal, point, smallint, oid, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gist_point_distance
;

comment on function pg_catalog.gist_point_distance(internal, point, smallint, oid, internal)
is 'GiST support';

create function pg_catalog.pg_stat_get_db_conflict_tablespace(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_db_conflict_tablespace
;

comment on function pg_catalog.pg_stat_get_db_conflict_tablespace(oid)
is 'statistics: recovery conflicts in database caused by drop tablespace';

create function pg_catalog.pg_stat_get_db_conflict_lock(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_db_conflict_lock
;

comment on function pg_catalog.pg_stat_get_db_conflict_lock(oid)
is 'statistics: recovery conflicts in database caused by relation lock';

create function pg_catalog.pg_stat_get_db_conflict_snapshot(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_db_conflict_snapshot
;

comment on function pg_catalog.pg_stat_get_db_conflict_snapshot(oid)
is 'statistics: recovery conflicts in database caused by snapshot expiry';

create function pg_catalog.pg_stat_get_db_conflict_bufferpin(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_db_conflict_bufferpin
;

comment on function pg_catalog.pg_stat_get_db_conflict_bufferpin(oid)
is 'statistics: recovery conflicts in database caused by shared buffer pin';

create function pg_catalog.pg_stat_get_db_conflict_startup_deadlock(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_db_conflict_startup_deadlock
;

comment on function pg_catalog.pg_stat_get_db_conflict_startup_deadlock(oid)
is 'statistics: recovery conflicts in database caused by buffer deadlock';

create function pg_catalog.pg_stat_get_db_conflict_all(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_db_conflict_all
;

comment on function pg_catalog.pg_stat_get_db_conflict_all(oid)
is 'statistics: recovery conflicts in database';

create function pg_catalog.pg_wal_replay_pause()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_wal_replay_pause
;

comment on function pg_catalog.pg_wal_replay_pause()
is 'pause wal replay';

create function pg_catalog.pg_wal_replay_resume()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_wal_replay_resume
;

comment on function pg_catalog.pg_wal_replay_resume()
is 'resume wal replay, if it was paused';

create function pg_catalog.pg_is_wal_replay_paused()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_is_wal_replay_paused
;

comment on function pg_catalog.pg_is_wal_replay_paused()
is 'true if wal replay is paused';

create function pg_catalog.pg_stat_get_db_stat_reset_time(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_db_stat_reset_time
;

comment on function pg_catalog.pg_stat_get_db_stat_reset_time(oid)
is 'statistics: last reset for a database';

create function pg_catalog.pg_stat_get_bgwriter_stat_reset_time()
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_bgwriter_stat_reset_time
;

comment on function pg_catalog.pg_stat_get_bgwriter_stat_reset_time()
is 'statistics: last reset for the bgwriter';

create function pg_catalog.ginarrayextract(anyarray, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ginarrayextract
;

comment on function pg_catalog.ginarrayextract(anyarray, internal)
is 'GIN array support (obsolete)';

create function pg_catalog.gin_extract_tsvector(tsvector, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gin_extract_tsvector
;

comment on function pg_catalog.gin_extract_tsvector(tsvector, internal)
is 'GIN tsvector support (obsolete)';

create function pg_catalog.pg_sequence_parameters(sequence_oid oid, out start_value bigint, out minimum_value bigint,
                                                                    out maximum_value bigint, out increment bigint,
                                                                    out cycle_option boolean, out cache_size bigint,
                                                                    out data_type oid)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_sequence_parameters
;

comment on function pg_catalog.pg_sequence_parameters(oid, out bigint, out bigint, out bigint, out bigint, out boolean,
                                                           out bigint, out oid)
is 'sequence parameters, for use by information schema';

create function pg_catalog.pg_available_extensions(out name name, out default_version text, out comment text)
stable
strict
parallel safe
cost 10
rows 100
language internal
as
-- missing source code for pg_catalog.pg_available_extensions
;

comment on function pg_catalog.pg_available_extensions(out name, out text, out text)
is 'list available extensions';

create function pg_catalog.pg_available_extension_versions(out name        name, out version text,
                                                           out superuser   boolean, out relocatable boolean,
                                                           out schema      name, out requires name [], out comment text)
stable
strict
parallel safe
cost 10
rows 100
language internal
as
-- missing source code for pg_catalog.pg_available_extension_versions
;

comment on function pg_catalog.pg_available_extension_versions(out name, out text, out boolean, out boolean, out name,
                                                               out name [], out text)
is 'list available extension versions';

create function pg_catalog.pg_extension_update_paths(name name, out source text, out target text, out path text)
stable
strict
parallel safe
cost 10
rows 100
language internal
as
-- missing source code for pg_catalog.pg_extension_update_paths
;

comment on function pg_catalog.pg_extension_update_paths(name, out text, out text, out text)
is 'list an extension''s version update paths';

create function pg_catalog.pg_extension_config_dump(regclass, text)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_extension_config_dump
;

comment on function pg_catalog.pg_extension_config_dump(regclass, text)
is 'flag an extension''s table contents to be emitted by pg_dump';

create function pg_catalog.gin_extract_tsquery(tsquery, internal, smallint, internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gin_extract_tsquery
;

comment on function pg_catalog.gin_extract_tsquery(tsquery, internal, smallint, internal, internal)
is 'GIN tsvector support (obsolete)';

create function pg_catalog.gin_tsquery_consistent(internal, smallint, tsquery, integer, internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gin_tsquery_consistent
;

comment on function pg_catalog.gin_tsquery_consistent(internal, smallint, tsquery, integer, internal, internal)
is 'GIN tsvector support (obsolete)';

create function pg_catalog.pg_advisory_xact_lock(bigint)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_advisory_xact_lock
;

comment on function pg_catalog.pg_advisory_xact_lock(bigint)
is 'obtain exclusive advisory lock';

create function pg_catalog.pg_advisory_xact_lock_shared(bigint)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_advisory_xact_lock_shared
;

comment on function pg_catalog.pg_advisory_xact_lock_shared(bigint)
is 'obtain shared advisory lock';

create function pg_catalog.pg_try_advisory_xact_lock(bigint)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_try_advisory_xact_lock
;

comment on function pg_catalog.pg_try_advisory_xact_lock(bigint)
is 'obtain exclusive advisory lock if available';

create function pg_catalog.pg_try_advisory_xact_lock_shared(bigint)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_try_advisory_xact_lock_shared
;

comment on function pg_catalog.pg_try_advisory_xact_lock_shared(bigint)
is 'obtain shared advisory lock if available';

create function pg_catalog.pg_advisory_xact_lock(integer, integer)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_advisory_xact_lock
;

comment on function pg_catalog.pg_advisory_xact_lock(integer, integer)
is 'obtain exclusive advisory lock';

create function pg_catalog.pg_advisory_xact_lock_shared(integer, integer)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_advisory_xact_lock_shared
;

comment on function pg_catalog.pg_advisory_xact_lock_shared(integer, integer)
is 'obtain shared advisory lock';

create function pg_catalog.pg_try_advisory_xact_lock(integer, integer)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_try_advisory_xact_lock
;

comment on function pg_catalog.pg_try_advisory_xact_lock(integer, integer)
is 'obtain exclusive advisory lock if available';

create function pg_catalog.pg_try_advisory_xact_lock_shared(integer, integer)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_try_advisory_xact_lock_shared
;

comment on function pg_catalog.pg_try_advisory_xact_lock_shared(integer, integer)
is 'obtain shared advisory lock if available';

create function pg_catalog.varchar_transform(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.varchar_transform
;

comment on function pg_catalog.varchar_transform(internal)
is 'transform a varchar length coercion';

create function pg_catalog.pg_create_restore_point(text)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_create_restore_point
;

comment on function pg_catalog.pg_create_restore_point(text)
is 'create a named restore point';

create function pg_catalog.pg_stat_get_wal_senders(out pid        integer, out state text, out sent_lsn pg_lsn,
                                                   out write_lsn  pg_lsn, out flush_lsn pg_lsn, out replay_lsn pg_lsn,
                                                   out write_lag  interval, out flush_lag interval,
                                                   out replay_lag interval, out sync_priority integer,
                                                   out sync_state text)
stable
parallel restricted
cost 1
rows 10
language internal
as
-- missing source code for pg_catalog.pg_stat_get_wal_senders
;

comment on function pg_catalog.pg_stat_get_wal_senders(out integer, out text, out pg_lsn, out pg_lsn, out pg_lsn,
                                                       out pg_lsn, out interval, out interval, out interval,
                                                       out integer, out text)
is 'statistics: information about currently active replication';

create function pg_catalog.row_number()
immutable
window
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.row_number
;

comment on function pg_catalog.row_number()
is 'row number within partition';

create function pg_catalog.rank()
immutable
window
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.rank
;

comment on function pg_catalog.rank()
is 'integer rank with gaps';

create function pg_catalog.dense_rank()
immutable
window
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.dense_rank
;

comment on function pg_catalog.dense_rank()
is 'integer rank without gaps';

create function pg_catalog.percent_rank()
immutable
window
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.percent_rank
;

comment on function pg_catalog.percent_rank()
is 'fractional rank within partition';

create function pg_catalog.cume_dist()
immutable
window
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cume_dist
;

comment on function pg_catalog.cume_dist()
is 'fractional row number within partition';

create function pg_catalog.ntile(integer)
immutable
window
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ntile
;

comment on function pg_catalog.ntile(integer)
is 'split rows into N groups';

create function pg_catalog.lag(anyelement)
immutable
window
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lag
;

comment on function pg_catalog.lag(anyelement)
is 'fetch the preceding row value';

create function pg_catalog.lag(anyelement, integer)
immutable
window
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lag
;

comment on function pg_catalog.lag(anyelement, integer)
is 'fetch the Nth preceding row value';

create function pg_catalog.lag(anyelement, integer, anyelement)
immutable
window
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lag
;

comment on function pg_catalog.lag(anyelement, integer, anyelement)
is 'fetch the Nth preceding row value with default';

create function pg_catalog.lead(anyelement)
immutable
window
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lead
;

comment on function pg_catalog.lead(anyelement)
is 'fetch the following row value';

create function pg_catalog.lead(anyelement, integer)
immutable
window
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lead
;

comment on function pg_catalog.lead(anyelement, integer)
is 'fetch the Nth following row value';

create function pg_catalog.lead(anyelement, integer, anyelement)
immutable
window
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lead
;

comment on function pg_catalog.lead(anyelement, integer, anyelement)
is 'fetch the Nth following row value with default';

create function pg_catalog.first_value(anyelement)
immutable
window
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.first_value
;

comment on function pg_catalog.first_value(anyelement)
is 'fetch the first row value';

create function pg_catalog.last_value(anyelement)
immutable
window
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.last_value
;

comment on function pg_catalog.last_value(anyelement)
is 'fetch the last row value';

create function pg_catalog.nth_value(anyelement, integer)
immutable
window
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.nth_value
;

comment on function pg_catalog.nth_value(anyelement, integer)
is 'fetch the Nth row value';

create function pg_catalog.fdw_handler_in(cstring)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.fdw_handler_in
;

comment on function pg_catalog.fdw_handler_in(cstring)
is 'I/O';

create function pg_catalog.fdw_handler_out(fdw_handler)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.fdw_handler_out
;

comment on function pg_catalog.fdw_handler_out(fdw_handler)
is 'I/O';

create function pg_catalog.void_recv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.void_recv
;

comment on function pg_catalog.void_recv(internal)
is 'I/O';

create function pg_catalog.void_send(void)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.void_send
;

comment on function pg_catalog.void_send(void)
is 'I/O';

create function pg_catalog.btint2sortsupport(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btint2sortsupport
;

comment on function pg_catalog.btint2sortsupport(internal)
is 'sort support';

create function pg_catalog.btint4sortsupport(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btint4sortsupport
;

comment on function pg_catalog.btint4sortsupport(internal)
is 'sort support';

create function pg_catalog.btint8sortsupport(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btint8sortsupport
;

comment on function pg_catalog.btint8sortsupport(internal)
is 'sort support';

create function pg_catalog.btfloat4sortsupport(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btfloat4sortsupport
;

comment on function pg_catalog.btfloat4sortsupport(internal)
is 'sort support';

create function pg_catalog.btfloat8sortsupport(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btfloat8sortsupport
;

comment on function pg_catalog.btfloat8sortsupport(internal)
is 'sort support';

create function pg_catalog.btoidsortsupport(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btoidsortsupport
;

comment on function pg_catalog.btoidsortsupport(internal)
is 'sort support';

create function pg_catalog.btnamesortsupport(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btnamesortsupport
;

comment on function pg_catalog.btnamesortsupport(internal)
is 'sort support';

create function pg_catalog.date_sortsupport(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.date_sortsupport
;

comment on function pg_catalog.date_sortsupport(internal)
is 'sort support';

create function pg_catalog.timestamp_sortsupport(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_sortsupport
;

comment on function pg_catalog.timestamp_sortsupport(internal)
is 'sort support';

create function pg_catalog.has_type_privilege(name, text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_type_privilege
;

comment on function pg_catalog.has_type_privilege(name, text, text)
is 'user privilege on type by username, type name';

create function pg_catalog.has_type_privilege(name, oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_type_privilege
;

comment on function pg_catalog.has_type_privilege(name, oid, text)
is 'user privilege on type by username, type oid';

create function pg_catalog.has_type_privilege(oid, text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_type_privilege
;

comment on function pg_catalog.has_type_privilege(oid, text, text)
is 'user privilege on type by user oid, type name';

create function pg_catalog.has_type_privilege(oid, oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_type_privilege
;

comment on function pg_catalog.has_type_privilege(oid, oid, text)
is 'user privilege on type by user oid, type oid';

create function pg_catalog.has_type_privilege(text, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_type_privilege
;

comment on function pg_catalog.has_type_privilege(text, text)
is 'current user privilege on type by type name';

create function pg_catalog.has_type_privilege(oid, text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.has_type_privilege
;

comment on function pg_catalog.has_type_privilege(oid, text)
is 'current user privilege on type by type oid';

create function pg_catalog.macaddr_not(macaddr)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr_not
;

comment on function pg_catalog.macaddr_not(macaddr)
is 'implementation of ~ operator';

create function pg_catalog.macaddr_and(macaddr, macaddr)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr_and
;

comment on function pg_catalog.macaddr_and(macaddr, macaddr)
is 'implementation of & operator';

create function pg_catalog.macaddr_or(macaddr, macaddr)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr_or
;

comment on function pg_catalog.macaddr_or(macaddr, macaddr)
is 'implementation of | operator';

create function pg_catalog.pg_stat_get_db_temp_files(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_db_temp_files
;

comment on function pg_catalog.pg_stat_get_db_temp_files(oid)
is 'statistics: number of temporary files written';

create function pg_catalog.pg_stat_get_db_temp_bytes(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_db_temp_bytes
;

comment on function pg_catalog.pg_stat_get_db_temp_bytes(oid)
is 'statistics: number of bytes in temporary files written';

create function pg_catalog.pg_stat_get_db_deadlocks(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_db_deadlocks
;

comment on function pg_catalog.pg_stat_get_db_deadlocks(oid)
is 'statistics: deadlocks detected in database';

create function pg_catalog.array_to_json(anyarray)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_to_json
;

comment on function pg_catalog.array_to_json(anyarray)
is 'map array to json';

create function pg_catalog.array_to_json(anyarray, boolean)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_to_json
;

comment on function pg_catalog.array_to_json(anyarray, boolean)
is 'map array to json with optional pretty printing';

create function pg_catalog.row_to_json(record)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.row_to_json
;

comment on function pg_catalog.row_to_json(record)
is 'map row to json';

create function pg_catalog.row_to_json(record, boolean)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.row_to_json
;

comment on function pg_catalog.row_to_json(record, boolean)
is 'map row to json with optional pretty printing';

create function pg_catalog.numeric_transform(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_transform
;

comment on function pg_catalog.numeric_transform(internal)
is 'transform a numeric length coercion';

create function pg_catalog.varbit_transform(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.varbit_transform
;

comment on function pg_catalog.varbit_transform(internal)
is 'transform a varbit length coercion';

create function pg_catalog.pg_get_viewdef(oid, integer)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_get_viewdef
;

comment on function pg_catalog.pg_get_viewdef(oid, integer)
is 'select statement of a view with pretty-printing and specified line wrapping';

create function pg_catalog.pg_stat_get_checkpoint_write_time()
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_checkpoint_write_time
;

comment on function pg_catalog.pg_stat_get_checkpoint_write_time()
is 'statistics: checkpoint time spent writing buffers to disk, in milliseconds';

create function pg_catalog.pg_stat_get_checkpoint_sync_time()
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_checkpoint_sync_time
;

comment on function pg_catalog.pg_stat_get_checkpoint_sync_time()
is 'statistics: checkpoint time spent synchronizing buffers to disk, in milliseconds';

create function pg_catalog.pg_collation_for("any")
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_collation_for
;

comment on function pg_catalog.pg_collation_for("any")
is 'collation of the argument; implementation of the COLLATION FOR expression';

create function pg_catalog.pg_trigger_depth()
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_trigger_depth
;

comment on function pg_catalog.pg_trigger_depth()
is 'current trigger depth';

create function pg_catalog.pg_wal_lsn_diff(pg_lsn, pg_lsn)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_wal_lsn_diff
;

comment on function pg_catalog.pg_wal_lsn_diff(pg_lsn, pg_lsn)
is 'difference in bytes, given two wal locations';

create function pg_catalog.pg_size_pretty(numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_size_pretty
;

comment on function pg_catalog.pg_size_pretty(numeric)
is 'convert a numeric to a human readable text using size units';

create function pg_catalog.array_remove(anyarray, anyelement)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_remove
;

comment on function pg_catalog.array_remove(anyarray, anyelement)
is 'remove any occurrences of an element from an array';

create function pg_catalog.array_replace(anyarray, anyelement, anyelement)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_replace
;

comment on function pg_catalog.array_replace(anyarray, anyelement, anyelement)
is 'replace any occurrences of an element in an array';

create function pg_catalog.rangesel(internal, oid, internal, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.rangesel
;

comment on function pg_catalog.rangesel(internal, oid, internal, integer)
is 'restriction selectivity for range operators';

create function pg_catalog.lo_lseek64(integer, bigint, integer)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.lo_lseek64
;

comment on function pg_catalog.lo_lseek64(integer, bigint, integer)
is 'large object seek (64 bit)';

create function pg_catalog.lo_tell64(integer)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.lo_tell64
;

comment on function pg_catalog.lo_tell64(integer)
is 'large object position (64 bit)';

create function pg_catalog.lo_truncate64(integer, bigint)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.lo_truncate64
;

comment on function pg_catalog.lo_truncate64(integer, bigint)
is 'truncate large object (64 bit)';

create function pg_catalog.json_agg_transfn(internal, anyelement)
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.json_agg_transfn
;

comment on function pg_catalog.json_agg_transfn(internal, anyelement)
is 'json aggregate transition function';

create function pg_catalog.json_agg_finalfn(internal)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.json_agg_finalfn
;

comment on function pg_catalog.json_agg_finalfn(internal)
is 'json aggregate final function';

create function pg_catalog.to_json(anyelement)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.to_json
;

comment on function pg_catalog.to_json(anyelement)
is 'map input to json';

create function pg_catalog.pg_stat_get_mod_since_analyze(oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_mod_since_analyze
;

comment on function pg_catalog.pg_stat_get_mod_since_analyze(oid)
is 'statistics: number of tuples changed since last analyze';

create function pg_catalog.numeric_sum(internal)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_sum
;

comment on function pg_catalog.numeric_sum(internal)
is 'aggregate final function';

create function pg_catalog.cardinality(anyarray)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cardinality
;

comment on function pg_catalog.cardinality(anyarray)
is 'array cardinality';

create function pg_catalog.json_object_agg_transfn(internal, "any", "any")
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.json_object_agg_transfn
;

comment on function pg_catalog.json_object_agg_transfn(internal, "any", "any")
is 'json object aggregate transition function';

create function pg_catalog.record_image_eq(record, record)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.record_image_eq
;

comment on function pg_catalog.record_image_eq(record, record)
is 'implementation of *= operator';

create function pg_catalog.record_image_ne(record, record)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.record_image_ne
;

comment on function pg_catalog.record_image_ne(record, record)
is 'implementation of *<> operator';

create function pg_catalog.record_image_lt(record, record)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.record_image_lt
;

comment on function pg_catalog.record_image_lt(record, record)
is 'implementation of *< operator';

create function pg_catalog.record_image_gt(record, record)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.record_image_gt
;

comment on function pg_catalog.record_image_gt(record, record)
is 'implementation of *> operator';

create function pg_catalog.record_image_le(record, record)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.record_image_le
;

comment on function pg_catalog.record_image_le(record, record)
is 'implementation of *<= operator';

create function pg_catalog.record_image_ge(record, record)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.record_image_ge
;

comment on function pg_catalog.record_image_ge(record, record)
is 'implementation of *>= operator';

create function pg_catalog.btrecordimagecmp(record, record)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btrecordimagecmp
;

comment on function pg_catalog.btrecordimagecmp(record, record)
is 'less-equal-greater based on byte images';

create function pg_catalog.pg_stat_get_archiver(out archived_count     bigint, out last_archived_wal text,
                                                out last_archived_time timestamp with time zone,
                                                out failed_count       bigint, out last_failed_wal text,
                                                out last_failed_time   timestamp with time zone,
                                                out stats_reset        timestamp with time zone)
stable
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_archiver
;

comment on function pg_catalog.pg_stat_get_archiver(out bigint, out text, out timestamp with time zone, out bigint,
                                                    out text, out timestamp with time zone,
                                                    out timestamp with time zone)
is 'statistics: information about WAL archiver';

create function pg_catalog.json_object_agg_finalfn(internal)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.json_object_agg_finalfn
;

comment on function pg_catalog.json_object_agg_finalfn(internal)
is 'json object aggregate final function';

create function pg_catalog.json_build_array("any")
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.json_build_array
;

comment on function pg_catalog.json_build_array("any")
is 'build a json array from any inputs';

create function pg_catalog.json_build_array()
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.json_build_array
;

comment on function pg_catalog.json_build_array()
is 'build an empty json array';

create function pg_catalog.json_build_object("any")
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.json_build_object
;

comment on function pg_catalog.json_build_object("any")
is 'build a json object from pairwise key/value inputs';

create function pg_catalog.json_build_object()
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.json_build_object
;

comment on function pg_catalog.json_build_object()
is 'build an empty json object';

create function pg_catalog.json_object(text [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.json_object
;

comment on function pg_catalog.json_object(text [])
is 'map text array of key value pairs to json object';

create function pg_catalog.json_object(text [], text [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.json_object
;

comment on function pg_catalog.json_object(text [], text [])
is 'map text arrays of keys and values to json object';

create function pg_catalog.json_to_record(json)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.json_to_record
;

comment on function pg_catalog.json_to_record(json)
is 'get record fields from a json object';

create function pg_catalog.json_to_recordset(json)
stable
parallel safe
cost 1
rows 100
language internal
as
-- missing source code for pg_catalog.json_to_recordset
;

comment on function pg_catalog.json_to_recordset(json)
is 'get set of records with fields from a json array of objects';

create function pg_catalog.jsonb_array_length(jsonb)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_array_length
;

comment on function pg_catalog.jsonb_array_length(jsonb)
is 'length of jsonb array';

create function pg_catalog.jsonb_each(from_json jsonb, out key text, out value jsonb)
immutable
strict
parallel safe
cost 1
rows 100
language internal
as
-- missing source code for pg_catalog.jsonb_each
;

comment on function pg_catalog.jsonb_each(jsonb, out text, out jsonb)
is 'key value pairs of a jsonb object';

create function pg_catalog.jsonb_populate_record(anyelement, jsonb)
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_populate_record
;

comment on function pg_catalog.jsonb_populate_record(anyelement, jsonb)
is 'get record fields from a jsonb object';

create function pg_catalog.jsonb_typeof(jsonb)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_typeof
;

comment on function pg_catalog.jsonb_typeof(jsonb)
is 'get the type of a jsonb value';

create function pg_catalog.jsonb_object_field_text(from_json jsonb, field_name text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_object_field_text
;

comment on function pg_catalog.jsonb_object_field_text(jsonb, text)
is 'implementation of ->> operator';

create function pg_catalog.jsonb_array_element(from_json jsonb, element_index integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_array_element
;

comment on function pg_catalog.jsonb_array_element(jsonb, integer)
is 'implementation of -> operator';

create function pg_catalog.jsonb_array_element_text(from_json jsonb, element_index integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_array_element_text
;

comment on function pg_catalog.jsonb_array_element_text(jsonb, integer)
is 'implementation of ->> operator';

create function pg_catalog.jsonb_extract_path(from_json jsonb, path_elems text [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_extract_path
;

comment on function pg_catalog.jsonb_extract_path(jsonb, text [])
is 'get value from jsonb with path elements';

create function pg_catalog.width_bucket(anyelement, anyarray)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.width_bucket
;

comment on function pg_catalog.width_bucket(anyelement, anyarray)
is 'bucket number of operand given a sorted array of bucket lower bounds';

create function pg_catalog.jsonb_array_elements(from_json jsonb, out value jsonb)
immutable
strict
parallel safe
cost 1
rows 100
language internal
as
-- missing source code for pg_catalog.jsonb_array_elements
;

comment on function pg_catalog.jsonb_array_elements(jsonb, out jsonb)
is 'elements of a jsonb array';

create function pg_catalog.pg_lsn_in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_lsn_in
;

comment on function pg_catalog.pg_lsn_in(cstring)
is 'I/O';

create function pg_catalog.pg_lsn_out(pg_lsn)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_lsn_out
;

comment on function pg_catalog.pg_lsn_out(pg_lsn)
is 'I/O';

create function pg_catalog.pg_lsn_lt(pg_lsn, pg_lsn)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_lsn_lt
;

comment on function pg_catalog.pg_lsn_lt(pg_lsn, pg_lsn)
is 'implementation of < operator';

create function pg_catalog.pg_lsn_le(pg_lsn, pg_lsn)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_lsn_le
;

comment on function pg_catalog.pg_lsn_le(pg_lsn, pg_lsn)
is 'implementation of <= operator';

create function pg_catalog.pg_lsn_eq(pg_lsn, pg_lsn)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_lsn_eq
;

comment on function pg_catalog.pg_lsn_eq(pg_lsn, pg_lsn)
is 'implementation of = operator';

create function pg_catalog.pg_lsn_ge(pg_lsn, pg_lsn)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_lsn_ge
;

comment on function pg_catalog.pg_lsn_ge(pg_lsn, pg_lsn)
is 'implementation of >= operator';

create function pg_catalog.pg_lsn_gt(pg_lsn, pg_lsn)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_lsn_gt
;

comment on function pg_catalog.pg_lsn_gt(pg_lsn, pg_lsn)
is 'implementation of > operator';

create function pg_catalog.pg_lsn_ne(pg_lsn, pg_lsn)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_lsn_ne
;

comment on function pg_catalog.pg_lsn_ne(pg_lsn, pg_lsn)
is 'implementation of <> operator';

create function pg_catalog.pg_lsn_mi(pg_lsn, pg_lsn)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_lsn_mi
;

comment on function pg_catalog.pg_lsn_mi(pg_lsn, pg_lsn)
is 'implementation of - operator';

create function pg_catalog.pg_lsn_recv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_lsn_recv
;

comment on function pg_catalog.pg_lsn_recv(internal)
is 'I/O';

create function pg_catalog.pg_lsn_send(pg_lsn)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_lsn_send
;

comment on function pg_catalog.pg_lsn_send(pg_lsn)
is 'I/O';

create function pg_catalog.pg_lsn_cmp(pg_lsn, pg_lsn)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_lsn_cmp
;

comment on function pg_catalog.pg_lsn_cmp(pg_lsn, pg_lsn)
is 'less-equal-greater';

create function pg_catalog.pg_lsn_hash(pg_lsn)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_lsn_hash
;

comment on function pg_catalog.pg_lsn_hash(pg_lsn)
is 'hash';

create function pg_catalog.bttextsortsupport(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bttextsortsupport
;

comment on function pg_catalog.bttextsortsupport(internal)
is 'sort support';

create function pg_catalog.generate_series(numeric, numeric, numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.generate_series
;

comment on function pg_catalog.generate_series(numeric, numeric, numeric)
is 'non-persistent series generator';

create function pg_catalog.generate_series(numeric, numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.generate_series
;

comment on function pg_catalog.generate_series(numeric, numeric)
is 'non-persistent series generator';

create function pg_catalog.json_strip_nulls(json)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.json_strip_nulls
;

comment on function pg_catalog.json_strip_nulls(json)
is 'remove object fields with null values from json';

create function pg_catalog.jsonb_strip_nulls(jsonb)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_strip_nulls
;

comment on function pg_catalog.jsonb_strip_nulls(jsonb)
is 'remove object fields with null values from jsonb';

create function pg_catalog.jsonb_object(text [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_object
;

comment on function pg_catalog.jsonb_object(text [])
is 'map text array of key value pairs to jsonb object';

create function pg_catalog.jsonb_object(text [], text [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_object
;

comment on function pg_catalog.jsonb_object(text [], text [])
is 'map text array of key value pairs to jsonb object';

create function pg_catalog.jsonb_agg_transfn(internal, anyelement)
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_agg_transfn
;

comment on function pg_catalog.jsonb_agg_transfn(internal, anyelement)
is 'jsonb aggregate transition function';

create function pg_catalog.jsonb_agg_finalfn(internal)
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_agg_finalfn
;

comment on function pg_catalog.jsonb_agg_finalfn(internal)
is 'jsonb aggregate final function';

create function pg_catalog.jsonb_object_agg_transfn(internal, "any", "any")
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_object_agg_transfn
;

comment on function pg_catalog.jsonb_object_agg_transfn(internal, "any", "any")
is 'jsonb object aggregate transition function';

create function pg_catalog.jsonb_object_agg_finalfn(internal)
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_object_agg_finalfn
;

comment on function pg_catalog.jsonb_object_agg_finalfn(internal)
is 'jsonb object aggregate final function';

create function pg_catalog.jsonb_build_array("any")
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_build_array
;

comment on function pg_catalog.jsonb_build_array("any")
is 'build a jsonb array from any inputs';

create function pg_catalog.jsonb_build_array()
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_build_array
;

comment on function pg_catalog.jsonb_build_array()
is 'build an empty jsonb array';

create function pg_catalog.jsonb_build_object("any")
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_build_object
;

comment on function pg_catalog.jsonb_build_object("any")
is 'build a jsonb object from pairwise key/value inputs';

create function pg_catalog.jsonb_build_object()
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_build_object
;

comment on function pg_catalog.jsonb_build_object()
is 'build an empty jsonb object';

create function pg_catalog.dist_ppoly(point, polygon)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.dist_ppoly
;

comment on function pg_catalog.dist_ppoly(point, polygon)
is 'implementation of <-> operator';

create function pg_catalog.array_position(anyarray, anyelement)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_position
;

comment on function pg_catalog.array_position(anyarray, anyelement)
is 'returns an offset of value in array';

create function pg_catalog.array_position(anyarray, anyelement, integer)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_position
;

comment on function pg_catalog.array_position(anyarray, anyelement, integer)
is 'returns an offset of value in array with start index';

create function pg_catalog.array_positions(anyarray, anyelement)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_positions
;

comment on function pg_catalog.array_positions(anyarray, anyelement)
is 'returns an array of offsets of some value in array';

create function pg_catalog.gist_circle_distance(internal, circle, smallint, oid, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gist_circle_distance
;

comment on function pg_catalog.gist_circle_distance(internal, circle, smallint, oid, internal)
is 'GiST support';

create function pg_catalog.scale(numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.scale
;

comment on function pg_catalog.scale(numeric)
is 'number of decimal digits in the fractional part';

create function pg_catalog.gist_point_fetch(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gist_point_fetch
;

comment on function pg_catalog.gist_point_fetch(internal)
is 'GiST support';

create function pg_catalog.numeric_sortsupport(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_sortsupport
;

comment on function pg_catalog.numeric_sortsupport(internal)
is 'sort support';

create function pg_catalog.gist_poly_distance(internal, polygon, smallint, oid, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gist_poly_distance
;

comment on function pg_catalog.gist_poly_distance(internal, polygon, smallint, oid, internal)
is 'GiST support';

create function pg_catalog.dist_cpoint(circle, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.dist_cpoint
;

comment on function pg_catalog.dist_cpoint(circle, point)
is 'implementation of <-> operator';

create function pg_catalog.dist_polyp(polygon, point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.dist_polyp
;

comment on function pg_catalog.dist_polyp(polygon, point)
is 'implementation of <-> operator';

create function pg_catalog.pg_read_file(text, bigint, bigint, boolean)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_read_file
;

comment on function pg_catalog.pg_read_file(text, bigint, bigint, boolean)
is 'read text from a file';

create function pg_catalog.current_setting(text, boolean)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.current_setting
;

comment on function pg_catalog.current_setting(text, boolean)
is 'SHOW X as a function, optionally no error for missing variable';

create function pg_catalog.pg_read_binary_file(text, bigint, bigint, boolean)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_read_binary_file
;

comment on function pg_catalog.pg_read_binary_file(text, bigint, bigint, boolean)
is 'read bytea from a file';

create function pg_catalog.pg_notification_queue_usage()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_notification_queue_usage
;

comment on function pg_catalog.pg_notification_queue_usage()
is 'get the fraction of the asynchronous notification queue currently in use';

create function pg_catalog.pg_ls_dir(text, boolean, boolean)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_ls_dir
;

comment on function pg_catalog.pg_ls_dir(text, boolean, boolean)
is 'list all files in a directory';

create function pg_catalog.row_security_active(oid)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.row_security_active
;

comment on function pg_catalog.row_security_active(oid)
is 'row security for current context active on table by table oid';

create function pg_catalog.row_security_active(text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.row_security_active
;

comment on function pg_catalog.row_security_active(text)
is 'row security for current context active on table by table name';

create function pg_catalog.uuid_sortsupport(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.uuid_sortsupport
;

comment on function pg_catalog.uuid_sortsupport(internal)
is 'sort support';

create function pg_catalog.jsonb_concat(jsonb, jsonb)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_concat
;

comment on function pg_catalog.jsonb_concat(jsonb, jsonb)
is 'implementation of || operator';

create function pg_catalog.jsonb_delete(jsonb, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_delete
;

comment on function pg_catalog.jsonb_delete(jsonb, text)
is 'implementation of - operator';

create function pg_catalog.jsonb_delete(jsonb, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_delete
;

comment on function pg_catalog.jsonb_delete(jsonb, integer)
is 'implementation of - operator';

create function pg_catalog.jsonb_delete_path(jsonb, text [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_delete_path
;

comment on function pg_catalog.jsonb_delete_path(jsonb, text [])
is 'implementation of #- operator';

create function pg_catalog.jsonb_set(jsonb_in          jsonb, path text [], replacement jsonb,
                                     create_if_missing boolean default true)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_set
;

comment on function pg_catalog.jsonb_set(jsonb, text [], jsonb, boolean)
is 'Set part of a jsonb';

create function pg_catalog.jsonb_pretty(jsonb)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_pretty
;

comment on function pg_catalog.jsonb_pretty(jsonb)
is 'Indented text from jsonb';

create function pg_catalog.pg_stat_file(filename text, missing_ok boolean, out size bigint,
                                                                           out access timestamp with time zone,
                                                                           out modification timestamp with time zone,
                                                                           out change timestamp with time zone,
                                                                           out creation timestamp with time zone,
                                                                           out isdir boolean)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_file
;

comment on function pg_catalog.pg_stat_file(text, boolean, out bigint, out timestamp with time zone,
                                                           out timestamp with time zone, out timestamp with time zone,
                                                           out timestamp with time zone, out boolean)
is 'get information about file';

create function pg_catalog.xidneq(xid, xid)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.xidneq
;

comment on function pg_catalog.xidneq(xid, xid)
is 'implementation of <> operator';

create function pg_catalog.xidneqint4(xid, integer)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.xidneqint4
;

comment on function pg_catalog.xidneqint4(xid, integer)
is 'implementation of <> operator';

create function pg_catalog.tsm_handler_in(cstring)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsm_handler_in
;

comment on function pg_catalog.tsm_handler_in(cstring)
is 'I/O';

create function pg_catalog.tsm_handler_out(tsm_handler)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsm_handler_out
;

comment on function pg_catalog.tsm_handler_out(tsm_handler)
is 'I/O';

create function pg_catalog.bernoulli(internal)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bernoulli
;

comment on function pg_catalog.bernoulli(internal)
is 'BERNOULLI tablesample method handler';

create function pg_catalog.system(internal)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.system
;

comment on function pg_catalog.system(internal)
is 'SYSTEM tablesample method handler';

create function pg_catalog.pg_stat_get_wal_receiver(out pid                   integer, out status text,
                                                    out receive_start_lsn     pg_lsn, out receive_start_tli integer,
                                                    out received_lsn          pg_lsn, out received_tli integer,
                                                    out last_msg_send_time    timestamp with time zone,
                                                    out last_msg_receipt_time timestamp with time zone,
                                                    out latest_end_lsn        pg_lsn,
                                                    out latest_end_time       timestamp with time zone,
                                                    out slot_name             text, out sender_host text,
                                                    out sender_port           integer, out conninfo text)
stable
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_wal_receiver
;

comment on function pg_catalog.pg_stat_get_wal_receiver(out integer, out text, out pg_lsn, out integer, out pg_lsn,
                                                        out integer, out timestamp with time zone,
                                                        out timestamp with time zone, out pg_lsn,
                                                        out timestamp with time zone, out text, out text, out integer,
                                                        out text)
is 'statistics: information about WAL receiver';

create function pg_catalog.pg_stat_get_progress_info(cmdtype text, out pid integer, out datid oid, out relid oid,
                                                                   out param1 bigint, out param2 bigint,
                                                                   out param3 bigint, out param4 bigint,
                                                                   out param5 bigint, out param6 bigint,
                                                                   out param7 bigint, out param8 bigint,
                                                                   out param9 bigint, out param10 bigint)
stable
strict
parallel restricted
cost 1
rows 100
language internal
as
-- missing source code for pg_catalog.pg_stat_get_progress_info
;

comment on function pg_catalog.pg_stat_get_progress_info(text, out integer, out oid, out oid, out bigint, out bigint,
                                                               out bigint, out bigint, out bigint, out bigint,
                                                               out bigint, out bigint, out bigint, out bigint)
is 'statistics: information about progress of backends running maintenance command';

create function pg_catalog.ts_filter(tsvector, "char" [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ts_filter
;

comment on function pg_catalog.ts_filter(tsvector, "char" [])
is 'delete lexemes that do not have one of the given weights';

create function pg_catalog.setweight(tsvector, "char", text [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.setweight
;

comment on function pg_catalog.setweight(tsvector, "char", text [])
is 'set given weight for given lexemes';

create function pg_catalog.ts_delete(tsvector, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ts_delete
;

comment on function pg_catalog.ts_delete(tsvector, text)
is 'delete lexeme';

create function pg_catalog.unnest(tsvector tsvector, out lexeme text, out positions smallint [], out weights text [])
immutable
strict
parallel safe
cost 1
rows 10
language internal
as
-- missing source code for pg_catalog.unnest
;

comment on function pg_catalog.unnest(tsvector, out text, out smallint [], out text [])
is 'expand tsvector to set of rows';

create function pg_catalog.ts_delete(tsvector, text [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ts_delete
;

comment on function pg_catalog.ts_delete(tsvector, text [])
is 'delete given lexemes';

create function pg_catalog.int4_avg_combine(bigint [], bigint [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4_avg_combine
;

comment on function pg_catalog.int4_avg_combine(bigint [], bigint [])
is 'aggregate combine function';

create function pg_catalog.interval_combine(interval [], interval [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.interval_combine
;

comment on function pg_catalog.interval_combine(interval [], interval [])
is 'aggregate combine function';

create function pg_catalog.tsvector_to_array(tsvector)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsvector_to_array
;

comment on function pg_catalog.tsvector_to_array(tsvector)
is 'convert tsvector to array of lexemes';

create function pg_catalog.array_to_tsvector(text [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_to_tsvector
;

comment on function pg_catalog.array_to_tsvector(text [])
is 'build tsvector from array of lexemes';

create function pg_catalog.bpchar_sortsupport(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bpchar_sortsupport
;

comment on function pg_catalog.bpchar_sortsupport(internal)
is 'sort support';

create function pg_catalog.pg_show_all_file_settings(out sourcefile text, out sourceline integer, out seqno integer,
                                                     out name       text, out setting text, out applied boolean,
                                                     out error      text)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_show_all_file_settings
;

comment on function pg_catalog.pg_show_all_file_settings(out text, out integer, out integer, out text, out text,
                                                         out boolean, out text)
is 'show config file settings';

create function pg_catalog.pg_current_wal_flush_lsn()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_current_wal_flush_lsn
;

comment on function pg_catalog.pg_current_wal_flush_lsn()
is 'current wal flush location';

create function pg_catalog.bytea_sortsupport(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bytea_sortsupport
;

comment on function pg_catalog.bytea_sortsupport(internal)
is 'sort support';

create function pg_catalog.bttext_pattern_sortsupport(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bttext_pattern_sortsupport
;

comment on function pg_catalog.bttext_pattern_sortsupport(internal)
is 'sort support';

create function pg_catalog.btbpchar_pattern_sortsupport(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.btbpchar_pattern_sortsupport
;

comment on function pg_catalog.btbpchar_pattern_sortsupport(internal)
is 'sort support';

create function pg_catalog.pg_size_bytes(text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_size_bytes
;

comment on function pg_catalog.pg_size_bytes(text)
is 'convert a size in human-readable format with size units into bytes';

create function pg_catalog.numeric_serialize(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_serialize
;

comment on function pg_catalog.numeric_serialize(internal)
is 'aggregate serial function';

create function pg_catalog.numeric_deserialize(bytea, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_deserialize
;

comment on function pg_catalog.numeric_deserialize(bytea, internal)
is 'aggregate deserial function';

create function pg_catalog.numeric_avg_combine(internal, internal)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_avg_combine
;

comment on function pg_catalog.numeric_avg_combine(internal, internal)
is 'aggregate combine function';

create function pg_catalog.numeric_poly_combine(internal, internal)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_poly_combine
;

comment on function pg_catalog.numeric_poly_combine(internal, internal)
is 'aggregate combine function';

create function pg_catalog.numeric_poly_serialize(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_poly_serialize
;

comment on function pg_catalog.numeric_poly_serialize(internal)
is 'aggregate serial function';

create function pg_catalog.numeric_poly_deserialize(bytea, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_poly_deserialize
;

comment on function pg_catalog.numeric_poly_deserialize(bytea, internal)
is 'aggregate deserial function';

create function pg_catalog.numeric_combine(internal, internal)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_combine
;

comment on function pg_catalog.numeric_combine(internal, internal)
is 'aggregate combine function';

create function pg_catalog.float8_regr_combine(double precision [], double precision [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float8_regr_combine
;

comment on function pg_catalog.float8_regr_combine(double precision [], double precision [])
is 'aggregate combine function';

create function pg_catalog.jsonb_delete(from_json jsonb, path_elems text [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_delete
;

comment on function pg_catalog.jsonb_delete(jsonb, text [])
is 'implementation of - operator';

create function pg_catalog.cash_mul_int8(money, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cash_mul_int8
;

comment on function pg_catalog.cash_mul_int8(money, bigint)
is 'implementation of * operator';

create function pg_catalog.cash_div_int8(money, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cash_div_int8
;

comment on function pg_catalog.cash_div_int8(money, bigint)
is 'implementation of / operator';

create function pg_catalog.txid_current_if_assigned()
stable
strict
cost 1
language internal
as
-- missing source code for pg_catalog.txid_current_if_assigned
;

comment on function pg_catalog.txid_current_if_assigned()
is 'get current transaction ID';

create function pg_catalog.pg_get_partkeydef(oid)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_get_partkeydef
;

comment on function pg_catalog.pg_get_partkeydef(oid)
is 'partition key description';

create function pg_catalog.pg_ls_logdir(out name text, out size bigint, out modification timestamp with time zone)
strict
parallel safe
cost 10
rows 20
language internal
as
-- missing source code for pg_catalog.pg_ls_logdir
;

comment on function pg_catalog.pg_ls_logdir(out text, out bigint, out timestamp with time zone)
is 'list files in the log directory';

create function pg_catalog.pg_ls_waldir(out name text, out size bigint, out modification timestamp with time zone)
strict
parallel safe
cost 10
rows 20
language internal
as
-- missing source code for pg_catalog.pg_ls_waldir
;

comment on function pg_catalog.pg_ls_waldir(out text, out bigint, out timestamp with time zone)
is 'list of files in the WAL directory';

create function pg_catalog.pg_ndistinct_in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_ndistinct_in
;

comment on function pg_catalog.pg_ndistinct_in(cstring)
is 'I/O';

create function pg_catalog.pg_ndistinct_out(pg_ndistinct)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_ndistinct_out
;

comment on function pg_catalog.pg_ndistinct_out(pg_ndistinct)
is 'I/O';

create function pg_catalog.pg_ndistinct_recv(internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_ndistinct_recv
;

comment on function pg_catalog.pg_ndistinct_recv(internal)
is 'I/O';

create function pg_catalog.pg_ndistinct_send(pg_ndistinct)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_ndistinct_send
;

comment on function pg_catalog.pg_ndistinct_send(pg_ndistinct)
is 'I/O';

create function pg_catalog.macaddr_sortsupport(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr_sortsupport
;

comment on function pg_catalog.macaddr_sortsupport(internal)
is 'sort support';

create function pg_catalog.txid_status(bigint)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.txid_status
;

comment on function pg_catalog.txid_status(bigint)
is 'commit status of transaction';

create function pg_catalog.pg_safe_snapshot_blocking_pids(integer)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_safe_snapshot_blocking_pids
;

comment on function pg_catalog.pg_safe_snapshot_blocking_pids(integer)
is 'get array of PIDs of sessions blocking specified backend PID from acquiring a safe snapshot';

create function pg_catalog.pg_isolation_test_session_is_blocked(integer, integer [])
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_isolation_test_session_is_blocked
;

comment on function pg_catalog.pg_isolation_test_session_is_blocked(integer, integer [])
is 'isolationtester support function';

create function pg_catalog.pg_identify_object_as_address(classid oid, objid oid, objsubid integer, out type text,
                                                                                                   out object_names text [],
                                                                                                   out object_args text [])
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_identify_object_as_address
;

comment on function pg_catalog.pg_identify_object_as_address(oid, oid, integer, out text, out text [], out text [])
is 'get identification of SQL object for pg_get_object_address()';

create function pg_catalog.brin_minmax_opcinfo(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.brin_minmax_opcinfo
;

comment on function pg_catalog.brin_minmax_opcinfo(internal)
is 'BRIN minmax support';

create function pg_catalog.brin_minmax_add_value(internal, internal, internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.brin_minmax_add_value
;

comment on function pg_catalog.brin_minmax_add_value(internal, internal, internal, internal)
is 'BRIN minmax support';

create function pg_catalog.brin_minmax_consistent(internal, internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.brin_minmax_consistent
;

comment on function pg_catalog.brin_minmax_consistent(internal, internal, internal)
is 'BRIN minmax support';

create function pg_catalog.brin_minmax_union(internal, internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.brin_minmax_union
;

comment on function pg_catalog.brin_minmax_union(internal, internal, internal)
is 'BRIN minmax support';

create function pg_catalog.int8_avg_accum_inv(internal, bigint)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8_avg_accum_inv
;

comment on function pg_catalog.int8_avg_accum_inv(internal, bigint)
is 'aggregate transition function';

create function pg_catalog.numeric_poly_sum(internal)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_poly_sum
;

comment on function pg_catalog.numeric_poly_sum(internal)
is 'aggregate final function';

create function pg_catalog.numeric_poly_avg(internal)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_poly_avg
;

comment on function pg_catalog.numeric_poly_avg(internal)
is 'aggregate final function';

create function pg_catalog.numeric_poly_var_pop(internal)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_poly_var_pop
;

comment on function pg_catalog.numeric_poly_var_pop(internal)
is 'aggregate final function';

create function pg_catalog.numeric_poly_var_samp(internal)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_poly_var_samp
;

comment on function pg_catalog.numeric_poly_var_samp(internal)
is 'aggregate final function';

create function pg_catalog.numeric_poly_stddev_pop(internal)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_poly_stddev_pop
;

comment on function pg_catalog.numeric_poly_stddev_pop(internal)
is 'aggregate final function';

create function pg_catalog.numeric_poly_stddev_samp(internal)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_poly_stddev_samp
;

comment on function pg_catalog.numeric_poly_stddev_samp(internal)
is 'aggregate final function';

create function pg_catalog.regexp_match(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regexp_match
;

comment on function pg_catalog.regexp_match(text, text)
is 'find first match for regexp';

create function pg_catalog.regexp_match(text, text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regexp_match
;

comment on function pg_catalog.regexp_match(text, text, text)
is 'find first match for regexp';

create function pg_catalog.int8_mul_cash(bigint, money)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8_mul_cash
;

comment on function pg_catalog.int8_mul_cash(bigint, money)
is 'implementation of * operator';

create function pg_catalog.pg_config(out name text, out setting text)
immutable
strict
parallel restricted
cost 1
rows 23
language internal
as
-- missing source code for pg_catalog.pg_config
;

comment on function pg_catalog.pg_config(out text, out text)
is 'pg_config binary as a function';

create function pg_catalog.pg_hba_file_rules(out line_number integer, out type text, out database text [],
                                             out user_name   text [], out address text, out netmask text,
                                             out auth_method text, out options text [], out error text)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_hba_file_rules
;

comment on function pg_catalog.pg_hba_file_rules(out integer, out text, out text [], out text [], out text, out text,
                                                 out text, out text [], out text)
is 'show pg_hba.conf rules';

create function pg_catalog.pg_statistics_obj_is_visible(oid)
stable
strict
parallel safe
cost 10
language internal
as
-- missing source code for pg_catalog.pg_statistics_obj_is_visible
;

comment on function pg_catalog.pg_statistics_obj_is_visible(oid)
is 'is statistics object visible in search path?';

create function pg_catalog.pg_dependencies_in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_dependencies_in
;

comment on function pg_catalog.pg_dependencies_in(cstring)
is 'I/O';

create function pg_catalog.pg_dependencies_out(pg_dependencies)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_dependencies_out
;

comment on function pg_catalog.pg_dependencies_out(pg_dependencies)
is 'I/O';

create function pg_catalog.pg_dependencies_recv(internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_dependencies_recv
;

comment on function pg_catalog.pg_dependencies_recv(internal)
is 'I/O';

create function pg_catalog.pg_dependencies_send(pg_dependencies)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_dependencies_send
;

comment on function pg_catalog.pg_dependencies_send(pg_dependencies)
is 'I/O';

create function pg_catalog.pg_get_partition_constraintdef(oid)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_get_partition_constraintdef
;

comment on function pg_catalog.pg_get_partition_constraintdef(oid)
is 'partition constraint description';

create function pg_catalog.time_hash_extended(time, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.time_hash_extended
;

comment on function pg_catalog.time_hash_extended(time, bigint)
is 'hash';

create function pg_catalog.timetz_hash_extended(time with time zone, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timetz_hash_extended
;

comment on function pg_catalog.timetz_hash_extended(time with time zone, bigint)
is 'hash';

create function pg_catalog.timestamp_hash_extended(timestamp, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_hash_extended
;

comment on function pg_catalog.timestamp_hash_extended(timestamp, bigint)
is 'hash';

create function pg_catalog.uuid_hash_extended(uuid, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.uuid_hash_extended
;

comment on function pg_catalog.uuid_hash_extended(uuid, bigint)
is 'hash';

create function pg_catalog.pg_lsn_hash_extended(pg_lsn, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_lsn_hash_extended
;

comment on function pg_catalog.pg_lsn_hash_extended(pg_lsn, bigint)
is 'hash';

create function pg_catalog.hashenumextended(anyenum, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hashenumextended
;

comment on function pg_catalog.hashenumextended(anyenum, bigint)
is 'hash';

create function pg_catalog.pg_get_statisticsobjdef(oid)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_get_statisticsobjdef
;

comment on function pg_catalog.pg_get_statisticsobjdef(oid)
is 'extended statistics object description';

create function pg_catalog.jsonb_hash_extended(jsonb, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_hash_extended
;

comment on function pg_catalog.jsonb_hash_extended(jsonb, bigint)
is 'hash';

create function pg_catalog.hash_range_extended(anyrange, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hash_range_extended
;

comment on function pg_catalog.hash_range_extended(anyrange, bigint)
is 'hash a range';

create function pg_catalog.interval_hash_extended(interval, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.interval_hash_extended
;

comment on function pg_catalog.interval_hash_extended(interval, bigint)
is 'hash';

create function pg_catalog.sha224(bytea)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.sha224
;

comment on function pg_catalog.sha224(bytea)
is 'SHA-224 hash';

create function pg_catalog.sha256(bytea)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.sha256
;

comment on function pg_catalog.sha256(bytea)
is 'SHA-256 hash';

create function pg_catalog.sha384(bytea)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.sha384
;

comment on function pg_catalog.sha384(bytea)
is 'SHA-384 hash';

create function pg_catalog.sha512(bytea)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.sha512
;

comment on function pg_catalog.sha512(bytea)
is 'SHA-512 hash';

create function pg_catalog.prefixsel(internal, oid, internal, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.prefixsel
;

comment on function pg_catalog.prefixsel(internal, oid, internal, integer)
is 'restriction selectivity of exact prefix';

create function pg_catalog.prefixjoinsel(internal, oid, internal, smallint, internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.prefixjoinsel
;

comment on function pg_catalog.prefixjoinsel(internal, oid, internal, smallint, internal)
is 'join selectivity of exact prefix';

create function pg_catalog.pg_control_system(out pg_control_version       integer, out catalog_version_no integer,
                                             out system_identifier        bigint,
                                             out pg_control_last_modified timestamp with time zone)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_control_system
;

comment on function pg_catalog.pg_control_system(out integer, out integer, out bigint, out timestamp with time zone)
is 'pg_controldata general state information as a function';

create function pg_catalog.pg_control_checkpoint(out checkpoint_lsn       pg_lsn, out redo_lsn pg_lsn,
                                                 out redo_wal_file        text, out timeline_id integer,
                                                 out prev_timeline_id     integer, out full_page_writes boolean,
                                                 out next_xid             text, out next_oid oid,
                                                 out next_multixact_id    xid, out next_multi_offset xid,
                                                 out oldest_xid           xid, out oldest_xid_dbid oid,
                                                 out oldest_active_xid    xid, out oldest_multi_xid xid,
                                                 out oldest_multi_dbid    oid, out oldest_commit_ts_xid xid,
                                                 out newest_commit_ts_xid xid,
                                                 out checkpoint_time      timestamp with time zone)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_control_checkpoint
;

comment on function pg_catalog.pg_control_checkpoint(out pg_lsn, out pg_lsn, out text, out integer, out integer,
                                                     out boolean, out text, out oid, out xid, out xid, out xid, out oid,
                                                     out xid, out xid, out oid, out xid, out xid,
                                                     out timestamp with time zone)
is 'pg_controldata checkpoint state information as a function';

create function pg_catalog.pg_control_recovery(out min_recovery_end_lsn          pg_lsn,
                                               out min_recovery_end_timeline     integer, out backup_start_lsn pg_lsn,
                                               out backup_end_lsn                pg_lsn,
                                               out end_of_backup_record_required boolean)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_control_recovery
;

comment on function pg_catalog.pg_control_recovery(out pg_lsn, out integer, out pg_lsn, out pg_lsn, out boolean)
is 'pg_controldata recovery state information as a function';

create function pg_catalog.pg_control_init(out max_data_alignment      integer, out database_block_size integer,
                                           out blocks_per_segment      integer, out wal_block_size integer,
                                           out bytes_per_wal_segment   integer, out max_identifier_length integer,
                                           out max_index_columns       integer, out max_toast_chunk_size integer,
                                           out large_object_chunk_size integer, out float4_pass_by_value boolean,
                                           out float8_pass_by_value    boolean, out data_page_checksum_version integer)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_control_init
;

comment on function pg_catalog.pg_control_init(out integer, out integer, out integer, out integer, out integer,
                                               out integer, out integer, out integer, out integer, out boolean,
                                               out boolean, out integer)
is 'pg_controldata init state information as a function';

create function pg_catalog.pg_import_system_collations(regnamespace)
strict
language internal
as
-- missing source code for pg_catalog.pg_import_system_collations
;

comment on function pg_catalog.pg_import_system_collations(regnamespace)
is 'import collations from operating system';

create function pg_catalog.macaddr8_recv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr8_recv
;

comment on function pg_catalog.macaddr8_recv(internal)
is 'I/O';

create function pg_catalog.macaddr8_send(macaddr8)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr8_send
;

comment on function pg_catalog.macaddr8_send(macaddr8)
is 'I/O';

create function pg_catalog.pg_collation_actual_version(oid)
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.pg_collation_actual_version
;

comment on function pg_catalog.pg_collation_actual_version(oid)
is 'get actual version of collation from operating system';

create function pg_catalog.numeric(jsonb)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric
;

comment on function pg_catalog.numeric(jsonb)
is 'convert jsonb to numeric';

create function pg_catalog.int2(jsonb)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2
;

comment on function pg_catalog.int2(jsonb)
is 'convert jsonb to int2';

create function pg_catalog.int4(jsonb)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4
;

comment on function pg_catalog.int4(jsonb)
is 'convert jsonb to int4';

create function pg_catalog.int8(jsonb)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8
;

comment on function pg_catalog.int8(jsonb)
is 'convert jsonb to int8';

create function pg_catalog.float4(jsonb)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.float4
;

comment on function pg_catalog.float4(jsonb)
is 'convert jsonb to float4';

create function pg_catalog.pg_filenode_relation(oid, oid)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_filenode_relation
;

comment on function pg_catalog.pg_filenode_relation(oid, oid)
is 'relation OID for filenode and tablespace';

create function pg_catalog.lo_from_bytea(oid, bytea)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.lo_from_bytea
;

comment on function pg_catalog.lo_from_bytea(oid, bytea)
is 'create new large object with given content';

create function pg_catalog.lo_get(oid)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.lo_get
;

comment on function pg_catalog.lo_get(oid)
is 'read entire large object';

create function pg_catalog.lo_get(oid, bigint, integer)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.lo_get
;

comment on function pg_catalog.lo_get(oid, bigint, integer)
is 'read large object from offset for length';

create function pg_catalog.lo_put(oid, bigint, bytea)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.lo_put
;

comment on function pg_catalog.lo_put(oid, bigint, bytea)
is 'write data at offset';

create function pg_catalog.make_timestamp(year integer, month integer, mday integer, hour integer, min integer,
                                          sec  double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.make_timestamp
;

comment on function pg_catalog.make_timestamp(integer, integer, integer, integer, integer, double precision)
is 'construct timestamp';

create function pg_catalog.make_timestamptz(year integer, month integer, mday integer, hour integer, min integer,
                                            sec  double precision)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.make_timestamptz
;

comment on function pg_catalog.make_timestamptz(integer, integer, integer, integer, integer, double precision)
is 'construct timestamp with time zone';

create function pg_catalog.make_timestamptz(year integer, month integer, mday integer, hour integer, min integer,
                                            sec  double precision, timezone text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.make_timestamptz
;

comment on function pg_catalog.make_timestamptz(integer, integer, integer, integer, integer, double precision, text)
is 'construct timestamp with time zone';

create function pg_catalog.make_interval(years integer default 0, months integer default 0, weeks integer default 0,
                                         days  integer default 0, hours integer default 0, mins integer default 0,
                                         secs  double precision default 0.0)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.make_interval
;

comment on function pg_catalog.make_interval(integer, integer, integer, integer, integer, integer, double precision)
is 'construct interval';

create function pg_catalog.jsonb_array_elements_text(from_json jsonb, out value text)
immutable
strict
parallel safe
cost 1
rows 100
language internal
as
-- missing source code for pg_catalog.jsonb_array_elements_text
;

comment on function pg_catalog.jsonb_array_elements_text(jsonb, out text)
is 'elements of jsonb array';

create function pg_catalog.spg_range_quad_config(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.spg_range_quad_config
;

comment on function pg_catalog.spg_range_quad_config(internal, internal)
is 'SP-GiST support for quad tree over range';

create function pg_catalog.spg_range_quad_choose(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.spg_range_quad_choose
;

comment on function pg_catalog.spg_range_quad_choose(internal, internal)
is 'SP-GiST support for quad tree over range';

create function pg_catalog.spg_range_quad_picksplit(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.spg_range_quad_picksplit
;

comment on function pg_catalog.spg_range_quad_picksplit(internal, internal)
is 'SP-GiST support for quad tree over range';

create function pg_catalog.spg_range_quad_inner_consistent(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.spg_range_quad_inner_consistent
;

comment on function pg_catalog.spg_range_quad_inner_consistent(internal, internal)
is 'SP-GiST support for quad tree over range';

create function pg_catalog.spg_range_quad_leaf_consistent(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.spg_range_quad_leaf_consistent
;

comment on function pg_catalog.spg_range_quad_leaf_consistent(internal, internal)
is 'SP-GiST support for quad tree over range';

create function pg_catalog.jsonb_populate_recordset(anyelement, jsonb)
stable
parallel safe
cost 1
rows 100
language internal
as
-- missing source code for pg_catalog.jsonb_populate_recordset
;

comment on function pg_catalog.jsonb_populate_recordset(anyelement, jsonb)
is 'get set of records with fields from a jsonb array of objects';

create function pg_catalog.to_regoperator(text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.to_regoperator
;

comment on function pg_catalog.to_regoperator(text)
is 'convert operator name to regoperator';

create function pg_catalog.jsonb_object_field(from_json jsonb, field_name text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_object_field
;

comment on function pg_catalog.jsonb_object_field(jsonb, text)
is 'implementation of -> operator';

create function pg_catalog.to_regprocedure(text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.to_regprocedure
;

comment on function pg_catalog.to_regprocedure(text)
is 'convert proname to regprocedure';

create function pg_catalog.gin_compare_jsonb(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gin_compare_jsonb
;

comment on function pg_catalog.gin_compare_jsonb(text, text)
is 'GIN support';

create function pg_catalog.gin_extract_jsonb(jsonb, internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gin_extract_jsonb
;

comment on function pg_catalog.gin_extract_jsonb(jsonb, internal, internal)
is 'GIN support';

create function pg_catalog.gin_extract_jsonb_query(jsonb, internal, smallint, internal, internal, internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gin_extract_jsonb_query
;

comment on function pg_catalog.gin_extract_jsonb_query(jsonb, internal, smallint, internal, internal, internal,
                                                       internal)
is 'GIN support';

create function pg_catalog.gin_consistent_jsonb(internal, smallint, jsonb, integer, internal, internal, internal,
                                                internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gin_consistent_jsonb
;

comment on function pg_catalog.gin_consistent_jsonb(internal, smallint, jsonb, integer, internal, internal, internal,
                                                    internal)
is 'GIN support';

create function pg_catalog.gin_extract_jsonb_path(jsonb, internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gin_extract_jsonb_path
;

comment on function pg_catalog.gin_extract_jsonb_path(jsonb, internal, internal)
is 'GIN support';

create function pg_catalog.gin_extract_jsonb_query_path(jsonb, internal, smallint, internal, internal, internal,
                                                        internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gin_extract_jsonb_query_path
;

comment on function pg_catalog.gin_extract_jsonb_query_path(jsonb, internal, smallint, internal, internal, internal,
                                                            internal)
is 'GIN support';

create function pg_catalog.gin_consistent_jsonb_path(internal, smallint, jsonb, integer, internal, internal, internal,
                                                     internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gin_consistent_jsonb_path
;

comment on function pg_catalog.gin_consistent_jsonb_path(internal, smallint, jsonb, integer, internal, internal,
                                                         internal, internal)
is 'GIN support';

create function pg_catalog.gin_triconsistent_jsonb(internal, smallint, jsonb, integer, internal, internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gin_triconsistent_jsonb
;

comment on function pg_catalog.gin_triconsistent_jsonb(internal, smallint, jsonb, integer, internal, internal, internal)
is 'GIN support';

create function pg_catalog.gin_triconsistent_jsonb_path(internal, smallint, jsonb, integer, internal, internal,
                                                        internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gin_triconsistent_jsonb_path
;

comment on function pg_catalog.gin_triconsistent_jsonb_path(internal, smallint, jsonb, integer, internal, internal,
                                                            internal)
is 'GIN support';

create function pg_catalog.jsonb_to_record(jsonb)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_to_record
;

comment on function pg_catalog.jsonb_to_record(jsonb)
is 'get record fields from a jsonb object';

create function pg_catalog.jsonb_to_recordset(jsonb)
stable
parallel safe
cost 1
rows 100
language internal
as
-- missing source code for pg_catalog.jsonb_to_recordset
;

comment on function pg_catalog.jsonb_to_recordset(jsonb)
is 'get set of records with fields from a jsonb array of objects';

create function pg_catalog.to_regoper(text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.to_regoper
;

comment on function pg_catalog.to_regoper(text)
is 'convert operator name to regoper';

create function pg_catalog.to_regtype(text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.to_regtype
;

comment on function pg_catalog.to_regtype(text)
is 'convert type name to regtype';

create function pg_catalog.to_regproc(text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.to_regproc
;

comment on function pg_catalog.to_regproc(text)
is 'convert proname to regproc';

create function pg_catalog.to_regclass(text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.to_regclass
;

comment on function pg_catalog.to_regclass(text)
is 'convert classname to regclass';

create function pg_catalog.bool_accum(internal, boolean)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bool_accum
;

comment on function pg_catalog.bool_accum(internal, boolean)
is 'aggregate transition function';

create function pg_catalog.bool_accum_inv(internal, boolean)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bool_accum_inv
;

comment on function pg_catalog.bool_accum_inv(internal, boolean)
is 'aggregate transition function';

create function pg_catalog.bool_alltrue(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bool_alltrue
;

comment on function pg_catalog.bool_alltrue(internal)
is 'aggregate final function';

create function pg_catalog.bool_anytrue(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bool_anytrue
;

comment on function pg_catalog.bool_anytrue(internal)
is 'aggregate final function';

create function pg_catalog.anyenum_in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.anyenum_in
;

comment on function pg_catalog.anyenum_in(cstring)
is 'I/O';

create function pg_catalog.anyenum_out(anyenum)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.anyenum_out
;

comment on function pg_catalog.anyenum_out(anyenum)
is 'I/O';

create function pg_catalog.enum_in(cstring, oid)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.enum_in
;

comment on function pg_catalog.enum_in(cstring, oid)
is 'I/O';

create function pg_catalog.enum_out(anyenum)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.enum_out
;

comment on function pg_catalog.enum_out(anyenum)
is 'I/O';

create function pg_catalog.enum_eq(anyenum, anyenum)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.enum_eq
;

comment on function pg_catalog.enum_eq(anyenum, anyenum)
is 'implementation of = operator';

create function pg_catalog.enum_ne(anyenum, anyenum)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.enum_ne
;

comment on function pg_catalog.enum_ne(anyenum, anyenum)
is 'implementation of <> operator';

create function pg_catalog.enum_lt(anyenum, anyenum)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.enum_lt
;

comment on function pg_catalog.enum_lt(anyenum, anyenum)
is 'implementation of < operator';

create function pg_catalog.enum_gt(anyenum, anyenum)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.enum_gt
;

comment on function pg_catalog.enum_gt(anyenum, anyenum)
is 'implementation of > operator';

create function pg_catalog.enum_le(anyenum, anyenum)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.enum_le
;

comment on function pg_catalog.enum_le(anyenum, anyenum)
is 'implementation of <= operator';

create function pg_catalog.enum_ge(anyenum, anyenum)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.enum_ge
;

comment on function pg_catalog.enum_ge(anyenum, anyenum)
is 'implementation of >= operator';

create function pg_catalog.enum_cmp(anyenum, anyenum)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.enum_cmp
;

comment on function pg_catalog.enum_cmp(anyenum, anyenum)
is 'less-equal-greater';

create function pg_catalog.hashenum(anyenum)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hashenum
;

comment on function pg_catalog.hashenum(anyenum)
is 'hash';

create function pg_catalog.enum_smaller(anyenum, anyenum)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.enum_smaller
;

comment on function pg_catalog.enum_smaller(anyenum, anyenum)
is 'smaller of two';

create function pg_catalog.enum_larger(anyenum, anyenum)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.enum_larger
;

comment on function pg_catalog.enum_larger(anyenum, anyenum)
is 'larger of two';

create function pg_catalog.enum_first(anyenum)
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.enum_first
;

comment on function pg_catalog.enum_first(anyenum)
is 'first value of the input enum type';

create function pg_catalog.enum_last(anyenum)
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.enum_last
;

comment on function pg_catalog.enum_last(anyenum)
is 'last value of the input enum type';

create function pg_catalog.enum_range(anyenum, anyenum)
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.enum_range
;

comment on function pg_catalog.enum_range(anyenum, anyenum)
is 'range between the two given enum values, as an ordered array';

create function pg_catalog.enum_range(anyenum)
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.enum_range
;

comment on function pg_catalog.enum_range(anyenum)
is 'range of the given enum type, as an ordered array';

create function pg_catalog.enum_recv(internal, oid)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.enum_recv
;

comment on function pg_catalog.enum_recv(internal, oid)
is 'I/O';

create function pg_catalog.enum_send(anyenum)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.enum_send
;

comment on function pg_catalog.enum_send(anyenum)
is 'I/O';

create function pg_catalog.string_agg_transfn(internal, text, text)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.string_agg_transfn
;

comment on function pg_catalog.string_agg_transfn(internal, text, text)
is 'aggregate transition function';

create function pg_catalog.string_agg_finalfn(internal)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.string_agg_finalfn
;

comment on function pg_catalog.string_agg_finalfn(internal)
is 'aggregate final function';

create function pg_catalog.pg_describe_object(oid, oid, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_describe_object
;

comment on function pg_catalog.pg_describe_object(oid, oid, integer)
is 'get identification of SQL object';

create function pg_catalog.format(text, "any")
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.format
;

comment on function pg_catalog.format(text, "any")
is 'format text message';

create function pg_catalog.format(text)
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.format
;

comment on function pg_catalog.format(text)
is 'format text message';

create function pg_catalog.bytea_string_agg_transfn(internal, bytea, bytea)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bytea_string_agg_transfn
;

comment on function pg_catalog.bytea_string_agg_transfn(internal, bytea, bytea)
is 'aggregate transition function';

create function pg_catalog.bytea_string_agg_finalfn(internal)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bytea_string_agg_finalfn
;

comment on function pg_catalog.bytea_string_agg_finalfn(internal)
is 'aggregate final function';

create function pg_catalog.int8dec(bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8dec
;

comment on function pg_catalog.int8dec(bigint)
is 'decrement';

create function pg_catalog.int8dec_any(bigint, "any")
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8dec_any
;

comment on function pg_catalog.int8dec_any(bigint, "any")
is 'decrement, ignores second argument';

create function pg_catalog.numeric_accum_inv(internal, numeric)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric_accum_inv
;

comment on function pg_catalog.numeric_accum_inv(internal, numeric)
is 'aggregate transition function';

create function pg_catalog.interval_accum_inv(interval [], interval)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.interval_accum_inv
;

comment on function pg_catalog.interval_accum_inv(interval [], interval)
is 'aggregate transition function';

create function pg_catalog.network_overlap(inet, inet)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.network_overlap
;

comment on function pg_catalog.network_overlap(inet, inet)
is 'implementation of && operator';

create function pg_catalog.inet_gist_consistent(internal, inet, smallint, oid, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inet_gist_consistent
;

comment on function pg_catalog.inet_gist_consistent(internal, inet, smallint, oid, internal)
is 'GiST support';

create function pg_catalog.inet_gist_union(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inet_gist_union
;

comment on function pg_catalog.inet_gist_union(internal, internal)
is 'GiST support';

create function pg_catalog.inet_gist_compress(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inet_gist_compress
;

comment on function pg_catalog.inet_gist_compress(internal)
is 'GiST support';

create function pg_catalog.bool(jsonb)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bool
;

comment on function pg_catalog.bool(jsonb)
is 'convert jsonb to boolean';

create function pg_catalog.inet_gist_penalty(internal, internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inet_gist_penalty
;

comment on function pg_catalog.inet_gist_penalty(internal, internal, internal)
is 'GiST support';

create function pg_catalog.inet_gist_picksplit(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inet_gist_picksplit
;

comment on function pg_catalog.inet_gist_picksplit(internal, internal)
is 'GiST support';

create function pg_catalog.inet_gist_same(inet, inet, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inet_gist_same
;

comment on function pg_catalog.inet_gist_same(inet, inet, internal)
is 'GiST support';

create function pg_catalog.networksel(internal, oid, internal, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.networksel
;

comment on function pg_catalog.networksel(internal, oid, internal, integer)
is 'restriction selectivity for network operators';

create function pg_catalog.networkjoinsel(internal, oid, internal, smallint, internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.networkjoinsel
;

comment on function pg_catalog.networkjoinsel(internal, oid, internal, smallint, internal)
is 'join selectivity for network operators';

create function pg_catalog.network_larger(inet, inet)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.network_larger
;

comment on function pg_catalog.network_larger(inet, inet)
is 'larger of two';

create function pg_catalog.network_smaller(inet, inet)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.network_smaller
;

comment on function pg_catalog.network_smaller(inet, inet)
is 'smaller of two';

create function pg_catalog.pg_event_trigger_dropped_objects(out classid         oid, out objid oid,
                                                            out objsubid        integer, out original boolean,
                                                            out normal          boolean, out is_temporary boolean,
                                                            out object_type     text, out schema_name text,
                                                            out object_name     text, out object_identity text,
                                                            out address_names   text [], out address_args text [])
stable
strict
parallel restricted
cost 10
rows 100
language internal
as
-- missing source code for pg_catalog.pg_event_trigger_dropped_objects
;

comment on function pg_catalog.pg_event_trigger_dropped_objects(out oid, out oid, out integer, out boolean, out boolean,
                                                                out boolean, out text, out text, out text, out text,
                                                                out text [], out text [])
is 'list objects dropped by the current command';

create function pg_catalog.int2_accum_inv(internal, smallint)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2_accum_inv
;

comment on function pg_catalog.int2_accum_inv(internal, smallint)
is 'aggregate transition function';

create function pg_catalog.int4_accum_inv(internal, integer)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4_accum_inv
;

comment on function pg_catalog.int4_accum_inv(internal, integer)
is 'aggregate transition function';

create function pg_catalog.int8_accum_inv(internal, bigint)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8_accum_inv
;

comment on function pg_catalog.int8_accum_inv(internal, bigint)
is 'aggregate transition function';

create function pg_catalog.int2_avg_accum_inv(bigint [], smallint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2_avg_accum_inv
;

comment on function pg_catalog.int2_avg_accum_inv(bigint [], smallint)
is 'aggregate transition function';

create function pg_catalog.int4_avg_accum_inv(bigint [], integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4_avg_accum_inv
;

comment on function pg_catalog.int4_avg_accum_inv(bigint [], integer)
is 'aggregate transition function';

create function pg_catalog.int2int4_sum(bigint [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int2int4_sum
;

comment on function pg_catalog.int2int4_sum(bigint [])
is 'aggregate final function';

create function pg_catalog.inet_gist_fetch(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inet_gist_fetch
;

comment on function pg_catalog.inet_gist_fetch(internal)
is 'GiST support';

create function pg_catalog.pg_logical_emit_message(boolean, text, text)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_logical_emit_message
;

comment on function pg_catalog.pg_logical_emit_message(boolean, text, text)
is 'emit a textual logical decoding message';

create function pg_catalog.pg_logical_emit_message(boolean, text, bytea)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_logical_emit_message
;

comment on function pg_catalog.pg_logical_emit_message(boolean, text, bytea)
is 'emit a binary logical decoding message';

create function pg_catalog.jsonb_insert(jsonb_in     jsonb, path text [], replacement jsonb,
                                        insert_after boolean default false)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_insert
;

comment on function pg_catalog.jsonb_insert(jsonb, text [], jsonb, boolean)
is 'Insert value into a jsonb';

create function pg_catalog.pg_xact_commit_timestamp(xid)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_xact_commit_timestamp
;

comment on function pg_catalog.pg_xact_commit_timestamp(xid)
is 'get commit timestamp of a transaction';

create function pg_catalog.binary_upgrade_set_next_pg_type_oid(oid)
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.binary_upgrade_set_next_pg_type_oid
;

comment on function pg_catalog.binary_upgrade_set_next_pg_type_oid(oid)
is 'for use by pg_upgrade';

create function pg_catalog.pg_last_committed_xact(out xid xid, out timestamp timestamp with time zone)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_last_committed_xact
;

comment on function pg_catalog.pg_last_committed_xact(out xid, out timestamp with time zone)
is 'get transaction Id and commit timestamp of latest transaction commit';

create function pg_catalog.binary_upgrade_set_next_array_pg_type_oid(oid)
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.binary_upgrade_set_next_array_pg_type_oid
;

comment on function pg_catalog.binary_upgrade_set_next_array_pg_type_oid(oid)
is 'for use by pg_upgrade';

create function pg_catalog.binary_upgrade_set_next_toast_pg_type_oid(oid)
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.binary_upgrade_set_next_toast_pg_type_oid
;

comment on function pg_catalog.binary_upgrade_set_next_toast_pg_type_oid(oid)
is 'for use by pg_upgrade';

create function pg_catalog.binary_upgrade_set_next_heap_pg_class_oid(oid)
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.binary_upgrade_set_next_heap_pg_class_oid
;

comment on function pg_catalog.binary_upgrade_set_next_heap_pg_class_oid(oid)
is 'for use by pg_upgrade';

create function pg_catalog.binary_upgrade_set_next_index_pg_class_oid(oid)
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.binary_upgrade_set_next_index_pg_class_oid
;

comment on function pg_catalog.binary_upgrade_set_next_index_pg_class_oid(oid)
is 'for use by pg_upgrade';

create function pg_catalog.binary_upgrade_set_next_toast_pg_class_oid(oid)
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.binary_upgrade_set_next_toast_pg_class_oid
;

comment on function pg_catalog.binary_upgrade_set_next_toast_pg_class_oid(oid)
is 'for use by pg_upgrade';

create function pg_catalog.binary_upgrade_set_next_pg_enum_oid(oid)
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.binary_upgrade_set_next_pg_enum_oid
;

comment on function pg_catalog.binary_upgrade_set_next_pg_enum_oid(oid)
is 'for use by pg_upgrade';

create function pg_catalog.binary_upgrade_set_next_pg_authid_oid(oid)
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.binary_upgrade_set_next_pg_authid_oid
;

comment on function pg_catalog.binary_upgrade_set_next_pg_authid_oid(oid)
is 'for use by pg_upgrade';

create function pg_catalog.binary_upgrade_create_empty_extension(text, text, boolean, text, oid [], text [], text [])
cost 1
language internal
as
-- missing source code for pg_catalog.binary_upgrade_create_empty_extension
;

comment on function pg_catalog.binary_upgrade_create_empty_extension(text, text, boolean, text, oid [], text [],
                                                                     text [])
is 'for use by pg_upgrade';

create function pg_catalog.event_trigger_in(cstring)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.event_trigger_in
;

comment on function pg_catalog.event_trigger_in(cstring)
is 'I/O';

create function pg_catalog.event_trigger_out(event_trigger)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.event_trigger_out
;

comment on function pg_catalog.event_trigger_out(event_trigger)
is 'I/O';

create function pg_catalog.tsvectorin(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsvectorin
;

comment on function pg_catalog.tsvectorin(cstring)
is 'I/O';

create function pg_catalog.tsvectorout(tsvector)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsvectorout
;

comment on function pg_catalog.tsvectorout(tsvector)
is 'I/O';

create function pg_catalog.tsqueryin(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsqueryin
;

comment on function pg_catalog.tsqueryin(cstring)
is 'I/O';

create function pg_catalog.tsqueryout(tsquery)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsqueryout
;

comment on function pg_catalog.tsqueryout(tsquery)
is 'I/O';

create function pg_catalog.tsvector_lt(tsvector, tsvector)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsvector_lt
;

comment on function pg_catalog.tsvector_lt(tsvector, tsvector)
is 'implementation of < operator';

create function pg_catalog.tsvector_le(tsvector, tsvector)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsvector_le
;

comment on function pg_catalog.tsvector_le(tsvector, tsvector)
is 'implementation of <= operator';

create function pg_catalog.tsvector_eq(tsvector, tsvector)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsvector_eq
;

comment on function pg_catalog.tsvector_eq(tsvector, tsvector)
is 'implementation of = operator';

create function pg_catalog.tsvector_ne(tsvector, tsvector)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsvector_ne
;

comment on function pg_catalog.tsvector_ne(tsvector, tsvector)
is 'implementation of <> operator';

create function pg_catalog.tsvector_ge(tsvector, tsvector)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsvector_ge
;

comment on function pg_catalog.tsvector_ge(tsvector, tsvector)
is 'implementation of >= operator';

create function pg_catalog.tsvector_gt(tsvector, tsvector)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsvector_gt
;

comment on function pg_catalog.tsvector_gt(tsvector, tsvector)
is 'implementation of > operator';

create function pg_catalog.tsvector_cmp(tsvector, tsvector)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsvector_cmp
;

comment on function pg_catalog.tsvector_cmp(tsvector, tsvector)
is 'less-equal-greater';

create function pg_catalog.strip(tsvector)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.strip
;

comment on function pg_catalog.strip(tsvector)
is 'strip position information';

create function pg_catalog.setweight(tsvector, "char")
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.setweight
;

comment on function pg_catalog.setweight(tsvector, "char")
is 'set given weight for whole tsvector';

create function pg_catalog.tsvector_concat(tsvector, tsvector)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsvector_concat
;

comment on function pg_catalog.tsvector_concat(tsvector, tsvector)
is 'implementation of || operator';

create function pg_catalog.ts_match_vq(tsvector, tsquery)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ts_match_vq
;

comment on function pg_catalog.ts_match_vq(tsvector, tsquery)
is 'implementation of @@ operator';

create function pg_catalog.ts_match_qv(tsquery, tsvector)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ts_match_qv
;

comment on function pg_catalog.ts_match_qv(tsquery, tsvector)
is 'implementation of @@ operator';

create function pg_catalog.tsvectorsend(tsvector)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsvectorsend
;

comment on function pg_catalog.tsvectorsend(tsvector)
is 'I/O';

create function pg_catalog.tsvectorrecv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsvectorrecv
;

comment on function pg_catalog.tsvectorrecv(internal)
is 'I/O';

create function pg_catalog.tsquerysend(tsquery)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsquerysend
;

comment on function pg_catalog.tsquerysend(tsquery)
is 'I/O';

create function pg_catalog.tsqueryrecv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsqueryrecv
;

comment on function pg_catalog.tsqueryrecv(internal)
is 'I/O';

create function pg_catalog.gtsvectorin(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gtsvectorin
;

comment on function pg_catalog.gtsvectorin(cstring)
is 'I/O';

create function pg_catalog.gtsvectorout(gtsvector)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gtsvectorout
;

comment on function pg_catalog.gtsvectorout(gtsvector)
is 'I/O';

create function pg_catalog.gtsvector_compress(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gtsvector_compress
;

comment on function pg_catalog.gtsvector_compress(internal)
is 'GiST tsvector support';

create function pg_catalog.gtsvector_decompress(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gtsvector_decompress
;

comment on function pg_catalog.gtsvector_decompress(internal)
is 'GiST tsvector support';

create function pg_catalog.gtsvector_picksplit(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gtsvector_picksplit
;

comment on function pg_catalog.gtsvector_picksplit(internal, internal)
is 'GiST tsvector support';

create function pg_catalog.gtsvector_union(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gtsvector_union
;

comment on function pg_catalog.gtsvector_union(internal, internal)
is 'GiST tsvector support';

create function pg_catalog.gtsvector_same(gtsvector, gtsvector, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gtsvector_same
;

comment on function pg_catalog.gtsvector_same(gtsvector, gtsvector, internal)
is 'GiST tsvector support';

create function pg_catalog.gtsvector_penalty(internal, internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gtsvector_penalty
;

comment on function pg_catalog.gtsvector_penalty(internal, internal, internal)
is 'GiST tsvector support';

create function pg_catalog.gtsvector_consistent(internal, tsvector, smallint, oid, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gtsvector_consistent
;

comment on function pg_catalog.gtsvector_consistent(internal, tsvector, smallint, oid, internal)
is 'GiST tsvector support';

create function pg_catalog.gin_extract_tsvector(tsvector, internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gin_extract_tsvector
;

comment on function pg_catalog.gin_extract_tsvector(tsvector, internal, internal)
is 'GIN tsvector support';

create function pg_catalog.gin_extract_tsquery(tsvector, internal, smallint, internal, internal, internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gin_extract_tsquery
;

comment on function pg_catalog.gin_extract_tsquery(tsvector, internal, smallint, internal, internal, internal, internal)
is 'GIN tsvector support';

create function pg_catalog.gin_tsquery_consistent(internal, smallint, tsvector, integer, internal, internal, internal,
                                                  internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gin_tsquery_consistent
;

comment on function pg_catalog.gin_tsquery_consistent(internal, smallint, tsvector, integer, internal, internal,
                                                      internal, internal)
is 'GIN tsvector support';

create function pg_catalog.tsquery_lt(tsquery, tsquery)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsquery_lt
;

comment on function pg_catalog.tsquery_lt(tsquery, tsquery)
is 'implementation of < operator';

create function pg_catalog.tsquery_le(tsquery, tsquery)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsquery_le
;

comment on function pg_catalog.tsquery_le(tsquery, tsquery)
is 'implementation of <= operator';

create function pg_catalog.tsquery_eq(tsquery, tsquery)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsquery_eq
;

comment on function pg_catalog.tsquery_eq(tsquery, tsquery)
is 'implementation of = operator';

create function pg_catalog.tsquery_ne(tsquery, tsquery)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsquery_ne
;

comment on function pg_catalog.tsquery_ne(tsquery, tsquery)
is 'implementation of <> operator';

create function pg_catalog.tsquery_ge(tsquery, tsquery)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsquery_ge
;

comment on function pg_catalog.tsquery_ge(tsquery, tsquery)
is 'implementation of >= operator';

create function pg_catalog.tsquery_gt(tsquery, tsquery)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsquery_gt
;

comment on function pg_catalog.tsquery_gt(tsquery, tsquery)
is 'implementation of > operator';

create function pg_catalog.tsquery_cmp(tsquery, tsquery)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsquery_cmp
;

comment on function pg_catalog.tsquery_cmp(tsquery, tsquery)
is 'less-equal-greater';

create function pg_catalog.tsquery_and(tsquery, tsquery)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsquery_and
;

comment on function pg_catalog.tsquery_and(tsquery, tsquery)
is 'implementation of && operator';

create function pg_catalog.tsquery_or(tsquery, tsquery)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsquery_or
;

comment on function pg_catalog.tsquery_or(tsquery, tsquery)
is 'implementation of || operator';

create function pg_catalog.tsquery_not(tsquery)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsquery_not
;

comment on function pg_catalog.tsquery_not(tsquery)
is 'implementation of !! operator';

create function pg_catalog.numnode(tsquery)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numnode
;

comment on function pg_catalog.numnode(tsquery)
is 'number of nodes';

create function pg_catalog.querytree(tsquery)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.querytree
;

comment on function pg_catalog.querytree(tsquery)
is 'show real useful query for GiST index';

create function pg_catalog.ts_rewrite(tsquery, tsquery, tsquery)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ts_rewrite
;

comment on function pg_catalog.ts_rewrite(tsquery, tsquery, tsquery)
is 'rewrite tsquery';

create function pg_catalog.ts_rewrite(tsquery, text)
strict
language internal
as
-- missing source code for pg_catalog.ts_rewrite
;

comment on function pg_catalog.ts_rewrite(tsquery, text)
is 'rewrite tsquery';

create function pg_catalog.tsmatchsel(internal, oid, internal, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsmatchsel
;

comment on function pg_catalog.tsmatchsel(internal, oid, internal, integer)
is 'restriction selectivity of tsvector @@ tsquery';

create function pg_catalog.tsmatchjoinsel(internal, oid, internal, smallint, internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsmatchjoinsel
;

comment on function pg_catalog.tsmatchjoinsel(internal, oid, internal, smallint, internal)
is 'join selectivity of tsvector @@ tsquery';

create function pg_catalog.ts_typanalyze(internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ts_typanalyze
;

comment on function pg_catalog.ts_typanalyze(internal)
is 'tsvector typanalyze';

create function pg_catalog.ts_stat(query text, out word text, out ndoc integer, out nentry integer)
strict
cost 10
rows 10000
language internal
as
-- missing source code for pg_catalog.ts_stat
;

comment on function pg_catalog.ts_stat(text, out text, out integer, out integer)
is 'statistics of tsvector column';

create function pg_catalog.ts_stat(query text, weights text, out word text, out ndoc integer, out nentry integer)
strict
cost 10
rows 10000
language internal
as
-- missing source code for pg_catalog.ts_stat
;

comment on function pg_catalog.ts_stat(text, text, out text, out integer, out integer)
is 'statistics of tsvector column';

create function pg_catalog.tsq_mcontains(tsquery, tsquery)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsq_mcontains
;

comment on function pg_catalog.tsq_mcontains(tsquery, tsquery)
is 'implementation of @> operator';

create function pg_catalog.tsq_mcontained(tsquery, tsquery)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsq_mcontained
;

comment on function pg_catalog.tsq_mcontained(tsquery, tsquery)
is 'implementation of <@ operator';

create function pg_catalog.gtsquery_compress(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gtsquery_compress
;

comment on function pg_catalog.gtsquery_compress(internal)
is 'GiST tsquery support';

create function pg_catalog.starts_with(text, text)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.starts_with
;

comment on function pg_catalog.starts_with(text, text)
is 'implementation of ^@ operator';

create function pg_catalog.gtsquery_picksplit(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gtsquery_picksplit
;

comment on function pg_catalog.gtsquery_picksplit(internal, internal)
is 'GiST tsquery support';

create function pg_catalog.gtsquery_union(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gtsquery_union
;

comment on function pg_catalog.gtsquery_union(internal, internal)
is 'GiST tsquery support';

create function pg_catalog.gtsquery_same(bigint, bigint, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gtsquery_same
;

comment on function pg_catalog.gtsquery_same(bigint, bigint, internal)
is 'GiST tsquery support';

create function pg_catalog.gtsquery_penalty(internal, internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gtsquery_penalty
;

comment on function pg_catalog.gtsquery_penalty(internal, internal, internal)
is 'GiST tsquery support';

create function pg_catalog.gtsquery_consistent(internal, tsquery, smallint, oid, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gtsquery_consistent
;

comment on function pg_catalog.gtsquery_consistent(internal, tsquery, smallint, oid, internal)
is 'GiST tsquery support';

create function pg_catalog.ts_rank(real [], tsvector, tsquery, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ts_rank
;

comment on function pg_catalog.ts_rank(real [], tsvector, tsquery, integer)
is 'relevance';

create function pg_catalog.ts_rank(real [], tsvector, tsquery)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ts_rank
;

comment on function pg_catalog.ts_rank(real [], tsvector, tsquery)
is 'relevance';

create function pg_catalog.ts_rank(tsvector, tsquery, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ts_rank
;

comment on function pg_catalog.ts_rank(tsvector, tsquery, integer)
is 'relevance';

create function pg_catalog.ts_rank(tsvector, tsquery)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ts_rank
;

comment on function pg_catalog.ts_rank(tsvector, tsquery)
is 'relevance';

create function pg_catalog.ts_rank_cd(real [], tsvector, tsquery, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ts_rank_cd
;

comment on function pg_catalog.ts_rank_cd(real [], tsvector, tsquery, integer)
is 'relevance';

create function pg_catalog.ts_rank_cd(real [], tsvector, tsquery)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ts_rank_cd
;

comment on function pg_catalog.ts_rank_cd(real [], tsvector, tsquery)
is 'relevance';

create function pg_catalog.ts_rank_cd(tsvector, tsquery, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ts_rank_cd
;

comment on function pg_catalog.ts_rank_cd(tsvector, tsquery, integer)
is 'relevance';

create function pg_catalog.ts_rank_cd(tsvector, tsquery)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ts_rank_cd
;

comment on function pg_catalog.ts_rank_cd(tsvector, tsquery)
is 'relevance';

create function pg_catalog.length(tsvector)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.length
;

comment on function pg_catalog.length(tsvector)
is 'number of lexemes';

create function pg_catalog.ts_token_type(parser_oid oid, out tokid integer, out alias text, out description text)
immutable
strict
parallel safe
cost 1
rows 16
language internal
as
-- missing source code for pg_catalog.ts_token_type
;

comment on function pg_catalog.ts_token_type(oid, out integer, out text, out text)
is 'get parser''s token types';

create function pg_catalog.ts_token_type(parser_name text, out tokid integer, out alias text, out description text)
stable
strict
parallel safe
cost 1
rows 16
language internal
as
-- missing source code for pg_catalog.ts_token_type
;

comment on function pg_catalog.ts_token_type(text, out integer, out text, out text)
is 'get parser''s token types';

create function pg_catalog.ts_parse(parser_oid oid, txt text, out tokid integer, out token text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ts_parse
;

comment on function pg_catalog.ts_parse(oid, text, out integer, out text)
is 'parse text to tokens';

create function pg_catalog.ts_parse(parser_name text, txt text, out tokid integer, out token text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ts_parse
;

comment on function pg_catalog.ts_parse(text, text, out integer, out text)
is 'parse text to tokens';

create function pg_catalog.prsd_start(internal, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.prsd_start
;

comment on function pg_catalog.prsd_start(internal, integer)
is '(internal)';

create function pg_catalog.prsd_nexttoken(internal, internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.prsd_nexttoken
;

comment on function pg_catalog.prsd_nexttoken(internal, internal, internal)
is '(internal)';

create function pg_catalog.prsd_end(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.prsd_end
;

comment on function pg_catalog.prsd_end(internal)
is '(internal)';

create function pg_catalog.prsd_headline(internal, internal, tsquery)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.prsd_headline
;

comment on function pg_catalog.prsd_headline(internal, internal, tsquery)
is '(internal)';

create function pg_catalog.prsd_lextype(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.prsd_lextype
;

comment on function pg_catalog.prsd_lextype(internal)
is '(internal)';

create function pg_catalog.ts_lexize(regdictionary, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ts_lexize
;

comment on function pg_catalog.ts_lexize(regdictionary, text)
is 'normalize one word by dictionary';

create function pg_catalog.gin_cmp_tslexeme(text, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gin_cmp_tslexeme
;

comment on function pg_catalog.gin_cmp_tslexeme(text, text)
is 'GIN tsvector support';

create function pg_catalog.dsimple_init(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.dsimple_init
;

comment on function pg_catalog.dsimple_init(internal)
is '(internal)';

create function pg_catalog.dsimple_lexize(internal, internal, internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.dsimple_lexize
;

comment on function pg_catalog.dsimple_lexize(internal, internal, internal, internal)
is '(internal)';

create function pg_catalog.dsynonym_init(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.dsynonym_init
;

comment on function pg_catalog.dsynonym_init(internal)
is '(internal)';

create function pg_catalog.dsynonym_lexize(internal, internal, internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.dsynonym_lexize
;

comment on function pg_catalog.dsynonym_lexize(internal, internal, internal, internal)
is '(internal)';

create function pg_catalog.dispell_init(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.dispell_init
;

comment on function pg_catalog.dispell_init(internal)
is '(internal)';

create function pg_catalog.dispell_lexize(internal, internal, internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.dispell_lexize
;

comment on function pg_catalog.dispell_lexize(internal, internal, internal, internal)
is '(internal)';

create function pg_catalog.regconfigin(cstring)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regconfigin
;

comment on function pg_catalog.regconfigin(cstring)
is 'I/O';

create function pg_catalog.regconfigout(regconfig)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regconfigout
;

comment on function pg_catalog.regconfigout(regconfig)
is 'I/O';

create function pg_catalog.regconfigrecv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regconfigrecv
;

comment on function pg_catalog.regconfigrecv(internal)
is 'I/O';

create function pg_catalog.regconfigsend(regconfig)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regconfigsend
;

comment on function pg_catalog.regconfigsend(regconfig)
is 'I/O';

create function pg_catalog.thesaurus_init(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.thesaurus_init
;

comment on function pg_catalog.thesaurus_init(internal)
is '(internal)';

create function pg_catalog.thesaurus_lexize(internal, internal, internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.thesaurus_lexize
;

comment on function pg_catalog.thesaurus_lexize(internal, internal, internal, internal)
is '(internal)';

create function pg_catalog.ts_headline(regconfig, text, tsquery, text)
immutable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.ts_headline
;

comment on function pg_catalog.ts_headline(regconfig, text, tsquery, text)
is 'generate headline';

create function pg_catalog.ts_headline(regconfig, text, tsquery)
immutable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.ts_headline
;

comment on function pg_catalog.ts_headline(regconfig, text, tsquery)
is 'generate headline';

create function pg_catalog.to_tsvector(regconfig, text)
immutable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.to_tsvector
;

comment on function pg_catalog.to_tsvector(regconfig, text)
is 'transform to tsvector';

create function pg_catalog.to_tsquery(regconfig, text)
immutable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.to_tsquery
;

comment on function pg_catalog.to_tsquery(regconfig, text)
is 'make tsquery';

create function pg_catalog.plainto_tsquery(regconfig, text)
immutable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.plainto_tsquery
;

comment on function pg_catalog.plainto_tsquery(regconfig, text)
is 'transform to tsquery';

create function pg_catalog.to_tsvector(text)
stable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.to_tsvector
;

comment on function pg_catalog.to_tsvector(text)
is 'transform to tsvector';

create function pg_catalog.to_tsquery(text)
stable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.to_tsquery
;

comment on function pg_catalog.to_tsquery(text)
is 'make tsquery';

create function pg_catalog.plainto_tsquery(text)
stable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.plainto_tsquery
;

comment on function pg_catalog.plainto_tsquery(text)
is 'transform to tsquery';

create function pg_catalog.tsvector_update_trigger()
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsvector_update_trigger
;

comment on function pg_catalog.tsvector_update_trigger()
is 'trigger for automatic update of tsvector column';

create function pg_catalog.tsvector_update_trigger_column()
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsvector_update_trigger_column
;

comment on function pg_catalog.tsvector_update_trigger_column()
is 'trigger for automatic update of tsvector column';

create function pg_catalog.ts_headline(text, tsquery, text)
stable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.ts_headline
;

comment on function pg_catalog.ts_headline(text, tsquery, text)
is 'generate headline';

create function pg_catalog.ts_headline(text, tsquery)
stable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.ts_headline
;

comment on function pg_catalog.ts_headline(text, tsquery)
is 'generate headline';

create function pg_catalog.pg_ts_parser_is_visible(oid)
stable
strict
parallel safe
cost 10
language internal
as
-- missing source code for pg_catalog.pg_ts_parser_is_visible
;

comment on function pg_catalog.pg_ts_parser_is_visible(oid)
is 'is text search parser visible in search path?';

create function pg_catalog.pg_ts_dict_is_visible(oid)
stable
strict
parallel safe
cost 10
language internal
as
-- missing source code for pg_catalog.pg_ts_dict_is_visible
;

comment on function pg_catalog.pg_ts_dict_is_visible(oid)
is 'is text search dictionary visible in search path?';

create function pg_catalog.pg_ts_config_is_visible(oid)
stable
strict
parallel safe
cost 10
language internal
as
-- missing source code for pg_catalog.pg_ts_config_is_visible
;

comment on function pg_catalog.pg_ts_config_is_visible(oid)
is 'is text search configuration visible in search path?';

create function pg_catalog.get_current_ts_config()
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.get_current_ts_config
;

comment on function pg_catalog.get_current_ts_config()
is 'get current tsearch configuration';

create function pg_catalog.ts_match_tt(text, text)
stable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.ts_match_tt
;

comment on function pg_catalog.ts_match_tt(text, text)
is 'implementation of @@ operator';

create function pg_catalog.ts_match_tq(text, tsquery)
stable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.ts_match_tq
;

comment on function pg_catalog.ts_match_tq(text, tsquery)
is 'implementation of @@ operator';

create function pg_catalog.pg_ts_template_is_visible(oid)
stable
strict
parallel safe
cost 10
language internal
as
-- missing source code for pg_catalog.pg_ts_template_is_visible
;

comment on function pg_catalog.pg_ts_template_is_visible(oid)
is 'is text search template visible in search path?';

create function pg_catalog.regdictionaryin(cstring)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regdictionaryin
;

comment on function pg_catalog.regdictionaryin(cstring)
is 'I/O';

create function pg_catalog.regdictionaryout(regdictionary)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regdictionaryout
;

comment on function pg_catalog.regdictionaryout(regdictionary)
is 'I/O';

create function pg_catalog.regdictionaryrecv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regdictionaryrecv
;

comment on function pg_catalog.regdictionaryrecv(internal)
is 'I/O';

create function pg_catalog.regdictionarysend(regdictionary)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regdictionarysend
;

comment on function pg_catalog.regdictionarysend(regdictionary)
is 'I/O';

create function pg_catalog.pg_stat_reset_shared(text)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_reset_shared
;

comment on function pg_catalog.pg_stat_reset_shared(text)
is 'statistics: reset collected statistics shared across the cluster';

create function pg_catalog.pg_stat_reset_single_table_counters(oid)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_reset_single_table_counters
;

comment on function pg_catalog.pg_stat_reset_single_table_counters(oid)
is 'statistics: reset collected statistics for a single table or index in the current database';

create function pg_catalog.pg_stat_reset_single_function_counters(oid)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_reset_single_function_counters
;

comment on function pg_catalog.pg_stat_reset_single_function_counters(oid)
is 'statistics: reset collected statistics for a single function in the current database';

create function pg_catalog.pg_tablespace_location(oid)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_tablespace_location
;

comment on function pg_catalog.pg_tablespace_location(oid)
is 'tablespace location';

create function pg_catalog.pg_create_physical_replication_slot(slot_name           name,
                                                               immediately_reserve boolean default false,
                                                               temporary           boolean default false,
  out                                                          slot_name           name, out lsn pg_lsn)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_create_physical_replication_slot
;

comment on function pg_catalog.pg_create_physical_replication_slot(name, boolean, boolean, out name, out pg_lsn)
is 'create a physical replication slot';

create function pg_catalog.pg_drop_replication_slot(name)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_drop_replication_slot
;

comment on function pg_catalog.pg_drop_replication_slot(name)
is 'drop a replication slot';

create function pg_catalog.pg_get_replication_slots(out slot_name   name, out plugin name, out slot_type text,
                                                    out datoid      oid, out temporary boolean, out active boolean,
                                                    out active_pid  integer, out xmin xid, out catalog_xmin xid,
                                                    out restart_lsn pg_lsn, out confirmed_flush_lsn pg_lsn)
stable
parallel safe
cost 1
rows 10
language internal
as
-- missing source code for pg_catalog.pg_get_replication_slots
;

comment on function pg_catalog.pg_get_replication_slots(out name, out name, out text, out oid, out boolean, out boolean,
                                                        out integer, out xid, out xid, out pg_lsn, out pg_lsn)
is 'information about replication slots currently in use';

create function pg_catalog.pg_logical_slot_get_changes(                                               slot_name     name,
                                                                                                      upto_lsn      pg_lsn,
                                                                                                      upto_nchanges integer,
                                                                                                      options       text [] default '{}' :: text [],
  out                                                                                                 lsn           pg_lsn,
  out                                                                                                 xid           xid,
  out                                                                                                 data          text)
cost 1000
language internal
as
-- missing source code for pg_catalog.pg_logical_slot_get_changes
;

comment on function pg_catalog.pg_logical_slot_get_changes(name, pg_lsn, integer, text [], out pg_lsn, out xid,
                                                                                           out text)
is 'get changes from replication slot';

create function pg_catalog.pg_logical_slot_get_binary_changes(                                               slot_name     name,
                                                                                                             upto_lsn      pg_lsn,
                                                                                                             upto_nchanges integer,
                                                                                                             options       text [] default '{}' :: text [],
  out                                                                                                        lsn           pg_lsn,
  out                                                                                                        xid           xid,
  out                                                                                                        data          bytea)
cost 1000
language internal
as
-- missing source code for pg_catalog.pg_logical_slot_get_binary_changes
;

comment on function pg_catalog.pg_logical_slot_get_binary_changes(name, pg_lsn, integer, text [], out pg_lsn, out xid,
                                                                                                  out bytea)
is 'get binary changes from replication slot';

create function pg_catalog.pg_logical_slot_peek_changes(                                               slot_name     name,
                                                                                                       upto_lsn      pg_lsn,
                                                                                                       upto_nchanges integer,
                                                                                                       options       text [] default '{}' :: text [],
  out                                                                                                  lsn           pg_lsn,
  out                                                                                                  xid           xid,
  out                                                                                                  data          text)
cost 1000
language internal
as
-- missing source code for pg_catalog.pg_logical_slot_peek_changes
;

comment on function pg_catalog.pg_logical_slot_peek_changes(name, pg_lsn, integer, text [], out pg_lsn, out xid,
                                                                                            out text)
is 'peek at changes from replication slot';

create function pg_catalog.pg_logical_slot_peek_binary_changes(slot_name name, upto_lsn pg_lsn, upto_nchanges integer,
                                                               options   text [] default '{}' :: text [],
  out                                                          lsn       pg_lsn, out xid xid, out data bytea)
cost 1000
language internal
as
-- missing source code for pg_catalog.pg_logical_slot_peek_binary_changes
;

comment on function pg_catalog.pg_logical_slot_peek_binary_changes(name, pg_lsn, integer, text [], out pg_lsn, out xid,
                                                                                                   out bytea)
is 'peek at binary changes from replication slot';

create function pg_catalog.pg_create_logical_replication_slot(                                     slot_name name,
                                                                                                   plugin    name,
                                                                                                   temporary boolean default false,
  out                                                                                              slot_name text,
  out                                                                                              lsn       pg_lsn)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_create_logical_replication_slot
;

comment on function pg_catalog.pg_create_logical_replication_slot(name, name, boolean, out text, out pg_lsn)
is 'set up a logical replication slot';

create function pg_catalog.to_jsonb(anyelement)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.to_jsonb
;

comment on function pg_catalog.to_jsonb(anyelement)
is 'map input to jsonb';

create function pg_catalog.pg_stat_get_snapshot_timestamp()
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_snapshot_timestamp
;

comment on function pg_catalog.pg_stat_get_snapshot_timestamp()
is 'statistics: timestamp of the current statistics snapshot';

create function pg_catalog.gin_clean_pending_list(regclass)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.gin_clean_pending_list
;

comment on function pg_catalog.gin_clean_pending_list(regclass)
is 'clean up GIN pending list';

create function pg_catalog.gtsvector_consistent(internal, gtsvector, integer, oid, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gtsvector_consistent
;

comment on function pg_catalog.gtsvector_consistent(internal, gtsvector, integer, oid, internal)
is 'GiST tsvector support (obsolete)';

create function pg_catalog.gin_extract_tsquery(tsquery, internal, smallint, internal, internal, internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gin_extract_tsquery
;

comment on function pg_catalog.gin_extract_tsquery(tsquery, internal, smallint, internal, internal, internal, internal)
is 'GIN tsvector support (obsolete)';

create function pg_catalog.gin_tsquery_consistent(internal, smallint, tsquery, integer, internal, internal, internal,
                                                  internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gin_tsquery_consistent
;

comment on function pg_catalog.gin_tsquery_consistent(internal, smallint, tsquery, integer, internal, internal,
                                                      internal, internal)
is 'GIN tsvector support (obsolete)';

create function pg_catalog.gtsquery_consistent(internal, internal, integer, oid, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gtsquery_consistent
;

comment on function pg_catalog.gtsquery_consistent(internal, internal, integer, oid, internal)
is 'GiST tsquery support (obsolete)';

create function pg_catalog.inet_spg_config(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inet_spg_config
;

comment on function pg_catalog.inet_spg_config(internal, internal)
is 'SP-GiST support';

create function pg_catalog.inet_spg_choose(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inet_spg_choose
;

comment on function pg_catalog.inet_spg_choose(internal, internal)
is 'SP-GiST support';

create function pg_catalog.inet_spg_picksplit(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inet_spg_picksplit
;

comment on function pg_catalog.inet_spg_picksplit(internal, internal)
is 'SP-GiST support';

create function pg_catalog.inet_spg_inner_consistent(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inet_spg_inner_consistent
;

comment on function pg_catalog.inet_spg_inner_consistent(internal, internal)
is 'SP-GiST support';

create function pg_catalog.inet_spg_leaf_consistent(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inet_spg_leaf_consistent
;

comment on function pg_catalog.inet_spg_leaf_consistent(internal, internal)
is 'SP-GiST support';

create function pg_catalog.pg_current_logfile()
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_current_logfile
;

comment on function pg_catalog.pg_current_logfile()
is 'current logging collector file location';

create function pg_catalog.pg_current_logfile(text)
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_current_logfile
;

comment on function pg_catalog.pg_current_logfile(text)
is 'current logging collector file location';

create function pg_catalog.jsonb_send(jsonb)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_send
;

comment on function pg_catalog.jsonb_send(jsonb)
is 'I/O';

create function pg_catalog.jsonb_out(jsonb)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_out
;

comment on function pg_catalog.jsonb_out(jsonb)
is 'I/O';

create function pg_catalog.jsonb_recv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_recv
;

comment on function pg_catalog.jsonb_recv(internal)
is 'I/O';

create function pg_catalog.jsonb_in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_in
;

comment on function pg_catalog.jsonb_in(cstring)
is 'I/O';

create function pg_catalog.pg_get_function_arg_default(oid, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_get_function_arg_default
;

comment on function pg_catalog.pg_get_function_arg_default(oid, integer)
is 'function argument default';

create function pg_catalog.pg_export_snapshot()
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_export_snapshot
;

comment on function pg_catalog.pg_export_snapshot()
is 'export a snapshot';

create function pg_catalog.pg_is_in_recovery()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_is_in_recovery
;

comment on function pg_catalog.pg_is_in_recovery()
is 'true if server is in recovery';

create function pg_catalog.money(integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.money
;

comment on function pg_catalog.money(integer)
is 'convert int4 to money';

create function pg_catalog.money(bigint)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.money
;

comment on function pg_catalog.money(bigint)
is 'convert int8 to money';

create function pg_catalog.pg_is_in_backup()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_is_in_backup
;

comment on function pg_catalog.pg_is_in_backup()
is 'true if server is in online backup';

create function pg_catalog.pg_backup_start_time()
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_backup_start_time
;

comment on function pg_catalog.pg_backup_start_time()
is 'start time of an online backup';

create function pg_catalog.pg_collation_is_visible(oid)
stable
strict
parallel safe
cost 10
language internal
as
-- missing source code for pg_catalog.pg_collation_is_visible
;

comment on function pg_catalog.pg_collation_is_visible(oid)
is 'is collation visible in search path?';

create function pg_catalog.array_typanalyze(internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_typanalyze
;

comment on function pg_catalog.array_typanalyze(internal)
is 'array typanalyze';

create function pg_catalog.arraycontsel(internal, oid, internal, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.arraycontsel
;

comment on function pg_catalog.arraycontsel(internal, oid, internal, integer)
is 'restriction selectivity for array-containment operators';

create function pg_catalog.arraycontjoinsel(internal, oid, internal, smallint, internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.arraycontjoinsel
;

comment on function pg_catalog.arraycontjoinsel(internal, oid, internal, smallint, internal)
is 'join selectivity for array-containment operators';

create function pg_catalog.pg_get_multixact_members(multixid xid, out xid xid, out mode text)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_get_multixact_members
;

comment on function pg_catalog.pg_get_multixact_members(xid, out xid, out text)
is 'view members of a multixactid';

create function pg_catalog.pg_last_wal_receive_lsn()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_last_wal_receive_lsn
;

comment on function pg_catalog.pg_last_wal_receive_lsn()
is 'current wal flush location';

create function pg_catalog.pg_last_wal_replay_lsn()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_last_wal_replay_lsn
;

comment on function pg_catalog.pg_last_wal_replay_lsn()
is 'last wal replay location';

create function pg_catalog.cash_div_cash(money, money)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cash_div_cash
;

comment on function pg_catalog.cash_div_cash(money, money)
is 'implementation of / operator';

create function pg_catalog.numeric(money)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numeric
;

comment on function pg_catalog.numeric(money)
is 'convert money to numeric';

create function pg_catalog.money(numeric)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.money
;

comment on function pg_catalog.money(numeric)
is 'convert numeric to money';

create function pg_catalog.pg_read_file(text)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_read_file
;

comment on function pg_catalog.pg_read_file(text)
is 'read text from a file';

create function pg_catalog.pg_read_binary_file(text, bigint, bigint)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_read_binary_file
;

comment on function pg_catalog.pg_read_binary_file(text, bigint, bigint)
is 'read bytea from a file';

create function pg_catalog.pg_read_binary_file(text)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_read_binary_file
;

comment on function pg_catalog.pg_read_binary_file(text)
is 'read bytea from a file';

create function pg_catalog.pg_opfamily_is_visible(oid)
stable
strict
parallel safe
cost 10
language internal
as
-- missing source code for pg_catalog.pg_opfamily_is_visible
;

comment on function pg_catalog.pg_opfamily_is_visible(oid)
is 'is opfamily visible in search path?';

create function pg_catalog.pg_last_xact_replay_timestamp()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_last_xact_replay_timestamp
;

comment on function pg_catalog.pg_last_xact_replay_timestamp()
is 'timestamp of last replay xact';

create function pg_catalog.anyrange_in(cstring, oid, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.anyrange_in
;

comment on function pg_catalog.anyrange_in(cstring, oid, integer)
is 'I/O';

create function pg_catalog.anyrange_out(anyrange)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.anyrange_out
;

comment on function pg_catalog.anyrange_out(anyrange)
is 'I/O';

create function pg_catalog.range_in(cstring, oid, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_in
;

comment on function pg_catalog.range_in(cstring, oid, integer)
is 'I/O';

create function pg_catalog.range_out(anyrange)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_out
;

comment on function pg_catalog.range_out(anyrange)
is 'I/O';

create function pg_catalog.range_recv(internal, oid, integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_recv
;

comment on function pg_catalog.range_recv(internal, oid, integer)
is 'I/O';

create function pg_catalog.range_send(anyrange)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_send
;

comment on function pg_catalog.range_send(anyrange)
is 'I/O';

create function pg_catalog.pg_identify_object(classid oid, objid oid, objsubid integer, out type text, out schema text,
                                                                                        out name text,
                                                                                        out identity text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_identify_object
;

comment on function pg_catalog.pg_identify_object(oid, oid, integer, out text, out text, out text, out text)
is 'get machine-parseable identification of SQL object';

create function pg_catalog.int4range(integer, integer)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4range
;

comment on function pg_catalog.int4range(integer, integer)
is 'int4range constructor';

create function pg_catalog.int4range(integer, integer, text)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4range
;

comment on function pg_catalog.int4range(integer, integer, text)
is 'int4range constructor';

create function pg_catalog.pg_relation_is_updatable(regclass, boolean)
stable
strict
parallel safe
cost 10
language internal
as
-- missing source code for pg_catalog.pg_relation_is_updatable
;

comment on function pg_catalog.pg_relation_is_updatable(regclass, boolean)
is 'is a relation insertable/updatable/deletable';

create function pg_catalog.pg_column_is_updatable(regclass, smallint, boolean)
stable
strict
parallel safe
cost 10
language internal
as
-- missing source code for pg_catalog.pg_column_is_updatable
;

comment on function pg_catalog.pg_column_is_updatable(regclass, smallint, boolean)
is 'is a column updatable';

create function pg_catalog.numrange(numeric, numeric)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numrange
;

comment on function pg_catalog.numrange(numeric, numeric)
is 'numrange constructor';

create function pg_catalog.numrange(numeric, numeric, text)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numrange
;

comment on function pg_catalog.numrange(numeric, numeric, text)
is 'numrange constructor';

create function pg_catalog.make_date(year integer, month integer, day integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.make_date
;

comment on function pg_catalog.make_date(integer, integer, integer)
is 'construct date';

create function pg_catalog.make_time(hour integer, min integer, sec double precision)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.make_time
;

comment on function pg_catalog.make_time(integer, integer, double precision)
is 'construct time';

create function pg_catalog.lower(anyrange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lower
;

comment on function pg_catalog.lower(anyrange)
is 'lower bound of range';

create function pg_catalog.upper(anyrange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.upper
;

comment on function pg_catalog.upper(anyrange)
is 'upper bound of range';

create function pg_catalog.isempty(anyrange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.isempty
;

comment on function pg_catalog.isempty(anyrange)
is 'is the range empty?';

create function pg_catalog.lower_inc(anyrange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lower_inc
;

comment on function pg_catalog.lower_inc(anyrange)
is 'is the range''s lower bound inclusive?';

create function pg_catalog.upper_inc(anyrange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.upper_inc
;

comment on function pg_catalog.upper_inc(anyrange)
is 'is the range''s upper bound inclusive?';

create function pg_catalog.lower_inf(anyrange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.lower_inf
;

comment on function pg_catalog.lower_inf(anyrange)
is 'is the range''s lower bound infinite?';

create function pg_catalog.upper_inf(anyrange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.upper_inf
;

comment on function pg_catalog.upper_inf(anyrange)
is 'is the range''s upper bound infinite?';

create function pg_catalog.range_eq(anyrange, anyrange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_eq
;

comment on function pg_catalog.range_eq(anyrange, anyrange)
is 'implementation of = operator';

create function pg_catalog.range_ne(anyrange, anyrange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_ne
;

comment on function pg_catalog.range_ne(anyrange, anyrange)
is 'implementation of <> operator';

create function pg_catalog.range_overlaps(anyrange, anyrange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_overlaps
;

comment on function pg_catalog.range_overlaps(anyrange, anyrange)
is 'implementation of && operator';

create function pg_catalog.range_contains_elem(anyrange, anyelement)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_contains_elem
;

comment on function pg_catalog.range_contains_elem(anyrange, anyelement)
is 'implementation of @> operator';

create function pg_catalog.range_contains(anyrange, anyrange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_contains
;

comment on function pg_catalog.range_contains(anyrange, anyrange)
is 'implementation of @> operator';

create function pg_catalog.elem_contained_by_range(anyelement, anyrange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.elem_contained_by_range
;

comment on function pg_catalog.elem_contained_by_range(anyelement, anyrange)
is 'implementation of <@ operator';

create function pg_catalog.range_contained_by(anyrange, anyrange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_contained_by
;

comment on function pg_catalog.range_contained_by(anyrange, anyrange)
is 'implementation of <@ operator';

create function pg_catalog.range_adjacent(anyrange, anyrange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_adjacent
;

comment on function pg_catalog.range_adjacent(anyrange, anyrange)
is 'implementation of -|- operator';

create function pg_catalog.range_before(anyrange, anyrange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_before
;

comment on function pg_catalog.range_before(anyrange, anyrange)
is 'implementation of << operator';

create function pg_catalog.range_after(anyrange, anyrange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_after
;

comment on function pg_catalog.range_after(anyrange, anyrange)
is 'implementation of >> operator';

create function pg_catalog.range_overleft(anyrange, anyrange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_overleft
;

comment on function pg_catalog.range_overleft(anyrange, anyrange)
is 'implementation of &< operator';

create function pg_catalog.range_overright(anyrange, anyrange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_overright
;

comment on function pg_catalog.range_overright(anyrange, anyrange)
is 'implementation of &> operator';

create function pg_catalog.range_union(anyrange, anyrange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_union
;

comment on function pg_catalog.range_union(anyrange, anyrange)
is 'implementation of + operator';

create function pg_catalog.range_intersect(anyrange, anyrange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_intersect
;

comment on function pg_catalog.range_intersect(anyrange, anyrange)
is 'implementation of * operator';

create function pg_catalog.range_minus(anyrange, anyrange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_minus
;

comment on function pg_catalog.range_minus(anyrange, anyrange)
is 'implementation of - operator';

create function pg_catalog.range_cmp(anyrange, anyrange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_cmp
;

comment on function pg_catalog.range_cmp(anyrange, anyrange)
is 'less-equal-greater';

create function pg_catalog.range_lt(anyrange, anyrange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_lt
;

comment on function pg_catalog.range_lt(anyrange, anyrange)
is 'implementation of < operator';

create function pg_catalog.range_le(anyrange, anyrange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_le
;

comment on function pg_catalog.range_le(anyrange, anyrange)
is 'implementation of <= operator';

create function pg_catalog.range_ge(anyrange, anyrange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_ge
;

comment on function pg_catalog.range_ge(anyrange, anyrange)
is 'implementation of >= operator';

create function pg_catalog.range_gt(anyrange, anyrange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_gt
;

comment on function pg_catalog.range_gt(anyrange, anyrange)
is 'implementation of > operator';

create function pg_catalog.range_gist_consistent(internal, anyrange, smallint, oid, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_gist_consistent
;

comment on function pg_catalog.range_gist_consistent(internal, anyrange, smallint, oid, internal)
is 'GiST support';

create function pg_catalog.range_gist_union(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_gist_union
;

comment on function pg_catalog.range_gist_union(internal, internal)
is 'GiST support';

create function pg_catalog.pg_replication_slot_advance(slot_name name, upto_lsn pg_lsn, out slot_name name,
                                                                                        out end_lsn pg_lsn)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_replication_slot_advance
;

comment on function pg_catalog.pg_replication_slot_advance(name, pg_lsn, out name, out pg_lsn)
is 'advance logical replication slot';

create function pg_catalog.range_gist_penalty(internal, internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_gist_penalty
;

comment on function pg_catalog.range_gist_penalty(internal, internal, internal)
is 'GiST support';

create function pg_catalog.range_gist_picksplit(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_gist_picksplit
;

comment on function pg_catalog.range_gist_picksplit(internal, internal)
is 'GiST support';

create function pg_catalog.range_gist_same(anyrange, anyrange, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_gist_same
;

comment on function pg_catalog.range_gist_same(anyrange, anyrange, internal)
is 'GiST support';

create function pg_catalog.hash_range(anyrange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.hash_range
;

comment on function pg_catalog.hash_range(anyrange)
is 'hash a range';

create function pg_catalog.int4range_canonical(int4range)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4range_canonical
;

comment on function pg_catalog.int4range_canonical(int4range)
is 'convert an int4 range to canonical form';

create function pg_catalog.daterange_canonical(daterange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.daterange_canonical
;

comment on function pg_catalog.daterange_canonical(daterange)
is 'convert a date range to canonical form';

create function pg_catalog.range_typanalyze(internal)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_typanalyze
;

comment on function pg_catalog.range_typanalyze(internal)
is 'range typanalyze';

create function pg_catalog.timestamp_transform(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_transform
;

comment on function pg_catalog.timestamp_transform(internal)
is 'transform a timestamp length coercion';

create function pg_catalog.interval_transform(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.interval_transform
;

comment on function pg_catalog.interval_transform(internal)
is 'transform an interval length coercion';

create function pg_catalog.ginarraytriconsistent(internal, smallint, anyarray, integer, internal, internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ginarraytriconsistent
;

comment on function pg_catalog.ginarraytriconsistent(internal, smallint, anyarray, integer, internal, internal,
                                                     internal)
is 'GIN array support';

create function pg_catalog.gin_tsquery_triconsistent(internal, smallint, tsvector, integer, internal, internal,
                                                     internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.gin_tsquery_triconsistent
;

comment on function pg_catalog.gin_tsquery_triconsistent(internal, smallint, tsvector, integer, internal, internal,
                                                         internal)
is 'GIN tsvector support';

create function pg_catalog.int4range_subdiff(integer, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int4range_subdiff
;

comment on function pg_catalog.int4range_subdiff(integer, integer)
is 'float8 difference of two int4 values';

create function pg_catalog.int8range_subdiff(bigint, bigint)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8range_subdiff
;

comment on function pg_catalog.int8range_subdiff(bigint, bigint)
is 'float8 difference of two int8 values';

create function pg_catalog.numrange_subdiff(numeric, numeric)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.numrange_subdiff
;

comment on function pg_catalog.numrange_subdiff(numeric, numeric)
is 'float8 difference of two numeric values';

create function pg_catalog.daterange_subdiff(date, date)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.daterange_subdiff
;

comment on function pg_catalog.daterange_subdiff(date, date)
is 'float8 difference of two date values';

create function pg_catalog.int8range_canonical(int8range)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8range_canonical
;

comment on function pg_catalog.int8range_canonical(int8range)
is 'convert an int8 range to canonical form';

create function pg_catalog.tsrange_subdiff(timestamp, timestamp)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsrange_subdiff
;

comment on function pg_catalog.tsrange_subdiff(timestamp, timestamp)
is 'float8 difference of two timestamp values';

create function pg_catalog.tstzrange_subdiff(timestamp with time zone, timestamp with time zone)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tstzrange_subdiff
;

comment on function pg_catalog.tstzrange_subdiff(timestamp with time zone, timestamp with time zone)
is 'float8 difference of two timestamp with time zone values';

create function pg_catalog.jsonb_object_keys(jsonb)
immutable
strict
parallel safe
cost 1
rows 100
language internal
as
-- missing source code for pg_catalog.jsonb_object_keys
;

comment on function pg_catalog.jsonb_object_keys(jsonb)
is 'get jsonb object keys';

create function pg_catalog.jsonb_each_text(from_json jsonb, out key text, out value text)
immutable
strict
parallel safe
cost 1
rows 100
language internal
as
-- missing source code for pg_catalog.jsonb_each_text
;

comment on function pg_catalog.jsonb_each_text(jsonb, out text, out text)
is 'key value pairs of a jsonb object';

create function pg_catalog.tsrange(timestamp, timestamp)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsrange
;

comment on function pg_catalog.tsrange(timestamp, timestamp)
is 'tsrange constructor';

create function pg_catalog.tsrange(timestamp, timestamp, text)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsrange
;

comment on function pg_catalog.tsrange(timestamp, timestamp, text)
is 'tsrange constructor';

create function pg_catalog.pg_sleep_for(interval)
  returns void
strict
parallel safe
cost 1
language sql
as $$
select pg_catalog.pg_sleep(
         extract(epoch from pg_catalog.clock_timestamp() operator (pg_catalog.+) $1) operator (pg_catalog.-)
         extract(epoch from pg_catalog.clock_timestamp()))
$$;

comment on function pg_catalog.pg_sleep_for(interval)
is 'sleep for the specified interval';

create function pg_catalog.pg_sleep_until(timestamp with time zone)
  returns void
strict
parallel safe
cost 1
language sql
as $$
select pg_catalog.pg_sleep(
         extract(epoch from $1) operator (pg_catalog.-) extract(epoch from pg_catalog.clock_timestamp()))
$$;

comment on function pg_catalog.pg_sleep_until(timestamp with time zone)
is 'sleep until the specified time';

create function pg_catalog.tstzrange(timestamp with time zone, timestamp with time zone)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tstzrange
;

comment on function pg_catalog.tstzrange(timestamp with time zone, timestamp with time zone)
is 'tstzrange constructor';

create function pg_catalog.tstzrange(timestamp with time zone, timestamp with time zone, text)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tstzrange
;

comment on function pg_catalog.tstzrange(timestamp with time zone, timestamp with time zone, text)
is 'tstzrange constructor';

create function pg_catalog.mxid_age(xid)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.mxid_age
;

comment on function pg_catalog.mxid_age(xid)
is 'age of a multi-transaction ID, in multi-transactions before current multi-transaction';

create function pg_catalog.jsonb_extract_path_text(from_json jsonb, path_elems text [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_extract_path_text
;

comment on function pg_catalog.jsonb_extract_path_text(jsonb, text [])
is 'get value from jsonb as text with path elements';

create function pg_catalog.daterange(date, date)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.daterange
;

comment on function pg_catalog.daterange(date, date)
is 'daterange constructor';

create function pg_catalog.daterange(date, date, text)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.daterange
;

comment on function pg_catalog.daterange(date, date, text)
is 'daterange constructor';

create function pg_catalog.acldefault("char", oid)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.acldefault
;

comment on function pg_catalog.acldefault("char", oid)
is 'TODO';

create function pg_catalog.time_transform(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.time_transform
;

comment on function pg_catalog.time_transform(internal)
is 'transform a time length coercion';

create function pg_catalog.int8range(bigint, bigint)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8range
;

comment on function pg_catalog.int8range(bigint, bigint)
is 'int8range constructor';

create function pg_catalog.int8range(bigint, bigint, text)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.int8range
;

comment on function pg_catalog.int8range(bigint, bigint, text)
is 'int8range constructor';

create function pg_catalog.json_object_field(from_json json, field_name text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.json_object_field
;

comment on function pg_catalog.json_object_field(json, text)
is 'implementation of -> operator';

create function pg_catalog.json_object_field_text(from_json json, field_name text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.json_object_field_text
;

comment on function pg_catalog.json_object_field_text(json, text)
is 'implementation of ->> operator';

create function pg_catalog.json_array_element(from_json json, element_index integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.json_array_element
;

comment on function pg_catalog.json_array_element(json, integer)
is 'implementation of -> operator';

create function pg_catalog.json_array_element_text(from_json json, element_index integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.json_array_element_text
;

comment on function pg_catalog.json_array_element_text(json, integer)
is 'implementation of ->> operator';

create function pg_catalog.json_extract_path(from_json json, path_elems text [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.json_extract_path
;

comment on function pg_catalog.json_extract_path(json, text [])
is 'get value from json with path elements';

create function pg_catalog.brin_summarize_new_values(regclass)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.brin_summarize_new_values
;

comment on function pg_catalog.brin_summarize_new_values(regclass)
is 'brin: standalone scan new table pages';

create function pg_catalog.json_extract_path_text(from_json json, path_elems text [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.json_extract_path_text
;

comment on function pg_catalog.json_extract_path_text(json, text [])
is 'get value from json as text with path elements';

create function pg_catalog.pg_get_object_address(type text, object_names text [], object_args text [], out classid oid,
                                                                                                       out objid oid,
                                                                                                       out objsubid integer)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_get_object_address
;

comment on function pg_catalog.pg_get_object_address(text, text [], text [], out oid, out oid, out integer)
is 'get OID-based object address from name/args arrays';

create function pg_catalog.json_array_elements(from_json json, out value json)
immutable
strict
parallel safe
cost 1
rows 100
language internal
as
-- missing source code for pg_catalog.json_array_elements
;

comment on function pg_catalog.json_array_elements(json, out json)
is 'key value pairs of a json object';

create function pg_catalog.json_array_length(json)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.json_array_length
;

comment on function pg_catalog.json_array_length(json)
is 'length of json array';

create function pg_catalog.json_object_keys(json)
immutable
strict
parallel safe
cost 1
rows 100
language internal
as
-- missing source code for pg_catalog.json_object_keys
;

comment on function pg_catalog.json_object_keys(json)
is 'get json object keys';

create function pg_catalog.json_each(from_json json, out key text, out value json)
immutable
strict
parallel safe
cost 1
rows 100
language internal
as
-- missing source code for pg_catalog.json_each
;

comment on function pg_catalog.json_each(json, out text, out json)
is 'key value pairs of a json object';

create function pg_catalog.json_each_text(from_json json, out key text, out value text)
immutable
strict
parallel safe
cost 1
rows 100
language internal
as
-- missing source code for pg_catalog.json_each_text
;

comment on function pg_catalog.json_each_text(json, out text, out text)
is 'key value pairs of a json object';

create function pg_catalog.json_populate_record(base anyelement, from_json json, use_json_as_text boolean default false)
stable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.json_populate_record
;

comment on function pg_catalog.json_populate_record(anyelement, json, boolean)
is 'get record fields from a json object';

create function pg_catalog.json_populate_recordset(base             anyelement, from_json json,
                                                   use_json_as_text boolean default false)
stable
parallel safe
cost 1
rows 100
language internal
as
-- missing source code for pg_catalog.json_populate_recordset
;

comment on function pg_catalog.json_populate_recordset(anyelement, json, boolean)
is 'get set of records with fields from a json array of objects';

create function pg_catalog.json_typeof(json)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.json_typeof
;

comment on function pg_catalog.json_typeof(json)
is 'get the type of a json value';

create function pg_catalog.json_array_elements_text(from_json json, out value text)
immutable
strict
parallel safe
cost 1
rows 100
language internal
as
-- missing source code for pg_catalog.json_array_elements_text
;

comment on function pg_catalog.json_array_elements_text(json, out text)
is 'elements of json array';

create function pg_catalog.ordered_set_transition(internal, "any")
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ordered_set_transition
;

comment on function pg_catalog.ordered_set_transition(internal, "any")
is 'aggregate transition function';

create function pg_catalog.ordered_set_transition_multi(internal, "any")
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.ordered_set_transition_multi
;

comment on function pg_catalog.ordered_set_transition_multi(internal, "any")
is 'aggregate transition function';

create function pg_catalog.percentile_disc_final(internal, double precision, anyelement)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.percentile_disc_final
;

comment on function pg_catalog.percentile_disc_final(internal, double precision, anyelement)
is 'aggregate final function';

create function pg_catalog.percentile_cont_float8_final(internal, double precision)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.percentile_cont_float8_final
;

comment on function pg_catalog.percentile_cont_float8_final(internal, double precision)
is 'aggregate final function';

create function pg_catalog.percentile_cont_interval_final(internal, double precision)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.percentile_cont_interval_final
;

comment on function pg_catalog.percentile_cont_interval_final(internal, double precision)
is 'aggregate final function';

create function pg_catalog.percentile_disc_multi_final(internal, double precision [], anyelement)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.percentile_disc_multi_final
;

comment on function pg_catalog.percentile_disc_multi_final(internal, double precision [], anyelement)
is 'aggregate final function';

create function pg_catalog.percentile_cont_float8_multi_final(internal, double precision [])
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.percentile_cont_float8_multi_final
;

comment on function pg_catalog.percentile_cont_float8_multi_final(internal, double precision [])
is 'aggregate final function';

create function pg_catalog.percentile_cont_interval_multi_final(internal, double precision [])
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.percentile_cont_interval_multi_final
;

comment on function pg_catalog.percentile_cont_interval_multi_final(internal, double precision [])
is 'aggregate final function';

create function pg_catalog.mode_final(internal, anyelement)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.mode_final
;

comment on function pg_catalog.mode_final(internal, anyelement)
is 'aggregate final function';

create function pg_catalog.rank_final(internal, "any")
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.rank_final
;

comment on function pg_catalog.rank_final(internal, "any")
is 'aggregate final function';

create function pg_catalog.percent_rank_final(internal, "any")
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.percent_rank_final
;

comment on function pg_catalog.percent_rank_final(internal, "any")
is 'aggregate final function';

create function pg_catalog.cume_dist_final(internal, "any")
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.cume_dist_final
;

comment on function pg_catalog.cume_dist_final(internal, "any")
is 'aggregate final function';

create function pg_catalog.dense_rank_final(internal, "any")
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.dense_rank_final
;

comment on function pg_catalog.dense_rank_final(internal, "any")
is 'aggregate final function';

create function pg_catalog.timestamp_izone_transform(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_izone_transform
;

comment on function pg_catalog.timestamp_izone_transform(internal)
is 'transform a time zone adjustment';

create function pg_catalog.timestamp_zone_transform(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.timestamp_zone_transform
;

comment on function pg_catalog.timestamp_zone_transform(internal)
is 'transform a time zone adjustment';

create function pg_catalog.brin_summarize_range(regclass, bigint)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.brin_summarize_range
;

comment on function pg_catalog.brin_summarize_range(regclass, bigint)
is 'brin: standalone scan new table pages';

create function pg_catalog.brin_desummarize_range(regclass, bigint)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.brin_desummarize_range
;

comment on function pg_catalog.brin_desummarize_range(regclass, bigint)
is 'brin: desummarize page range';

create function pg_catalog.spg_quad_config(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.spg_quad_config
;

comment on function pg_catalog.spg_quad_config(internal, internal)
is 'SP-GiST support for quad tree over point';

create function pg_catalog.spg_quad_choose(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.spg_quad_choose
;

comment on function pg_catalog.spg_quad_choose(internal, internal)
is 'SP-GiST support for quad tree over point';

create function pg_catalog.spg_quad_picksplit(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.spg_quad_picksplit
;

comment on function pg_catalog.spg_quad_picksplit(internal, internal)
is 'SP-GiST support for quad tree over point';

create function pg_catalog.spg_quad_inner_consistent(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.spg_quad_inner_consistent
;

comment on function pg_catalog.spg_quad_inner_consistent(internal, internal)
is 'SP-GiST support for quad tree over point';

create function pg_catalog.spg_quad_leaf_consistent(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.spg_quad_leaf_consistent
;

comment on function pg_catalog.spg_quad_leaf_consistent(internal, internal)
is 'SP-GiST support for quad tree and k-d tree over point';

create function pg_catalog.spg_kd_config(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.spg_kd_config
;

comment on function pg_catalog.spg_kd_config(internal, internal)
is 'SP-GiST support for k-d tree over point';

create function pg_catalog.spg_kd_choose(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.spg_kd_choose
;

comment on function pg_catalog.spg_kd_choose(internal, internal)
is 'SP-GiST support for k-d tree over point';

create function pg_catalog.spg_kd_picksplit(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.spg_kd_picksplit
;

comment on function pg_catalog.spg_kd_picksplit(internal, internal)
is 'SP-GiST support for k-d tree over point';

create function pg_catalog.spg_kd_inner_consistent(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.spg_kd_inner_consistent
;

comment on function pg_catalog.spg_kd_inner_consistent(internal, internal)
is 'SP-GiST support for k-d tree over point';

create function pg_catalog.spg_text_config(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.spg_text_config
;

comment on function pg_catalog.spg_text_config(internal, internal)
is 'SP-GiST support for radix tree over text';

create function pg_catalog.spg_text_choose(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.spg_text_choose
;

comment on function pg_catalog.spg_text_choose(internal, internal)
is 'SP-GiST support for radix tree over text';

create function pg_catalog.spg_text_picksplit(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.spg_text_picksplit
;

comment on function pg_catalog.spg_text_picksplit(internal, internal)
is 'SP-GiST support for radix tree over text';

create function pg_catalog.spg_text_inner_consistent(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.spg_text_inner_consistent
;

comment on function pg_catalog.spg_text_inner_consistent(internal, internal)
is 'SP-GiST support for radix tree over text';

create function pg_catalog.spg_text_leaf_consistent(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.spg_text_leaf_consistent
;

comment on function pg_catalog.spg_text_leaf_consistent(internal, internal)
is 'SP-GiST support for radix tree over text';

create function pg_catalog.pg_sequence_last_value(regclass)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_sequence_last_value
;

comment on function pg_catalog.pg_sequence_last_value(regclass)
is 'sequence last value';

create function pg_catalog.jsonb_ne(jsonb, jsonb)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_ne
;

comment on function pg_catalog.jsonb_ne(jsonb, jsonb)
is 'implementation of <> operator';

create function pg_catalog.jsonb_lt(jsonb, jsonb)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_lt
;

comment on function pg_catalog.jsonb_lt(jsonb, jsonb)
is 'implementation of < operator';

create function pg_catalog.jsonb_gt(jsonb, jsonb)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_gt
;

comment on function pg_catalog.jsonb_gt(jsonb, jsonb)
is 'implementation of > operator';

create function pg_catalog.jsonb_le(jsonb, jsonb)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_le
;

comment on function pg_catalog.jsonb_le(jsonb, jsonb)
is 'implementation of <= operator';

create function pg_catalog.jsonb_ge(jsonb, jsonb)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_ge
;

comment on function pg_catalog.jsonb_ge(jsonb, jsonb)
is 'implementation of >= operator';

create function pg_catalog.jsonb_eq(jsonb, jsonb)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_eq
;

comment on function pg_catalog.jsonb_eq(jsonb, jsonb)
is 'implementation of = operator';

create function pg_catalog.jsonb_cmp(jsonb, jsonb)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_cmp
;

comment on function pg_catalog.jsonb_cmp(jsonb, jsonb)
is 'less-equal-greater';

create function pg_catalog.jsonb_hash(jsonb)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_hash
;

comment on function pg_catalog.jsonb_hash(jsonb)
is 'hash';

create function pg_catalog.jsonb_contains(jsonb, jsonb)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_contains
;

comment on function pg_catalog.jsonb_contains(jsonb, jsonb)
is 'implementation of @> operator';

create function pg_catalog.jsonb_exists(jsonb, text)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_exists
;

comment on function pg_catalog.jsonb_exists(jsonb, text)
is 'implementation of ? operator';

create function pg_catalog.jsonb_exists_any(jsonb, text [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_exists_any
;

comment on function pg_catalog.jsonb_exists_any(jsonb, text [])
is 'implementation of ?| operator';

create function pg_catalog.jsonb_exists_all(jsonb, text [])
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_exists_all
;

comment on function pg_catalog.jsonb_exists_all(jsonb, text [])
is 'implementation of ?& operator';

create function pg_catalog.jsonb_contained(jsonb, jsonb)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.jsonb_contained
;

comment on function pg_catalog.jsonb_contained(jsonb, jsonb)
is 'implementation of <@ operator';

create function pg_catalog.array_agg_array_transfn(internal, anyarray)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_agg_array_transfn
;

comment on function pg_catalog.array_agg_array_transfn(internal, anyarray)
is 'aggregate transition function';

create function pg_catalog.array_agg_array_finalfn(internal, anyarray)
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.array_agg_array_finalfn
;

comment on function pg_catalog.array_agg_array_finalfn(internal, anyarray)
is 'aggregate final function';

create function pg_catalog.range_merge(anyrange, anyrange)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.range_merge
;

comment on function pg_catalog.range_merge(anyrange, anyrange)
is 'the smallest range which includes both of the given ranges';

create function pg_catalog.inet_merge(inet, inet)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inet_merge
;

comment on function pg_catalog.inet_merge(inet, inet)
is 'the smallest network which includes both of the given networks';

create function pg_catalog.bound_box(box, box)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.bound_box
;

comment on function pg_catalog.bound_box(box, box)
is 'bounding box of two boxes';

create function pg_catalog.inet_same_family(inet, inet)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.inet_same_family
;

comment on function pg_catalog.inet_same_family(inet, inet)
is 'are the addresses from the same family?';

create function pg_catalog.binary_upgrade_set_record_init_privs(boolean)
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.binary_upgrade_set_record_init_privs
;

comment on function pg_catalog.binary_upgrade_set_record_init_privs(boolean)
is 'for use by pg_upgrade';

create function pg_catalog.regnamespacein(cstring)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regnamespacein
;

comment on function pg_catalog.regnamespacein(cstring)
is 'I/O';

create function pg_catalog.regnamespaceout(regnamespace)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regnamespaceout
;

comment on function pg_catalog.regnamespaceout(regnamespace)
is 'I/O';

create function pg_catalog.to_regnamespace(text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.to_regnamespace
;

comment on function pg_catalog.to_regnamespace(text)
is 'convert namespace name to regnamespace';

create function pg_catalog.regnamespacerecv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regnamespacerecv
;

comment on function pg_catalog.regnamespacerecv(internal)
is 'I/O';

create function pg_catalog.regnamespacesend(regnamespace)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regnamespacesend
;

comment on function pg_catalog.regnamespacesend(regnamespace)
is 'I/O';

create function pg_catalog.box(point)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.box
;

comment on function pg_catalog.box(point)
is 'convert point to empty box';

create function pg_catalog.regroleout(regrole)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regroleout
;

comment on function pg_catalog.regroleout(regrole)
is 'I/O';

create function pg_catalog.to_regrole(text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.to_regrole
;

comment on function pg_catalog.to_regrole(text)
is 'convert role name to regrole';

create function pg_catalog.regrolerecv(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regrolerecv
;

comment on function pg_catalog.regrolerecv(internal)
is 'I/O';

create function pg_catalog.regrolesend(regrole)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regrolesend
;

comment on function pg_catalog.regrolesend(regrole)
is 'I/O';

create function pg_catalog.regrolein(cstring)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.regrolein
;

comment on function pg_catalog.regrolein(cstring)
is 'I/O';

create function pg_catalog.pg_rotate_logfile_old()
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_rotate_logfile_old
;

comment on function pg_catalog.pg_rotate_logfile_old()
is 'rotate log file - old version for adminpack 1.0';

create function pg_catalog.pg_read_file_old(text, bigint, bigint)
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_read_file_old
;

comment on function pg_catalog.pg_read_file_old(text, bigint, bigint)
is 'read text from a file - old version for adminpack 1.0';

create function pg_catalog.binary_upgrade_set_missing_value(oid, text, text)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.binary_upgrade_set_missing_value
;

comment on function pg_catalog.binary_upgrade_set_missing_value(oid, text, text)
is 'for use by pg_upgrade';

create function pg_catalog.brin_inclusion_opcinfo(internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.brin_inclusion_opcinfo
;

comment on function pg_catalog.brin_inclusion_opcinfo(internal)
is 'BRIN inclusion support';

create function pg_catalog.brin_inclusion_add_value(internal, internal, internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.brin_inclusion_add_value
;

comment on function pg_catalog.brin_inclusion_add_value(internal, internal, internal, internal)
is 'BRIN inclusion support';

create function pg_catalog.brin_inclusion_consistent(internal, internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.brin_inclusion_consistent
;

comment on function pg_catalog.brin_inclusion_consistent(internal, internal, internal)
is 'BRIN inclusion support';

create function pg_catalog.brin_inclusion_union(internal, internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.brin_inclusion_union
;

comment on function pg_catalog.brin_inclusion_union(internal, internal, internal)
is 'BRIN inclusion support';

create function pg_catalog.macaddr8_in(cstring)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr8_in
;

comment on function pg_catalog.macaddr8_in(cstring)
is 'I/O';

create function pg_catalog.macaddr8_out(macaddr8)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr8_out
;

comment on function pg_catalog.macaddr8_out(macaddr8)
is 'I/O';

create function pg_catalog.trunc(macaddr8)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.trunc
;

comment on function pg_catalog.trunc(macaddr8)
is 'MACADDR8 manufacturer fields';

create function pg_catalog.macaddr8_eq(macaddr8, macaddr8)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr8_eq
;

comment on function pg_catalog.macaddr8_eq(macaddr8, macaddr8)
is 'implementation of = operator';

create function pg_catalog.macaddr8_lt(macaddr8, macaddr8)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr8_lt
;

comment on function pg_catalog.macaddr8_lt(macaddr8, macaddr8)
is 'implementation of < operator';

create function pg_catalog.macaddr8_le(macaddr8, macaddr8)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr8_le
;

comment on function pg_catalog.macaddr8_le(macaddr8, macaddr8)
is 'implementation of <= operator';

create function pg_catalog.macaddr8_gt(macaddr8, macaddr8)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr8_gt
;

comment on function pg_catalog.macaddr8_gt(macaddr8, macaddr8)
is 'implementation of > operator';

create function pg_catalog.macaddr8_ge(macaddr8, macaddr8)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr8_ge
;

comment on function pg_catalog.macaddr8_ge(macaddr8, macaddr8)
is 'implementation of >= operator';

create function pg_catalog.macaddr8_ne(macaddr8, macaddr8)
immutable
leakproof
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr8_ne
;

comment on function pg_catalog.macaddr8_ne(macaddr8, macaddr8)
is 'implementation of <> operator';

create function pg_catalog.macaddr8_cmp(macaddr8, macaddr8)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr8_cmp
;

comment on function pg_catalog.macaddr8_cmp(macaddr8, macaddr8)
is 'less-equal-greater';

create function pg_catalog.macaddr8_not(macaddr8)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr8_not
;

comment on function pg_catalog.macaddr8_not(macaddr8)
is 'implementation of ~ operator';

create function pg_catalog.macaddr8_and(macaddr8, macaddr8)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr8_and
;

comment on function pg_catalog.macaddr8_and(macaddr8, macaddr8)
is 'implementation of & operator';

create function pg_catalog.macaddr8_or(macaddr8, macaddr8)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr8_or
;

comment on function pg_catalog.macaddr8_or(macaddr8, macaddr8)
is 'implementation of | operator';

create function pg_catalog.macaddr8(macaddr)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr8
;

comment on function pg_catalog.macaddr8(macaddr)
is 'convert macaddr to macaddr8';

create function pg_catalog.macaddr(macaddr8)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr
;

comment on function pg_catalog.macaddr(macaddr8)
is 'convert macaddr8 to macaddr';

create function pg_catalog.macaddr8_set7bit(macaddr8)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.macaddr8_set7bit
;

comment on function pg_catalog.macaddr8_set7bit(macaddr8)
is 'set 7th bit in macaddr8';

create function pg_catalog.in_range(bigint, bigint, bigint, boolean, boolean)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.in_range
;

comment on function pg_catalog.in_range(bigint, bigint, bigint, boolean, boolean)
is 'window RANGE support';

create function pg_catalog.in_range(integer, integer, bigint, boolean, boolean)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.in_range
;

comment on function pg_catalog.in_range(integer, integer, bigint, boolean, boolean)
is 'window RANGE support';

create function pg_catalog.in_range(integer, integer, integer, boolean, boolean)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.in_range
;

comment on function pg_catalog.in_range(integer, integer, integer, boolean, boolean)
is 'window RANGE support';

create function pg_catalog.in_range(integer, integer, smallint, boolean, boolean)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.in_range
;

comment on function pg_catalog.in_range(integer, integer, smallint, boolean, boolean)
is 'window RANGE support';

create function pg_catalog.in_range(smallint, smallint, bigint, boolean, boolean)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.in_range
;

comment on function pg_catalog.in_range(smallint, smallint, bigint, boolean, boolean)
is 'window RANGE support';

create function pg_catalog.in_range(smallint, smallint, integer, boolean, boolean)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.in_range
;

comment on function pg_catalog.in_range(smallint, smallint, integer, boolean, boolean)
is 'window RANGE support';

create function pg_catalog.in_range(smallint, smallint, smallint, boolean, boolean)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.in_range
;

comment on function pg_catalog.in_range(smallint, smallint, smallint, boolean, boolean)
is 'window RANGE support';

create function pg_catalog.in_range(date, date, interval, boolean, boolean)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.in_range
;

comment on function pg_catalog.in_range(date, date, interval, boolean, boolean)
is 'window RANGE support';

create function pg_catalog.in_range(timestamp, timestamp, interval, boolean, boolean)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.in_range
;

comment on function pg_catalog.in_range(timestamp, timestamp, interval, boolean, boolean)
is 'window RANGE support';

create function pg_catalog.in_range(timestamp with time zone, timestamp with time zone, interval, boolean, boolean)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.in_range
;

comment on function pg_catalog.in_range(timestamp with time zone, timestamp with time zone, interval, boolean, boolean)
is 'window RANGE support';

create function pg_catalog.in_range(interval, interval, interval, boolean, boolean)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.in_range
;

comment on function pg_catalog.in_range(interval, interval, interval, boolean, boolean)
is 'window RANGE support';

create function pg_catalog.in_range(time, time, interval, boolean, boolean)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.in_range
;

comment on function pg_catalog.in_range(time, time, interval, boolean, boolean)
is 'window RANGE support';

create function pg_catalog.in_range(time with time zone, time with time zone, interval, boolean, boolean)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.in_range
;

comment on function pg_catalog.in_range(time with time zone, time with time zone, interval, boolean, boolean)
is 'window RANGE support';

create function pg_catalog.in_range(double precision, double precision, double precision, boolean, boolean)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.in_range
;

comment on function pg_catalog.in_range(double precision, double precision, double precision, boolean, boolean)
is 'window RANGE support';

create function pg_catalog.in_range(real, real, double precision, boolean, boolean)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.in_range
;

comment on function pg_catalog.in_range(real, real, double precision, boolean, boolean)
is 'window RANGE support';

create function pg_catalog.in_range(numeric, numeric, numeric, boolean, boolean)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.in_range
;

comment on function pg_catalog.in_range(numeric, numeric, numeric, boolean, boolean)
is 'window RANGE support';

create function pg_catalog.ts_headline(regconfig, jsonb, tsquery, text)
immutable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.ts_headline
;

comment on function pg_catalog.ts_headline(regconfig, jsonb, tsquery, text)
is 'generate headline from jsonb';

create function pg_catalog.ts_headline(regconfig, jsonb, tsquery)
immutable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.ts_headline
;

comment on function pg_catalog.ts_headline(regconfig, jsonb, tsquery)
is 'generate headline from jsonb';

create function pg_catalog.ts_headline(jsonb, tsquery, text)
stable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.ts_headline
;

comment on function pg_catalog.ts_headline(jsonb, tsquery, text)
is 'generate headline from jsonb';

create function pg_catalog.ts_headline(jsonb, tsquery)
stable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.ts_headline
;

comment on function pg_catalog.ts_headline(jsonb, tsquery)
is 'generate headline from jsonb';

create function pg_catalog.ts_headline(regconfig, json, tsquery, text)
immutable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.ts_headline
;

comment on function pg_catalog.ts_headline(regconfig, json, tsquery, text)
is 'generate headline from json';

create function pg_catalog.ts_headline(regconfig, json, tsquery)
immutable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.ts_headline
;

comment on function pg_catalog.ts_headline(regconfig, json, tsquery)
is 'generate headline from json';

create function pg_catalog.ts_headline(json, tsquery, text)
stable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.ts_headline
;

comment on function pg_catalog.ts_headline(json, tsquery, text)
is 'generate headline from json';

create function pg_catalog.ts_headline(json, tsquery)
stable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.ts_headline
;

comment on function pg_catalog.ts_headline(json, tsquery)
is 'generate headline from json';

create function pg_catalog.to_tsvector(jsonb)
stable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.to_tsvector
;

comment on function pg_catalog.to_tsvector(jsonb)
is 'transform string values from jsonb to tsvector';

create function pg_catalog.to_tsvector(json)
stable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.to_tsvector
;

comment on function pg_catalog.to_tsvector(json)
is 'transform string values from json to tsvector';

create function pg_catalog.to_tsvector(regconfig, jsonb)
immutable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.to_tsvector
;

comment on function pg_catalog.to_tsvector(regconfig, jsonb)
is 'transform string values from jsonb to tsvector';

create function pg_catalog.to_tsvector(regconfig, json)
immutable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.to_tsvector
;

comment on function pg_catalog.to_tsvector(regconfig, json)
is 'transform string values from json to tsvector';

create function pg_catalog.jsonb_to_tsvector(jsonb, jsonb)
stable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.jsonb_to_tsvector
;

comment on function pg_catalog.jsonb_to_tsvector(jsonb, jsonb)
is 'transform specified values from jsonb to tsvector';

create function pg_catalog.jsonb_to_tsvector(regconfig, jsonb, jsonb)
immutable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.jsonb_to_tsvector
;

comment on function pg_catalog.jsonb_to_tsvector(regconfig, jsonb, jsonb)
is 'transform specified values from jsonb to tsvector';

create function pg_catalog.json_to_tsvector(json, jsonb)
stable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.json_to_tsvector
;

comment on function pg_catalog.json_to_tsvector(json, jsonb)
is 'transform specified values from json to tsvector';

create function pg_catalog.json_to_tsvector(regconfig, json, jsonb)
immutable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.json_to_tsvector
;

comment on function pg_catalog.json_to_tsvector(regconfig, json, jsonb)
is 'transform specified values from json to tsvector';

create function pg_catalog.pg_event_trigger_table_rewrite_oid(out oid oid)
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_event_trigger_table_rewrite_oid
;

comment on function pg_catalog.pg_event_trigger_table_rewrite_oid(out oid)
is 'return Oid of the table getting rewritten';

create function pg_catalog.pg_event_trigger_table_rewrite_reason()
stable
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_event_trigger_table_rewrite_reason
;

comment on function pg_catalog.pg_event_trigger_table_rewrite_reason()
is 'return reason code for table getting rewritten';

create function pg_catalog.pg_event_trigger_ddl_commands(out classid      oid, out objid oid, out objsubid integer,
                                                         out command_tag  text, out object_type text,
                                                         out schema_name  text, out object_identity text,
                                                         out in_extension boolean, out command pg_ddl_command)
stable
strict
parallel restricted
cost 10
rows 100
language internal
as
-- missing source code for pg_catalog.pg_event_trigger_ddl_commands
;

comment on function pg_catalog.pg_event_trigger_ddl_commands(out oid, out oid, out integer, out text, out text,
                                                             out text, out text, out boolean, out pg_ddl_command)
is 'list DDL actions being executed by the current command';

create function pg_catalog.phraseto_tsquery(text)
stable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.phraseto_tsquery
;

comment on function pg_catalog.phraseto_tsquery(text)
is 'transform to tsquery';

create function pg_catalog.tsquery_phrase(tsquery, tsquery)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsquery_phrase
;

comment on function pg_catalog.tsquery_phrase(tsquery, tsquery)
is 'implementation of <-> operator';

create function pg_catalog.tsquery_phrase(tsquery, tsquery, integer)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.tsquery_phrase
;

comment on function pg_catalog.tsquery_phrase(tsquery, tsquery, integer)
is 'phrase-concatenate with distance';

create function pg_catalog.phraseto_tsquery(regconfig, text)
immutable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.phraseto_tsquery
;

comment on function pg_catalog.phraseto_tsquery(regconfig, text)
is 'transform to tsquery';

create function pg_catalog.websearch_to_tsquery(regconfig, text)
immutable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.websearch_to_tsquery
;

comment on function pg_catalog.websearch_to_tsquery(regconfig, text)
is 'transform to tsquery';

create function pg_catalog.websearch_to_tsquery(text)
stable
strict
parallel safe
language internal
as
-- missing source code for pg_catalog.websearch_to_tsquery
;

comment on function pg_catalog.websearch_to_tsquery(text)
is 'transform to tsquery';

create function pg_catalog.spg_bbox_quad_config(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.spg_bbox_quad_config
;

comment on function pg_catalog.spg_bbox_quad_config(internal, internal)
is 'SP-GiST support for quad tree over 2-D types represented by their bounding boxes';

create function pg_catalog.spg_poly_quad_compress(polygon)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.spg_poly_quad_compress
;

comment on function pg_catalog.spg_poly_quad_compress(polygon)
is 'SP-GiST support for quad tree over polygons';

create function pg_catalog.spg_box_quad_config(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.spg_box_quad_config
;

comment on function pg_catalog.spg_box_quad_config(internal, internal)
is 'SP-GiST support for quad tree over box';

create function pg_catalog.spg_box_quad_choose(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.spg_box_quad_choose
;

comment on function pg_catalog.spg_box_quad_choose(internal, internal)
is 'SP-GiST support for quad tree over box';

create function pg_catalog.spg_box_quad_picksplit(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.spg_box_quad_picksplit
;

comment on function pg_catalog.spg_box_quad_picksplit(internal, internal)
is 'SP-GiST support for quad tree over box';

create function pg_catalog.spg_box_quad_inner_consistent(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.spg_box_quad_inner_consistent
;

comment on function pg_catalog.spg_box_quad_inner_consistent(internal, internal)
is 'SP-GiST support for quad tree over box';

create function pg_catalog.spg_box_quad_leaf_consistent(internal, internal)
immutable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.spg_box_quad_leaf_consistent
;

comment on function pg_catalog.spg_box_quad_leaf_consistent(internal, internal)
is 'SP-GiST support for quad tree over box';

create function pg_catalog.satisfies_hash_partition(oid, integer, integer, "any")
immutable
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.satisfies_hash_partition
;

comment on function pg_catalog.satisfies_hash_partition(oid, integer, integer, "any")
is 'hash partition CHECK constraint';

create function pg_catalog.pg_replication_origin_create(text)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_replication_origin_create
;

comment on function pg_catalog.pg_replication_origin_create(text)
is 'create a replication origin';

create function pg_catalog.pg_replication_origin_drop(text)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_replication_origin_drop
;

comment on function pg_catalog.pg_replication_origin_drop(text)
is 'drop replication origin identified by its name';

create function pg_catalog.pg_replication_origin_oid(text)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_replication_origin_oid
;

comment on function pg_catalog.pg_replication_origin_oid(text)
is 'translate the replication origin''s name to its id';

create function pg_catalog.pg_replication_origin_session_setup(text)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_replication_origin_session_setup
;

comment on function pg_catalog.pg_replication_origin_session_setup(text)
is 'configure session to maintain replication progress tracking for the passed in origin';

create function pg_catalog.pg_replication_origin_session_reset()
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_replication_origin_session_reset
;

comment on function pg_catalog.pg_replication_origin_session_reset()
is 'teardown configured replication progress tracking';

create function pg_catalog.pg_replication_origin_session_is_setup()
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_replication_origin_session_is_setup
;

comment on function pg_catalog.pg_replication_origin_session_is_setup()
is 'is a replication origin configured in this session';

create function pg_catalog.pg_replication_origin_session_progress(boolean)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_replication_origin_session_progress
;

comment on function pg_catalog.pg_replication_origin_session_progress(boolean)
is 'get the replication progress of the current session';

create function pg_catalog.pg_replication_origin_xact_setup(pg_lsn, timestamp with time zone)
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_replication_origin_xact_setup
;

comment on function pg_catalog.pg_replication_origin_xact_setup(pg_lsn, timestamp with time zone)
is 'setup the transaction''s origin lsn and timestamp';

create function pg_catalog.pg_replication_origin_xact_reset()
strict
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_replication_origin_xact_reset
;

comment on function pg_catalog.pg_replication_origin_xact_reset()
is 'reset the transaction''s origin lsn and timestamp';

create function pg_catalog.pg_replication_origin_advance(text, pg_lsn)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_replication_origin_advance
;

comment on function pg_catalog.pg_replication_origin_advance(text, pg_lsn)
is 'advance replication identifier to specific location';

create function pg_catalog.pg_replication_origin_progress(text, boolean)
strict
cost 1
language internal
as
-- missing source code for pg_catalog.pg_replication_origin_progress
;

comment on function pg_catalog.pg_replication_origin_progress(text, boolean)
is 'get an individual replication origin''s replication progress';

create function pg_catalog.pg_show_replication_origin_status(out local_id   oid, out external_id text,
                                                             out remote_lsn pg_lsn, out local_lsn pg_lsn)
parallel restricted
cost 1
rows 100
language internal
as
-- missing source code for pg_catalog.pg_show_replication_origin_status
;

comment on function pg_catalog.pg_show_replication_origin_status(out oid, out text, out pg_lsn, out pg_lsn)
is 'get progress for all replication origins';

create function pg_catalog.pg_stat_get_subscription(subid oid, out subid oid, out relid oid, out pid integer,
                                                               out received_lsn pg_lsn,
                                                               out last_msg_send_time timestamp with time zone,
                                                               out last_msg_receipt_time timestamp with time zone,
                                                               out latest_end_lsn pg_lsn,
                                                               out latest_end_time timestamp with time zone)
stable
parallel restricted
cost 1
language internal
as
-- missing source code for pg_catalog.pg_stat_get_subscription
;

comment on function pg_catalog.pg_stat_get_subscription(oid, out oid, out oid, out integer, out pg_lsn,
                                                             out timestamp with time zone, out timestamp with time zone,
                                                             out pg_lsn, out timestamp with time zone)
is 'statistics: information about subscription';

create function pg_catalog.pg_get_publication_tables(pubname text, out relid oid)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_get_publication_tables
;

comment on function pg_catalog.pg_get_publication_tables(text, out oid)
is 'get OIDs of tables in a publication';

create function pg_catalog.pg_get_replica_identity_index(regclass)
stable
strict
parallel safe
cost 10
language internal
as
-- missing source code for pg_catalog.pg_get_replica_identity_index
;

comment on function pg_catalog.pg_get_replica_identity_index(regclass)
is 'oid of replica identity index if any';

create function pg_catalog.pg_relation_is_publishable(regclass)
stable
strict
parallel safe
cost 1
language internal
as
-- missing source code for pg_catalog.pg_relation_is_publishable
;

comment on function pg_catalog.pg_relation_is_publishable(regclass)
is 'returns whether a relation can be part of a publication';

create function pg_catalog.ts_debug(config regconfig, document text, OUT alias text, OUT description text,
                                                                     OUT token text, OUT dictionaries regdictionary [],
                                                                     OUT dictionary regdictionary, OUT lexemes text [])
  returns SETOF record
stable
strict
parallel safe
language sql
as $$
SELECT tt.alias       AS alias,
       tt.description AS description,
       parse.token    AS token,
       ARRAY(SELECT m.mapdict :: pg_catalog.regdictionary
             FROM pg_catalog.pg_ts_config_map AS m
             WHERE m.mapcfg = $1
               AND m.maptokentype = parse.tokid
             ORDER BY m.mapseqno)
                      AS dictionaries,
       (SELECT mapdict :: pg_catalog.regdictionary
        FROM pg_catalog.pg_ts_config_map AS m
        WHERE m.mapcfg = $1
          AND m.maptokentype = parse.tokid
        ORDER BY pg_catalog.ts_lexize(mapdict, parse.token) IS NULL, m.mapseqno
        LIMIT 1)      AS dictionary,
       (SELECT pg_catalog.ts_lexize(mapdict, parse.token)
        FROM pg_catalog.pg_ts_config_map AS m
        WHERE m.mapcfg = $1
          AND m.maptokentype = parse.tokid
        ORDER BY pg_catalog.ts_lexize(mapdict, parse.token) IS NULL, m.mapseqno
        LIMIT 1)      AS lexemes
FROM pg_catalog.ts_parse(
       (SELECT cfgparser FROM pg_catalog.pg_ts_config WHERE oid = $1), $2
         ) AS parse,
     pg_catalog.ts_token_type(
       (SELECT cfgparser FROM pg_catalog.pg_ts_config WHERE oid = $1)
         ) AS tt
WHERE tt.tokid = parse.tokid
$$;

comment on function pg_catalog.ts_debug(regconfig, text, out text, out text, out text, out regdictionary [],
                                                         out regdictionary, out text [])
is 'debug function for text search configuration';

create function pg_catalog.ts_debug(document text, OUT alias text, OUT description text, OUT token text,
                                                   OUT dictionaries regdictionary [], OUT dictionary regdictionary,
                                                   OUT lexemes text [])
  returns SETOF record
stable
strict
parallel safe
language sql
as $$
SELECT *
FROM pg_catalog.ts_debug(pg_catalog.get_current_ts_config(), $1);
$$;

comment on function pg_catalog.ts_debug(text, out text, out text, out text, out regdictionary [], out regdictionary,
                                              out text [])
is 'debug function for current text search configuration';

create function pg_catalog.ascii_to_mic(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.ascii_to_mic
;

comment on function pg_catalog.ascii_to_mic(integer, integer, cstring, internal, integer)
is 'internal conversion function for SQL_ASCII to MULE_INTERNAL';

create function pg_catalog.mic_to_ascii(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.mic_to_ascii
;

comment on function pg_catalog.mic_to_ascii(integer, integer, cstring, internal, integer)
is 'internal conversion function for MULE_INTERNAL to SQL_ASCII';

create function pg_catalog.koi8r_to_mic(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.koi8r_to_mic
;

comment on function pg_catalog.koi8r_to_mic(integer, integer, cstring, internal, integer)
is 'internal conversion function for KOI8R to MULE_INTERNAL';

create function pg_catalog.mic_to_koi8r(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.mic_to_koi8r
;

comment on function pg_catalog.mic_to_koi8r(integer, integer, cstring, internal, integer)
is 'internal conversion function for MULE_INTERNAL to KOI8R';

create function pg_catalog.iso_to_mic(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.iso_to_mic
;

comment on function pg_catalog.iso_to_mic(integer, integer, cstring, internal, integer)
is 'internal conversion function for ISO-8859-5 to MULE_INTERNAL';

create function pg_catalog.mic_to_iso(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.mic_to_iso
;

comment on function pg_catalog.mic_to_iso(integer, integer, cstring, internal, integer)
is 'internal conversion function for MULE_INTERNAL to ISO-8859-5';

create function pg_catalog.win1251_to_mic(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.win1251_to_mic
;

comment on function pg_catalog.win1251_to_mic(integer, integer, cstring, internal, integer)
is 'internal conversion function for WIN1251 to MULE_INTERNAL';

create function pg_catalog.mic_to_win1251(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.mic_to_win1251
;

comment on function pg_catalog.mic_to_win1251(integer, integer, cstring, internal, integer)
is 'internal conversion function for MULE_INTERNAL to WIN1251';

create function pg_catalog.win866_to_mic(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.win866_to_mic
;

comment on function pg_catalog.win866_to_mic(integer, integer, cstring, internal, integer)
is 'internal conversion function for WIN866 to MULE_INTERNAL';

create function pg_catalog.mic_to_win866(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.mic_to_win866
;

comment on function pg_catalog.mic_to_win866(integer, integer, cstring, internal, integer)
is 'internal conversion function for MULE_INTERNAL to WIN866';

create function pg_catalog.koi8r_to_win1251(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.koi8r_to_win1251
;

comment on function pg_catalog.koi8r_to_win1251(integer, integer, cstring, internal, integer)
is 'internal conversion function for KOI8R to WIN1251';

create function pg_catalog.win1251_to_koi8r(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.win1251_to_koi8r
;

comment on function pg_catalog.win1251_to_koi8r(integer, integer, cstring, internal, integer)
is 'internal conversion function for WIN1251 to KOI8R';

create function pg_catalog.koi8r_to_win866(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.koi8r_to_win866
;

comment on function pg_catalog.koi8r_to_win866(integer, integer, cstring, internal, integer)
is 'internal conversion function for KOI8R to WIN866';

create function pg_catalog.win866_to_koi8r(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.win866_to_koi8r
;

comment on function pg_catalog.win866_to_koi8r(integer, integer, cstring, internal, integer)
is 'internal conversion function for WIN866 to KOI8R';

create function pg_catalog.win866_to_win1251(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.win866_to_win1251
;

comment on function pg_catalog.win866_to_win1251(integer, integer, cstring, internal, integer)
is 'internal conversion function for WIN866 to WIN1251';

create function pg_catalog.win1251_to_win866(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.win1251_to_win866
;

comment on function pg_catalog.win1251_to_win866(integer, integer, cstring, internal, integer)
is 'internal conversion function for WIN1251 to WIN866';

create function pg_catalog.iso_to_koi8r(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.iso_to_koi8r
;

comment on function pg_catalog.iso_to_koi8r(integer, integer, cstring, internal, integer)
is 'internal conversion function for ISO-8859-5 to KOI8R';

create function pg_catalog.koi8r_to_iso(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.koi8r_to_iso
;

comment on function pg_catalog.koi8r_to_iso(integer, integer, cstring, internal, integer)
is 'internal conversion function for KOI8R to ISO-8859-5';

create function pg_catalog.iso_to_win1251(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.iso_to_win1251
;

comment on function pg_catalog.iso_to_win1251(integer, integer, cstring, internal, integer)
is 'internal conversion function for ISO-8859-5 to WIN1251';

create function pg_catalog.win1251_to_iso(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.win1251_to_iso
;

comment on function pg_catalog.win1251_to_iso(integer, integer, cstring, internal, integer)
is 'internal conversion function for WIN1251 to ISO-8859-5';

create function pg_catalog.iso_to_win866(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.iso_to_win866
;

comment on function pg_catalog.iso_to_win866(integer, integer, cstring, internal, integer)
is 'internal conversion function for ISO-8859-5 to WIN866';

create function pg_catalog.win866_to_iso(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.win866_to_iso
;

comment on function pg_catalog.win866_to_iso(integer, integer, cstring, internal, integer)
is 'internal conversion function for WIN866 to ISO-8859-5';

create function pg_catalog.euc_cn_to_mic(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.euc_cn_to_mic
;

comment on function pg_catalog.euc_cn_to_mic(integer, integer, cstring, internal, integer)
is 'internal conversion function for EUC_CN to MULE_INTERNAL';

create function pg_catalog.mic_to_euc_cn(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.mic_to_euc_cn
;

comment on function pg_catalog.mic_to_euc_cn(integer, integer, cstring, internal, integer)
is 'internal conversion function for MULE_INTERNAL to EUC_CN';

create function pg_catalog.euc_jp_to_sjis(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.euc_jp_to_sjis
;

comment on function pg_catalog.euc_jp_to_sjis(integer, integer, cstring, internal, integer)
is 'internal conversion function for EUC_JP to SJIS';

create function pg_catalog.sjis_to_euc_jp(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.sjis_to_euc_jp
;

comment on function pg_catalog.sjis_to_euc_jp(integer, integer, cstring, internal, integer)
is 'internal conversion function for SJIS to EUC_JP';

create function pg_catalog.euc_jp_to_mic(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.euc_jp_to_mic
;

comment on function pg_catalog.euc_jp_to_mic(integer, integer, cstring, internal, integer)
is 'internal conversion function for EUC_JP to MULE_INTERNAL';

create function pg_catalog.sjis_to_mic(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.sjis_to_mic
;

comment on function pg_catalog.sjis_to_mic(integer, integer, cstring, internal, integer)
is 'internal conversion function for SJIS to MULE_INTERNAL';

create function pg_catalog.mic_to_euc_jp(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.mic_to_euc_jp
;

comment on function pg_catalog.mic_to_euc_jp(integer, integer, cstring, internal, integer)
is 'internal conversion function for MULE_INTERNAL to EUC_JP';

create function pg_catalog.mic_to_sjis(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.mic_to_sjis
;

comment on function pg_catalog.mic_to_sjis(integer, integer, cstring, internal, integer)
is 'internal conversion function for MULE_INTERNAL to SJIS';

create function pg_catalog.euc_kr_to_mic(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.euc_kr_to_mic
;

comment on function pg_catalog.euc_kr_to_mic(integer, integer, cstring, internal, integer)
is 'internal conversion function for EUC_KR to MULE_INTERNAL';

create function pg_catalog.mic_to_euc_kr(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.mic_to_euc_kr
;

comment on function pg_catalog.mic_to_euc_kr(integer, integer, cstring, internal, integer)
is 'internal conversion function for MULE_INTERNAL to EUC_KR';

create function pg_catalog.euc_tw_to_big5(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.euc_tw_to_big5
;

comment on function pg_catalog.euc_tw_to_big5(integer, integer, cstring, internal, integer)
is 'internal conversion function for EUC_TW to BIG5';

create function pg_catalog.big5_to_euc_tw(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.big5_to_euc_tw
;

comment on function pg_catalog.big5_to_euc_tw(integer, integer, cstring, internal, integer)
is 'internal conversion function for BIG5 to EUC_TW';

create function pg_catalog.euc_tw_to_mic(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.euc_tw_to_mic
;

comment on function pg_catalog.euc_tw_to_mic(integer, integer, cstring, internal, integer)
is 'internal conversion function for EUC_TW to MULE_INTERNAL';

create function pg_catalog.big5_to_mic(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.big5_to_mic
;

comment on function pg_catalog.big5_to_mic(integer, integer, cstring, internal, integer)
is 'internal conversion function for BIG5 to MULE_INTERNAL';

create function pg_catalog.mic_to_euc_tw(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.mic_to_euc_tw
;

comment on function pg_catalog.mic_to_euc_tw(integer, integer, cstring, internal, integer)
is 'internal conversion function for MULE_INTERNAL to EUC_TW';

create function pg_catalog.mic_to_big5(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.mic_to_big5
;

comment on function pg_catalog.mic_to_big5(integer, integer, cstring, internal, integer)
is 'internal conversion function for MULE_INTERNAL to BIG5';

create function pg_catalog.latin2_to_mic(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.latin2_to_mic
;

comment on function pg_catalog.latin2_to_mic(integer, integer, cstring, internal, integer)
is 'internal conversion function for LATIN2 to MULE_INTERNAL';

create function pg_catalog.mic_to_latin2(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.mic_to_latin2
;

comment on function pg_catalog.mic_to_latin2(integer, integer, cstring, internal, integer)
is 'internal conversion function for MULE_INTERNAL to LATIN2';

create function pg_catalog.win1250_to_mic(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.win1250_to_mic
;

comment on function pg_catalog.win1250_to_mic(integer, integer, cstring, internal, integer)
is 'internal conversion function for WIN1250 to MULE_INTERNAL';

create function pg_catalog.mic_to_win1250(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.mic_to_win1250
;

comment on function pg_catalog.mic_to_win1250(integer, integer, cstring, internal, integer)
is 'internal conversion function for MULE_INTERNAL to WIN1250';

create function pg_catalog.latin2_to_win1250(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.latin2_to_win1250
;

comment on function pg_catalog.latin2_to_win1250(integer, integer, cstring, internal, integer)
is 'internal conversion function for LATIN2 to WIN1250';

create function pg_catalog.win1250_to_latin2(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.win1250_to_latin2
;

comment on function pg_catalog.win1250_to_latin2(integer, integer, cstring, internal, integer)
is 'internal conversion function for WIN1250 to LATIN2';

create function pg_catalog.latin1_to_mic(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.latin1_to_mic
;

comment on function pg_catalog.latin1_to_mic(integer, integer, cstring, internal, integer)
is 'internal conversion function for LATIN1 to MULE_INTERNAL';

create function pg_catalog.mic_to_latin1(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.mic_to_latin1
;

comment on function pg_catalog.mic_to_latin1(integer, integer, cstring, internal, integer)
is 'internal conversion function for MULE_INTERNAL to LATIN1';

create function pg_catalog.latin3_to_mic(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.latin3_to_mic
;

comment on function pg_catalog.latin3_to_mic(integer, integer, cstring, internal, integer)
is 'internal conversion function for LATIN3 to MULE_INTERNAL';

create function pg_catalog.mic_to_latin3(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.mic_to_latin3
;

comment on function pg_catalog.mic_to_latin3(integer, integer, cstring, internal, integer)
is 'internal conversion function for MULE_INTERNAL to LATIN3';

create function pg_catalog.latin4_to_mic(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.latin4_to_mic
;

comment on function pg_catalog.latin4_to_mic(integer, integer, cstring, internal, integer)
is 'internal conversion function for LATIN4 to MULE_INTERNAL';

create function pg_catalog.mic_to_latin4(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.mic_to_latin4
;

comment on function pg_catalog.mic_to_latin4(integer, integer, cstring, internal, integer)
is 'internal conversion function for MULE_INTERNAL to LATIN4';

create function pg_catalog.ascii_to_utf8(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.ascii_to_utf8
;

comment on function pg_catalog.ascii_to_utf8(integer, integer, cstring, internal, integer)
is 'internal conversion function for SQL_ASCII to UTF8';

create function pg_catalog.utf8_to_ascii(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.utf8_to_ascii
;

comment on function pg_catalog.utf8_to_ascii(integer, integer, cstring, internal, integer)
is 'internal conversion function for UTF8 to SQL_ASCII';

create function pg_catalog.big5_to_utf8(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.big5_to_utf8
;

comment on function pg_catalog.big5_to_utf8(integer, integer, cstring, internal, integer)
is 'internal conversion function for BIG5 to UTF8';

create function pg_catalog.utf8_to_big5(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.utf8_to_big5
;

comment on function pg_catalog.utf8_to_big5(integer, integer, cstring, internal, integer)
is 'internal conversion function for UTF8 to BIG5';

create function pg_catalog.utf8_to_koi8r(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.utf8_to_koi8r
;

comment on function pg_catalog.utf8_to_koi8r(integer, integer, cstring, internal, integer)
is 'internal conversion function for UTF8 to KOI8R';

create function pg_catalog.koi8r_to_utf8(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.koi8r_to_utf8
;

comment on function pg_catalog.koi8r_to_utf8(integer, integer, cstring, internal, integer)
is 'internal conversion function for KOI8R to UTF8';

create function pg_catalog.utf8_to_koi8u(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.utf8_to_koi8u
;

comment on function pg_catalog.utf8_to_koi8u(integer, integer, cstring, internal, integer)
is 'internal conversion function for UTF8 to KOI8U';

create function pg_catalog.koi8u_to_utf8(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.koi8u_to_utf8
;

comment on function pg_catalog.koi8u_to_utf8(integer, integer, cstring, internal, integer)
is 'internal conversion function for KOI8U to UTF8';

create function pg_catalog.utf8_to_win(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.utf8_to_win
;

comment on function pg_catalog.utf8_to_win(integer, integer, cstring, internal, integer)
is 'internal conversion function for UTF8 to WIN1258';

create function pg_catalog.win_to_utf8(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.win_to_utf8
;

comment on function pg_catalog.win_to_utf8(integer, integer, cstring, internal, integer)
is 'internal conversion function for WIN1258 to UTF8';

create function pg_catalog.euc_cn_to_utf8(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.euc_cn_to_utf8
;

comment on function pg_catalog.euc_cn_to_utf8(integer, integer, cstring, internal, integer)
is 'internal conversion function for EUC_CN to UTF8';

create function pg_catalog.utf8_to_euc_cn(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.utf8_to_euc_cn
;

comment on function pg_catalog.utf8_to_euc_cn(integer, integer, cstring, internal, integer)
is 'internal conversion function for UTF8 to EUC_CN';

create function pg_catalog.euc_jp_to_utf8(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.euc_jp_to_utf8
;

comment on function pg_catalog.euc_jp_to_utf8(integer, integer, cstring, internal, integer)
is 'internal conversion function for EUC_JP to UTF8';

create function pg_catalog.utf8_to_euc_jp(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.utf8_to_euc_jp
;

comment on function pg_catalog.utf8_to_euc_jp(integer, integer, cstring, internal, integer)
is 'internal conversion function for UTF8 to EUC_JP';

create function pg_catalog.euc_kr_to_utf8(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.euc_kr_to_utf8
;

comment on function pg_catalog.euc_kr_to_utf8(integer, integer, cstring, internal, integer)
is 'internal conversion function for EUC_KR to UTF8';

create function pg_catalog.utf8_to_euc_kr(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.utf8_to_euc_kr
;

comment on function pg_catalog.utf8_to_euc_kr(integer, integer, cstring, internal, integer)
is 'internal conversion function for UTF8 to EUC_KR';

create function pg_catalog.euc_tw_to_utf8(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.euc_tw_to_utf8
;

comment on function pg_catalog.euc_tw_to_utf8(integer, integer, cstring, internal, integer)
is 'internal conversion function for EUC_TW to UTF8';

create function pg_catalog.utf8_to_euc_tw(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.utf8_to_euc_tw
;

comment on function pg_catalog.utf8_to_euc_tw(integer, integer, cstring, internal, integer)
is 'internal conversion function for UTF8 to EUC_TW';

create function pg_catalog.gb18030_to_utf8(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.gb18030_to_utf8
;

comment on function pg_catalog.gb18030_to_utf8(integer, integer, cstring, internal, integer)
is 'internal conversion function for GB18030 to UTF8';

create function pg_catalog.utf8_to_gb18030(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.utf8_to_gb18030
;

comment on function pg_catalog.utf8_to_gb18030(integer, integer, cstring, internal, integer)
is 'internal conversion function for UTF8 to GB18030';

create function pg_catalog.gbk_to_utf8(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.gbk_to_utf8
;

comment on function pg_catalog.gbk_to_utf8(integer, integer, cstring, internal, integer)
is 'internal conversion function for GBK to UTF8';

create function pg_catalog.utf8_to_gbk(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.utf8_to_gbk
;

comment on function pg_catalog.utf8_to_gbk(integer, integer, cstring, internal, integer)
is 'internal conversion function for UTF8 to GBK';

create function pg_catalog.utf8_to_iso8859(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.utf8_to_iso8859
;

comment on function pg_catalog.utf8_to_iso8859(integer, integer, cstring, internal, integer)
is 'internal conversion function for UTF8 to ISO-8859-8';

create function pg_catalog.iso8859_to_utf8(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.iso8859_to_utf8
;

comment on function pg_catalog.iso8859_to_utf8(integer, integer, cstring, internal, integer)
is 'internal conversion function for ISO-8859-8 to UTF8';

create function pg_catalog.iso8859_1_to_utf8(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.iso8859_1_to_utf8
;

comment on function pg_catalog.iso8859_1_to_utf8(integer, integer, cstring, internal, integer)
is 'internal conversion function for LATIN1 to UTF8';

create function pg_catalog.utf8_to_iso8859_1(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.utf8_to_iso8859_1
;

comment on function pg_catalog.utf8_to_iso8859_1(integer, integer, cstring, internal, integer)
is 'internal conversion function for UTF8 to LATIN1';

create function pg_catalog.johab_to_utf8(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.johab_to_utf8
;

comment on function pg_catalog.johab_to_utf8(integer, integer, cstring, internal, integer)
is 'internal conversion function for JOHAB to UTF8';

create function pg_catalog.utf8_to_johab(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.utf8_to_johab
;

comment on function pg_catalog.utf8_to_johab(integer, integer, cstring, internal, integer)
is 'internal conversion function for UTF8 to JOHAB';

create function pg_catalog.sjis_to_utf8(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.sjis_to_utf8
;

comment on function pg_catalog.sjis_to_utf8(integer, integer, cstring, internal, integer)
is 'internal conversion function for SJIS to UTF8';

create function pg_catalog.utf8_to_sjis(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.utf8_to_sjis
;

comment on function pg_catalog.utf8_to_sjis(integer, integer, cstring, internal, integer)
is 'internal conversion function for UTF8 to SJIS';

create function pg_catalog.uhc_to_utf8(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.uhc_to_utf8
;

comment on function pg_catalog.uhc_to_utf8(integer, integer, cstring, internal, integer)
is 'internal conversion function for UHC to UTF8';

create function pg_catalog.utf8_to_uhc(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.utf8_to_uhc
;

comment on function pg_catalog.utf8_to_uhc(integer, integer, cstring, internal, integer)
is 'internal conversion function for UTF8 to UHC';

create function pg_catalog.euc_jis_2004_to_utf8(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.euc_jis_2004_to_utf8
;

comment on function pg_catalog.euc_jis_2004_to_utf8(integer, integer, cstring, internal, integer)
is 'internal conversion function for EUC_JIS_2004 to UTF8';

create function pg_catalog.utf8_to_euc_jis_2004(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.utf8_to_euc_jis_2004
;

comment on function pg_catalog.utf8_to_euc_jis_2004(integer, integer, cstring, internal, integer)
is 'internal conversion function for UTF8 to EUC_JIS_2004';

create function pg_catalog.shift_jis_2004_to_utf8(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.shift_jis_2004_to_utf8
;

comment on function pg_catalog.shift_jis_2004_to_utf8(integer, integer, cstring, internal, integer)
is 'internal conversion function for SHIFT_JIS_2004 to UTF8';

create function pg_catalog.utf8_to_shift_jis_2004(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.utf8_to_shift_jis_2004
;

comment on function pg_catalog.utf8_to_shift_jis_2004(integer, integer, cstring, internal, integer)
is 'internal conversion function for UTF8 to SHIFT_JIS_2004';

create function pg_catalog.euc_jis_2004_to_shift_jis_2004(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.euc_jis_2004_to_shift_jis_2004
;

comment on function pg_catalog.euc_jis_2004_to_shift_jis_2004(integer, integer, cstring, internal, integer)
is 'internal conversion function for EUC_JIS_2004 to SHIFT_JIS_2004';

create function pg_catalog.shift_jis_2004_to_euc_jis_2004(integer, integer, cstring, internal, integer)
strict
language c
as
-- missing source code for pg_catalog.shift_jis_2004_to_euc_jis_2004
;

comment on function pg_catalog.shift_jis_2004_to_euc_jis_2004(integer, integer, cstring, internal, integer)
is 'internal conversion function for SHIFT_JIS_2004 to EUC_JIS_2004';

create function pg_catalog.dsnowball_init(internal)
strict
language c
as
-- missing source code for pg_catalog.dsnowball_init
;

create function pg_catalog.dsnowball_lexize(internal, internal, internal, internal)
strict
language c
as
-- missing source code for pg_catalog.dsnowball_lexize
;

create function information_schema."_pg_expandarray"(anyarray, OUT x anyelement, OUT n integer)
  returns SETOF record
immutable
strict
parallel safe
language sql
as $$
select $1 [ s ], s - pg_catalog.array_lower($1, 1) + 1
from pg_catalog.generate_series(pg_catalog.array_lower($1, 1),
                                pg_catalog.array_upper($1, 1),
                                1) as g (s)
$$;

create function information_schema."_pg_keysequal"(smallint [], smallint [])
  returns boolean
immutable
parallel safe
language sql
as $$
select $1 operator (pg_catalog.<@) $2 and $2 operator (pg_catalog.<@) $1
$$;

create function information_schema."_pg_index_position"(oid, smallint)
  returns integer
stable
strict
language sql
as $$
SELECT (ss.a).n
FROM (SELECT information_schema._pg_expandarray(indkey) AS a FROM pg_catalog.pg_index WHERE indexrelid = $1) ss
WHERE (ss.a).x = $2;
$$;

create function information_schema."_pg_truetypid"(pg_attribute, pg_type)
  returns oid
immutable
strict
parallel safe
language sql
as $$
SELECT CASE WHEN $2.typtype = 'd' THEN $2.typbasetype ELSE $1.atttypid END
$$;

create function information_schema."_pg_truetypmod"(pg_attribute, pg_type)
  returns integer
immutable
strict
parallel safe
language sql
as $$
SELECT CASE WHEN $2.typtype = 'd' THEN $2.typtypmod ELSE $1.atttypmod END
$$;

create function information_schema."_pg_char_max_length"(typid oid, typmod integer)
  returns integer
immutable
strict
parallel safe
language sql
as $$
SELECT CASE
         WHEN $2 = -1 /* default typmod */
                 THEN null
         WHEN $1 IN (1042, 1043) /* char, varchar */
                 THEN $2 - 4
         WHEN $1 IN (1560, 1562) /* bit, varbit */
                 THEN $2
         ELSE null END
$$;

create function information_schema."_pg_char_octet_length"(typid oid, typmod integer)
  returns integer
immutable
strict
parallel safe
language sql
as $$
SELECT CASE
         WHEN $1 IN (25, 1042, 1043) /* text, char, varchar */
                 THEN CASE
                        WHEN $2 = -1 /* default typmod */
                                THEN CAST(2 ^ 30 AS integer)
                        ELSE information_schema._pg_char_max_length($1, $2) *
                             pg_catalog.pg_encoding_max_length((SELECT encoding
                                                                FROM pg_catalog.pg_database
                                                                WHERE datname = pg_catalog.current_database()))
        END
         ELSE null END
$$;

create function information_schema."_pg_numeric_precision"(typid oid, typmod integer)
  returns integer
immutable
strict
parallel safe
language sql
as $$
SELECT CASE $1
         WHEN 21 /*int2*/ THEN 16
         WHEN 23 /*int4*/ THEN 32
         WHEN 20 /*int8*/ THEN 64
         WHEN 1700 /*numeric*/ THEN CASE
                                      WHEN $2 = -1
                                              THEN null
                                      ELSE (($2 - 4) >> 16) & 65535
        END
         WHEN 700 /*float4*/ THEN 24 /*FLT_MANT_DIG*/
         WHEN 701 /*float8*/ THEN 53 /*DBL_MANT_DIG*/
         ELSE null END
$$;

create function information_schema."_pg_numeric_precision_radix"(typid oid, typmod integer)
  returns integer
immutable
strict
parallel safe
language sql
as $$
SELECT CASE
         WHEN $1 IN (21, 23, 20, 700, 701) THEN 2
         WHEN $1 IN (1700) THEN 10
         ELSE null END
$$;

create function information_schema."_pg_numeric_scale"(typid oid, typmod integer)
  returns integer
immutable
strict
parallel safe
language sql
as $$
SELECT CASE
         WHEN $1 IN (21, 23, 20) THEN 0
         WHEN $1 IN (1700) THEN CASE
                                  WHEN $2 = -1
                                          THEN null
                                  ELSE ($2 - 4) & 65535
        END
         ELSE null END
$$;

create function information_schema."_pg_datetime_precision"(typid oid, typmod integer)
  returns integer
immutable
strict
parallel safe
language sql
as $$
SELECT CASE
         WHEN $1 IN (1082) /* date */
                 THEN 0
         WHEN $1 IN (1083, 1114, 1184, 1266) /* time, timestamp, same + tz */
                 THEN CASE WHEN $2 < 0 THEN 6 ELSE $2 END
         WHEN $1 IN (1186) /* interval */
                 THEN CASE WHEN $2 < 0 OR $2 & 65535 = 65535 THEN 6 ELSE $2 & 65535 END
         ELSE null END
$$;

create function information_schema."_pg_interval_type"(typid oid, mod integer)
  returns text
immutable
strict
parallel safe
language sql
as $$
SELECT CASE
         WHEN $1 IN (1186) /* interval */
                 THEN upper(substring(format_type($1, $2) from 'interval[()0-9]* #"%#"' for '#'))
         ELSE null END
$$;

create function pg_catalog.plpgsql_call_handler()
language c
as
-- missing source code for pg_catalog.plpgsql_call_handler
;

create function pg_catalog.plpgsql_inline_handler(internal)
strict
language c
as
-- missing source code for pg_catalog.plpgsql_inline_handler
;

create function pg_catalog.plpgsql_validator(oid)
strict
language c
as
-- missing source code for pg_catalog.plpgsql_validator
;

create operator pg_catalog.= (procedure = int48eq, leftarg = integer, rightarg = bigint);

comment on operator pg_catalog.=(integer, bigint)
is 'equal';

create operator pg_catalog.<> (procedure = int48ne, leftarg = integer, rightarg = bigint);

comment on operator pg_catalog.<>(integer, bigint)
is 'not equal';

create operator pg_catalog.< (procedure = int48lt, leftarg = integer, rightarg = bigint);

comment on operator pg_catalog.<(integer, bigint)
is 'less than';

create operator pg_catalog.< (procedure = boollt, leftarg = boolean, rightarg = boolean);

comment on operator pg_catalog.<(boolean, boolean)
is 'less than';

create operator pg_catalog.> (procedure = boolgt, leftarg = boolean, rightarg = boolean);

comment on operator pg_catalog.>(boolean, boolean)
is 'greater than';

create operator pg_catalog.> (procedure = int48gt, leftarg = integer, rightarg = bigint);

comment on operator pg_catalog.>(integer, bigint)
is 'greater than';

create operator pg_catalog.<= (procedure = int48le, leftarg = integer, rightarg = bigint);

comment on operator pg_catalog.<=(integer, bigint)
is 'less than or equal';

create operator pg_catalog.>= (procedure = int48ge, leftarg = integer, rightarg = bigint);

comment on operator pg_catalog.>=(integer, bigint)
is 'greater than or equal';

create operator pg_catalog.<> (procedure = boolne, leftarg = boolean, rightarg = boolean);

comment on operator pg_catalog.<>(boolean, boolean)
is 'not equal';

create operator pg_catalog.= (procedure = booleq, leftarg = boolean, rightarg = boolean);

comment on operator pg_catalog.=(boolean, boolean)
is 'equal';

create operator pg_catalog.= (procedure = chareq, leftarg = "char", rightarg = "char");

comment on operator pg_catalog.=("char", "char")
is 'equal';

create operator pg_catalog.= (procedure = nameeq, leftarg = name, rightarg = name);

comment on operator pg_catalog.=(name, name)
is 'equal';

create operator pg_catalog.= (procedure = int2eq, leftarg = smallint, rightarg = smallint);

comment on operator pg_catalog.=(smallint, smallint)
is 'equal';

create operator pg_catalog.< (procedure = int2lt, leftarg = smallint, rightarg = smallint);

comment on operator pg_catalog.<(smallint, smallint)
is 'less than';

create operator pg_catalog.= (procedure = int4eq, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.=(integer, integer)
is 'equal';

create operator pg_catalog.< (procedure = int4lt, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.<(integer, integer)
is 'less than';

create operator pg_catalog.= (procedure = texteq, leftarg = text, rightarg = text);

comment on operator pg_catalog.=(text, text)
is 'equal';

create operator pg_catalog.|| (procedure = array_append, leftarg = anyarray, rightarg = anyelement);

comment on operator pg_catalog.||(anyarray, anyelement)
is 'append element onto end of array';

create operator pg_catalog.= (procedure = xideq, leftarg = xid, rightarg = xid);

comment on operator pg_catalog.=(xid, xid)
is 'equal';

create operator pg_catalog.= (procedure = xideqint4, leftarg = xid, rightarg = integer);

comment on operator pg_catalog.=(xid, integer)
is 'equal';

create operator pg_catalog.|| (procedure = array_prepend, leftarg = anyelement, rightarg = anyarray);

comment on operator pg_catalog.||(anyelement, anyarray)
is 'prepend element onto front of array';

create operator pg_catalog.|| (procedure = array_cat, leftarg = anyarray, rightarg = anyarray);

comment on operator pg_catalog.||(anyarray, anyarray)
is 'concatenate';

create operator pg_catalog.= (procedure = cideq, leftarg = cid, rightarg = cid);

comment on operator pg_catalog.=(cid, cid)
is 'equal';

create operator pg_catalog.= (procedure = tideq, leftarg = tid, rightarg = tid);

comment on operator pg_catalog.=(tid, tid)
is 'equal';

create operator pg_catalog.! (procedure = numeric_fac, leftarg = bigint);

comment on operator pg_catalog.!(bigint, none)
is 'factorial';

create operator pg_catalog.!! (procedure = numeric_fac, rightarg = bigint);

comment on operator pg_catalog.!!(none, bigint)
is 'deprecated, use ! instead';

create operator pg_catalog.<> (procedure = tidne, leftarg = tid, rightarg = tid);

comment on operator pg_catalog.<>(tid, tid)
is 'not equal';

create operator pg_catalog.= (procedure = int8eq, leftarg = bigint, rightarg = bigint);

comment on operator pg_catalog.=(bigint, bigint)
is 'equal';

create operator pg_catalog.<> (procedure = int8ne, leftarg = bigint, rightarg = bigint);

comment on operator pg_catalog.<>(bigint, bigint)
is 'not equal';

create operator pg_catalog.< (procedure = int8lt, leftarg = bigint, rightarg = bigint);

comment on operator pg_catalog.<(bigint, bigint)
is 'less than';

create operator pg_catalog.> (procedure = int8gt, leftarg = bigint, rightarg = bigint);

comment on operator pg_catalog.>(bigint, bigint)
is 'greater than';

create operator pg_catalog.<= (procedure = int8le, leftarg = bigint, rightarg = bigint);

comment on operator pg_catalog.<=(bigint, bigint)
is 'less than or equal';

create operator pg_catalog.>= (procedure = int8ge, leftarg = bigint, rightarg = bigint);

comment on operator pg_catalog.>=(bigint, bigint)
is 'greater than or equal';

create operator pg_catalog.= (procedure = int84eq, leftarg = bigint, rightarg = integer);

comment on operator pg_catalog.=(bigint, integer)
is 'equal';

create operator pg_catalog.<> (procedure = int84ne, leftarg = bigint, rightarg = integer);

comment on operator pg_catalog.<>(bigint, integer)
is 'not equal';

create operator pg_catalog.< (procedure = int84lt, leftarg = bigint, rightarg = integer);

comment on operator pg_catalog.<(bigint, integer)
is 'less than';

create operator pg_catalog.> (procedure = int84gt, leftarg = bigint, rightarg = integer);

comment on operator pg_catalog.>(bigint, integer)
is 'greater than';

create operator pg_catalog.<= (procedure = int84le, leftarg = bigint, rightarg = integer);

comment on operator pg_catalog.<=(bigint, integer)
is 'less than or equal';

create operator pg_catalog.>= (procedure = int84ge, leftarg = bigint, rightarg = integer);

comment on operator pg_catalog.>=(bigint, integer)
is 'greater than or equal';

create operator pg_catalog.@> (procedure = box_contain_pt, leftarg = box, rightarg = point);

comment on operator pg_catalog.@>(box, point)
is 'contains';

create operator pg_catalog.% (procedure = int8mod, leftarg = bigint, rightarg = bigint);

comment on operator pg_catalog.%(bigint, bigint)
is 'modulus';

create operator pg_catalog.@ (procedure = int8abs, rightarg = bigint);

comment on operator pg_catalog.@(none, bigint)
is 'absolute value';

create operator pg_catalog.- (procedure = int8um, rightarg = bigint);

comment on operator pg_catalog.-(none, bigint)
is 'negate';

create operator pg_catalog.<< (procedure = poly_left, leftarg = polygon, rightarg = polygon);

comment on operator pg_catalog.<<(polygon, polygon)
is 'is left of';

create operator pg_catalog.&< (procedure = poly_overleft, leftarg = polygon, rightarg = polygon);

comment on operator pg_catalog.&<(polygon, polygon)
is 'overlaps or is left of';

create operator pg_catalog.&> (procedure = poly_overright, leftarg = polygon, rightarg = polygon);

comment on operator pg_catalog.&>(polygon, polygon)
is 'overlaps or is right of';

create operator pg_catalog.>> (procedure = poly_right, leftarg = polygon, rightarg = polygon);

comment on operator pg_catalog.>>(polygon, polygon)
is 'is right of';

create operator pg_catalog.<@ (procedure = poly_contained, leftarg = polygon, rightarg = polygon);

comment on operator pg_catalog.<@(polygon, polygon)
is 'is contained by';

create operator pg_catalog.@> (procedure = poly_contain, leftarg = polygon, rightarg = polygon);

comment on operator pg_catalog.@>(polygon, polygon)
is 'contains';

create operator pg_catalog.~= (procedure = poly_same, leftarg = polygon, rightarg = polygon);

comment on operator pg_catalog.~=(polygon, polygon)
is 'same as';

create operator pg_catalog.&& (procedure = poly_overlap, leftarg = polygon, rightarg = polygon);

comment on operator pg_catalog.&&(polygon, polygon)
is 'overlaps';

create operator pg_catalog.<< (procedure = box_left, leftarg = box, rightarg = box);

comment on operator pg_catalog.<<(box, box)
is 'is left of';

create operator pg_catalog.&< (procedure = box_overleft, leftarg = box, rightarg = box);

comment on operator pg_catalog.&<(box, box)
is 'overlaps or is left of';

create operator pg_catalog.&> (procedure = box_overright, leftarg = box, rightarg = box);

comment on operator pg_catalog.&>(box, box)
is 'overlaps or is right of';

create operator pg_catalog.>> (procedure = box_right, leftarg = box, rightarg = box);

comment on operator pg_catalog.>>(box, box)
is 'is right of';

create operator pg_catalog.<@ (procedure = box_contained, leftarg = box, rightarg = box);

comment on operator pg_catalog.<@(box, box)
is 'is contained by';

create operator pg_catalog.@> (procedure = box_contain, leftarg = box, rightarg = box);

comment on operator pg_catalog.@>(box, box)
is 'contains';

create operator pg_catalog.~= (procedure = box_same, leftarg = box, rightarg = box);

comment on operator pg_catalog.~=(box, box)
is 'same as';

create operator pg_catalog.&& (procedure = box_overlap, leftarg = box, rightarg = box);

comment on operator pg_catalog.&&(box, box)
is 'overlaps';

create operator pg_catalog.>= (procedure = box_ge, leftarg = box, rightarg = box);

comment on operator pg_catalog.>=(box, box)
is 'greater than or equal by area';

create operator pg_catalog.> (procedure = box_gt, leftarg = box, rightarg = box);

comment on operator pg_catalog.>(box, box)
is 'greater than by area';

create operator pg_catalog.= (procedure = box_eq, leftarg = box, rightarg = box);

comment on operator pg_catalog.=(box, box)
is 'equal by area';

create operator pg_catalog.< (procedure = box_lt, leftarg = box, rightarg = box);

comment on operator pg_catalog.<(box, box)
is 'less than by area';

create operator pg_catalog.<= (procedure = box_le, leftarg = box, rightarg = box);

comment on operator pg_catalog.<=(box, box)
is 'less than or equal by area';

create operator pg_catalog.>^ (procedure = point_above, leftarg = point, rightarg = point);

comment on operator pg_catalog.>^(point, point)
is 'is above';

create operator pg_catalog.<< (procedure = point_left, leftarg = point, rightarg = point);

comment on operator pg_catalog.<<(point, point)
is 'is left of';

create operator pg_catalog.>> (procedure = point_right, leftarg = point, rightarg = point);

comment on operator pg_catalog.>>(point, point)
is 'is right of';

create operator pg_catalog.<^ (procedure = point_below, leftarg = point, rightarg = point);

comment on operator pg_catalog.<^(point, point)
is 'is below';

create operator pg_catalog.~= (procedure = point_eq, leftarg = point, rightarg = point);

comment on operator pg_catalog.~=(point, point)
is 'same as';

create operator pg_catalog.<@ (procedure = on_pb, leftarg = point, rightarg = box);

comment on operator pg_catalog.<@(point, box)
is 'point inside box';

create operator pg_catalog.<@ (procedure = on_ppath, leftarg = point, rightarg = path);

comment on operator pg_catalog.<@(point, path)
is 'point within closed path, or point on open path';

create operator pg_catalog.@@ (procedure = box_center, rightarg = box);

comment on operator pg_catalog.@@(none, box)
is 'center of';

create operator pg_catalog.* (procedure = int4mul, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.*(integer, integer)
is 'multiply';

create operator pg_catalog.<-> (procedure = point_distance, leftarg = point, rightarg = point);

comment on operator pg_catalog.<->(point, point)
is 'distance between';

create operator pg_catalog.<> (procedure = int4ne, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.<>(integer, integer)
is 'not equal';

create operator pg_catalog.<> (procedure = int2ne, leftarg = smallint, rightarg = smallint);

comment on operator pg_catalog.<>(smallint, smallint)
is 'not equal';

create operator pg_catalog.> (procedure = int2gt, leftarg = smallint, rightarg = smallint);

comment on operator pg_catalog.>(smallint, smallint)
is 'greater than';

create operator pg_catalog.> (procedure = int4gt, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.>(integer, integer)
is 'greater than';

create operator pg_catalog.<= (procedure = int2le, leftarg = smallint, rightarg = smallint);

comment on operator pg_catalog.<=(smallint, smallint)
is 'less than or equal';

create operator pg_catalog.<= (procedure = int4le, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.<=(integer, integer)
is 'less than or equal';

create operator pg_catalog.>= (procedure = int2ge, leftarg = smallint, rightarg = smallint);

comment on operator pg_catalog.>=(smallint, smallint)
is 'greater than or equal';

create operator pg_catalog.>= (procedure = int4ge, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.>=(integer, integer)
is 'greater than or equal';

create operator pg_catalog.* (procedure = int2mul, leftarg = smallint, rightarg = smallint);

comment on operator pg_catalog.*(smallint, smallint)
is 'multiply';

create operator pg_catalog./ (procedure = int2div, leftarg = smallint, rightarg = smallint);

comment on operator pg_catalog./(smallint, smallint)
is 'divide';

create operator pg_catalog./ (procedure = int4div, leftarg = integer, rightarg = integer);

comment on operator pg_catalog./(integer, integer)
is 'divide';

create operator pg_catalog.% (procedure = int2mod, leftarg = smallint, rightarg = smallint);

comment on operator pg_catalog.%(smallint, smallint)
is 'modulus';

create operator pg_catalog.% (procedure = int4mod, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.%(integer, integer)
is 'modulus';

create operator pg_catalog.<> (procedure = textne, leftarg = text, rightarg = text);

comment on operator pg_catalog.<>(text, text)
is 'not equal';

create operator pg_catalog.= (procedure = int24eq, leftarg = smallint, rightarg = integer);

comment on operator pg_catalog.=(smallint, integer)
is 'equal';

create operator pg_catalog.= (procedure = int42eq, leftarg = integer, rightarg = smallint);

comment on operator pg_catalog.=(integer, smallint)
is 'equal';

create operator pg_catalog.< (procedure = int24lt, leftarg = smallint, rightarg = integer);

comment on operator pg_catalog.<(smallint, integer)
is 'less than';

create operator pg_catalog.< (procedure = int42lt, leftarg = integer, rightarg = smallint);

comment on operator pg_catalog.<(integer, smallint)
is 'less than';

create operator pg_catalog.> (procedure = int24gt, leftarg = smallint, rightarg = integer);

comment on operator pg_catalog.>(smallint, integer)
is 'greater than';

create operator pg_catalog.> (procedure = int42gt, leftarg = integer, rightarg = smallint);

comment on operator pg_catalog.>(integer, smallint)
is 'greater than';

create operator pg_catalog.<> (procedure = int24ne, leftarg = smallint, rightarg = integer);

comment on operator pg_catalog.<>(smallint, integer)
is 'not equal';

create operator pg_catalog.<> (procedure = int42ne, leftarg = integer, rightarg = smallint);

comment on operator pg_catalog.<>(integer, smallint)
is 'not equal';

create operator pg_catalog.<= (procedure = int24le, leftarg = smallint, rightarg = integer);

comment on operator pg_catalog.<=(smallint, integer)
is 'less than or equal';

create operator pg_catalog.<= (procedure = int42le, leftarg = integer, rightarg = smallint);

comment on operator pg_catalog.<=(integer, smallint)
is 'less than or equal';

create operator pg_catalog.>= (procedure = int24ge, leftarg = smallint, rightarg = integer);

comment on operator pg_catalog.>=(smallint, integer)
is 'greater than or equal';

create operator pg_catalog.>= (procedure = int42ge, leftarg = integer, rightarg = smallint);

comment on operator pg_catalog.>=(integer, smallint)
is 'greater than or equal';

create operator pg_catalog.* (procedure = int24mul, leftarg = smallint, rightarg = integer);

comment on operator pg_catalog.*(smallint, integer)
is 'multiply';

create operator pg_catalog.* (procedure = int42mul, leftarg = integer, rightarg = smallint);

comment on operator pg_catalog.*(integer, smallint)
is 'multiply';

create operator pg_catalog./ (procedure = int24div, leftarg = smallint, rightarg = integer);

comment on operator pg_catalog./(smallint, integer)
is 'divide';

create operator pg_catalog./ (procedure = int42div, leftarg = integer, rightarg = smallint);

comment on operator pg_catalog./(integer, smallint)
is 'divide';

create operator pg_catalog.+ (procedure = int2pl, leftarg = smallint, rightarg = smallint);

comment on operator pg_catalog.+(smallint, smallint)
is 'add';

create operator pg_catalog.+ (procedure = int4pl, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.+(integer, integer)
is 'add';

create operator pg_catalog.+ (procedure = int24pl, leftarg = smallint, rightarg = integer);

comment on operator pg_catalog.+(smallint, integer)
is 'add';

create operator pg_catalog.+ (procedure = int42pl, leftarg = integer, rightarg = smallint);

comment on operator pg_catalog.+(integer, smallint)
is 'add';

create operator pg_catalog.- (procedure = int2mi, leftarg = smallint, rightarg = smallint);

comment on operator pg_catalog.-(smallint, smallint)
is 'subtract';

create operator pg_catalog.- (procedure = int4mi, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.-(integer, integer)
is 'subtract';

create operator pg_catalog.- (procedure = int24mi, leftarg = smallint, rightarg = integer);

comment on operator pg_catalog.-(smallint, integer)
is 'subtract';

create operator pg_catalog.- (procedure = int42mi, leftarg = integer, rightarg = smallint);

comment on operator pg_catalog.-(integer, smallint)
is 'subtract';

create operator pg_catalog.- (procedure = int4um, rightarg = integer);

comment on operator pg_catalog.-(none, integer)
is 'negate';

create operator pg_catalog.- (procedure = int2um, rightarg = smallint);

comment on operator pg_catalog.-(none, smallint)
is 'negate';

create operator pg_catalog.= (procedure = abstimeeq, leftarg = abstime, rightarg = abstime);

comment on operator pg_catalog.=(abstime, abstime)
is 'equal';

create operator pg_catalog.<> (procedure = abstimene, leftarg = abstime, rightarg = abstime);

comment on operator pg_catalog.<>(abstime, abstime)
is 'not equal';

create operator pg_catalog.< (procedure = abstimelt, leftarg = abstime, rightarg = abstime);

comment on operator pg_catalog.<(abstime, abstime)
is 'less than';

create operator pg_catalog.> (procedure = abstimegt, leftarg = abstime, rightarg = abstime);

comment on operator pg_catalog.>(abstime, abstime)
is 'greater than';

create operator pg_catalog.<= (procedure = abstimele, leftarg = abstime, rightarg = abstime);

comment on operator pg_catalog.<=(abstime, abstime)
is 'less than or equal';

create operator pg_catalog.>= (procedure = abstimege, leftarg = abstime, rightarg = abstime);

comment on operator pg_catalog.>=(abstime, abstime)
is 'greater than or equal';

create operator pg_catalog.= (procedure = reltimeeq, leftarg = reltime, rightarg = reltime);

comment on operator pg_catalog.=(reltime, reltime)
is 'equal';

create operator pg_catalog.<> (procedure = reltimene, leftarg = reltime, rightarg = reltime);

comment on operator pg_catalog.<>(reltime, reltime)
is 'not equal';

create operator pg_catalog.< (procedure = reltimelt, leftarg = reltime, rightarg = reltime);

comment on operator pg_catalog.<(reltime, reltime)
is 'less than';

create operator pg_catalog.> (procedure = reltimegt, leftarg = reltime, rightarg = reltime);

comment on operator pg_catalog.>(reltime, reltime)
is 'greater than';

create operator pg_catalog.<= (procedure = reltimele, leftarg = reltime, rightarg = reltime);

comment on operator pg_catalog.<=(reltime, reltime)
is 'less than or equal';

create operator pg_catalog.>= (procedure = reltimege, leftarg = reltime, rightarg = reltime);

comment on operator pg_catalog.>=(reltime, reltime)
is 'greater than or equal';

create operator pg_catalog.~= (procedure = tintervalsame, leftarg = tinterval, rightarg = tinterval);

comment on operator pg_catalog.~=(tinterval, tinterval)
is 'same as';

create operator pg_catalog.<< (procedure = tintervalct, leftarg = tinterval, rightarg = tinterval);

comment on operator pg_catalog.<<(tinterval, tinterval)
is 'contains';

create operator pg_catalog.&& (procedure = tintervalov, leftarg = tinterval, rightarg = tinterval);

comment on operator pg_catalog.&&(tinterval, tinterval)
is 'overlaps';

create operator pg_catalog.#= (procedure = tintervalleneq, leftarg = tinterval, rightarg = reltime);

comment on operator pg_catalog.#=(tinterval, reltime)
is 'equal by length';

create operator pg_catalog.#<> (procedure = tintervallenne, leftarg = tinterval, rightarg = reltime);

comment on operator pg_catalog.#<>(tinterval, reltime)
is 'not equal by length';

create operator pg_catalog.#< (procedure = tintervallenlt, leftarg = tinterval, rightarg = reltime);

comment on operator pg_catalog.#<(tinterval, reltime)
is 'less than by length';

create operator pg_catalog.#> (procedure = tintervallengt, leftarg = tinterval, rightarg = reltime);

comment on operator pg_catalog.#>(tinterval, reltime)
is 'greater than by length';

create operator pg_catalog.#<= (procedure = tintervallenle, leftarg = tinterval, rightarg = reltime);

comment on operator pg_catalog.#<=(tinterval, reltime)
is 'less than or equal by length';

create operator pg_catalog.#>= (procedure = tintervallenge, leftarg = tinterval, rightarg = reltime);

comment on operator pg_catalog.#>=(tinterval, reltime)
is 'greater than or equal by length';

create operator pg_catalog.+ (procedure = timepl, leftarg = abstime, rightarg = reltime);

comment on operator pg_catalog.+(abstime, reltime)
is 'add';

create operator pg_catalog.- (procedure = timemi, leftarg = abstime, rightarg = reltime);

comment on operator pg_catalog.-(abstime, reltime)
is 'subtract';

create operator pg_catalog.<?> (procedure = intinterval, leftarg = abstime, rightarg = tinterval);

comment on operator pg_catalog.<?>(abstime, tinterval)
is 'is contained by';

create operator pg_catalog.- (procedure = float4um, rightarg = real);

comment on operator pg_catalog.-(none, real)
is 'negate';

create operator pg_catalog.- (procedure = float8um, rightarg = double precision);

comment on operator pg_catalog.-(none, double precision)
is 'negate';

create operator pg_catalog.+ (procedure = float4pl, leftarg = real, rightarg = real);

comment on operator pg_catalog.+(real, real)
is 'add';

create operator pg_catalog.- (procedure = float4mi, leftarg = real, rightarg = real);

comment on operator pg_catalog.-(real, real)
is 'subtract';

create operator pg_catalog./ (procedure = float4div, leftarg = real, rightarg = real);

comment on operator pg_catalog./(real, real)
is 'divide';

create operator pg_catalog.* (procedure = float4mul, leftarg = real, rightarg = real);

comment on operator pg_catalog.*(real, real)
is 'multiply';

create operator pg_catalog.@ (procedure = float4abs, rightarg = real);

comment on operator pg_catalog.@(none, real)
is 'absolute value';

create operator pg_catalog.+ (procedure = float8pl, leftarg = double precision, rightarg = double precision);

comment on operator pg_catalog.+(double precision, double precision)
is 'add';

create operator pg_catalog.- (procedure = float8mi, leftarg = double precision, rightarg = double precision);

comment on operator pg_catalog.-(double precision, double precision)
is 'subtract';

create operator pg_catalog./ (procedure = float8div, leftarg = double precision, rightarg = double precision);

comment on operator pg_catalog./(double precision, double precision)
is 'divide';

create operator pg_catalog.* (procedure = float8mul, leftarg = double precision, rightarg = double precision);

comment on operator pg_catalog.*(double precision, double precision)
is 'multiply';

create operator pg_catalog.@ (procedure = float8abs, rightarg = double precision);

comment on operator pg_catalog.@(none, double precision)
is 'absolute value';

create operator pg_catalog.|/ (procedure = dsqrt, rightarg = double precision);

comment on operator pg_catalog.|/(none, double precision)
is 'square root';

create operator pg_catalog.||/ (procedure = dcbrt, rightarg = double precision);

comment on operator pg_catalog.||/(none, double precision)
is 'cube root';

create operator pg_catalog.<#> (procedure = mktinterval, leftarg = abstime, rightarg = abstime);

comment on operator pg_catalog.<#>(abstime, abstime)
is 'convert to tinterval';

create operator pg_catalog.= (procedure = oideq, leftarg = oid, rightarg = oid);

comment on operator pg_catalog.=(oid, oid)
is 'equal';

create operator pg_catalog.<> (procedure = oidne, leftarg = oid, rightarg = oid);

comment on operator pg_catalog.<>(oid, oid)
is 'not equal';

create operator pg_catalog.< (procedure = oidlt, leftarg = oid, rightarg = oid);

comment on operator pg_catalog.<(oid, oid)
is 'less than';

create operator pg_catalog.> (procedure = oidgt, leftarg = oid, rightarg = oid);

comment on operator pg_catalog.>(oid, oid)
is 'greater than';

create operator pg_catalog.<= (procedure = oidle, leftarg = oid, rightarg = oid);

comment on operator pg_catalog.<=(oid, oid)
is 'less than or equal';

create operator pg_catalog.>= (procedure = oidge, leftarg = oid, rightarg = oid);

comment on operator pg_catalog.>=(oid, oid)
is 'greater than or equal';

create operator pg_catalog.<-> (procedure = dist_pl, leftarg = point, rightarg = line);

comment on operator pg_catalog.<->(point, line)
is 'distance between';

create operator pg_catalog.<-> (procedure = dist_ps, leftarg = point, rightarg = lseg);

comment on operator pg_catalog.<->(point, lseg)
is 'distance between';

create operator pg_catalog.<-> (procedure = dist_pb, leftarg = point, rightarg = box);

comment on operator pg_catalog.<->(point, box)
is 'distance between';

create operator pg_catalog.<-> (procedure = dist_sl, leftarg = lseg, rightarg = line);

comment on operator pg_catalog.<->(lseg, line)
is 'distance between';

create operator pg_catalog.<-> (procedure = dist_sb, leftarg = lseg, rightarg = box);

comment on operator pg_catalog.<->(lseg, box)
is 'distance between';

create operator pg_catalog.<-> (procedure = dist_ppath, leftarg = point, rightarg = path);

comment on operator pg_catalog.<->(point, path)
is 'distance between';

create operator pg_catalog.= (procedure = float4eq, leftarg = real, rightarg = real);

comment on operator pg_catalog.=(real, real)
is 'equal';

create operator pg_catalog.<> (procedure = float4ne, leftarg = real, rightarg = real);

comment on operator pg_catalog.<>(real, real)
is 'not equal';

create operator pg_catalog.< (procedure = float4lt, leftarg = real, rightarg = real);

comment on operator pg_catalog.<(real, real)
is 'less than';

create operator pg_catalog.> (procedure = float4gt, leftarg = real, rightarg = real);

comment on operator pg_catalog.>(real, real)
is 'greater than';

create operator pg_catalog.<= (procedure = float4le, leftarg = real, rightarg = real);

comment on operator pg_catalog.<=(real, real)
is 'less than or equal';

create operator pg_catalog.>= (procedure = float4ge, leftarg = real, rightarg = real);

comment on operator pg_catalog.>=(real, real)
is 'greater than or equal';

create operator pg_catalog.<> (procedure = charne, leftarg = "char", rightarg = "char");

comment on operator pg_catalog.<>("char", "char")
is 'not equal';

create operator pg_catalog.< (procedure = charlt, leftarg = "char", rightarg = "char");

comment on operator pg_catalog.<("char", "char")
is 'less than';

create operator pg_catalog.<= (procedure = charle, leftarg = "char", rightarg = "char");

comment on operator pg_catalog.<=("char", "char")
is 'less than or equal';

create operator pg_catalog.> (procedure = chargt, leftarg = "char", rightarg = "char");

comment on operator pg_catalog.>("char", "char")
is 'greater than';

create operator pg_catalog.>= (procedure = charge, leftarg = "char", rightarg = "char");

comment on operator pg_catalog.>=("char", "char")
is 'greater than or equal';

create operator pg_catalog.~ (procedure = nameregexeq, leftarg = name, rightarg = text);

comment on operator pg_catalog.~(name, text)
is 'matches regular expression, case-sensitive';

create operator pg_catalog.!~ (procedure = nameregexne, leftarg = name, rightarg = text);

comment on operator pg_catalog.!~(name, text)
is 'does not match regular expression, case-sensitive';

create operator pg_catalog.~ (procedure = textregexeq, leftarg = text, rightarg = text);

comment on operator pg_catalog.~(text, text)
is 'matches regular expression, case-sensitive';

create operator pg_catalog.!~ (procedure = textregexne, leftarg = text, rightarg = text);

comment on operator pg_catalog.!~(text, text)
is 'does not match regular expression, case-sensitive';

create operator pg_catalog.<> (procedure = namene, leftarg = name, rightarg = name);

comment on operator pg_catalog.<>(name, name)
is 'not equal';

create operator pg_catalog.<> (procedure = oidvectorne, leftarg = oidvector, rightarg = oidvector);

comment on operator pg_catalog.<>(oidvector, oidvector)
is 'not equal';

create operator pg_catalog.< (procedure = oidvectorlt, leftarg = oidvector, rightarg = oidvector);

comment on operator pg_catalog.<(oidvector, oidvector)
is 'less than';

create operator pg_catalog.> (procedure = oidvectorgt, leftarg = oidvector, rightarg = oidvector);

comment on operator pg_catalog.>(oidvector, oidvector)
is 'greater than';

create operator pg_catalog.<= (procedure = oidvectorle, leftarg = oidvector, rightarg = oidvector);

comment on operator pg_catalog.<=(oidvector, oidvector)
is 'less than or equal';

create operator pg_catalog.>= (procedure = oidvectorge, leftarg = oidvector, rightarg = oidvector);

comment on operator pg_catalog.>=(oidvector, oidvector)
is 'greater than or equal';

create operator pg_catalog.= (procedure = oidvectoreq, leftarg = oidvector, rightarg = oidvector);

comment on operator pg_catalog.=(oidvector, oidvector)
is 'equal';

create operator pg_catalog.|| (procedure = textcat, leftarg = text, rightarg = text);

comment on operator pg_catalog.||(text, text)
is 'concatenate';

create operator pg_catalog.< (procedure = namelt, leftarg = name, rightarg = name);

comment on operator pg_catalog.<(name, name)
is 'less than';

create operator pg_catalog.<= (procedure = namele, leftarg = name, rightarg = name);

comment on operator pg_catalog.<=(name, name)
is 'less than or equal';

create operator pg_catalog.> (procedure = namegt, leftarg = name, rightarg = name);

comment on operator pg_catalog.>(name, name)
is 'greater than';

create operator pg_catalog.>= (procedure = namege, leftarg = name, rightarg = name);

comment on operator pg_catalog.>=(name, name)
is 'greater than or equal';

create operator pg_catalog.< (procedure = text_lt, leftarg = text, rightarg = text);

comment on operator pg_catalog.<(text, text)
is 'less than';

create operator pg_catalog.<= (procedure = text_le, leftarg = text, rightarg = text);

comment on operator pg_catalog.<=(text, text)
is 'less than or equal';

create operator pg_catalog.> (procedure = text_gt, leftarg = text, rightarg = text);

comment on operator pg_catalog.>(text, text)
is 'greater than';

create operator pg_catalog.>= (procedure = text_ge, leftarg = text, rightarg = text);

comment on operator pg_catalog.>=(text, text)
is 'greater than or equal';

create operator pg_catalog.= (procedure = float8eq, leftarg = double precision, rightarg = double precision);

comment on operator pg_catalog.=(double precision, double precision)
is 'equal';

create operator pg_catalog.<> (procedure = float8ne, leftarg = double precision, rightarg = double precision);

comment on operator pg_catalog.<>(double precision, double precision)
is 'not equal';

create operator pg_catalog.< (procedure = float8lt, leftarg = double precision, rightarg = double precision);

comment on operator pg_catalog.<(double precision, double precision)
is 'less than';

create operator pg_catalog.<= (procedure = float8le, leftarg = double precision, rightarg = double precision);

comment on operator pg_catalog.<=(double precision, double precision)
is 'less than or equal';

create operator pg_catalog.> (procedure = float8gt, leftarg = double precision, rightarg = double precision);

comment on operator pg_catalog.>(double precision, double precision)
is 'greater than';

create operator pg_catalog.>= (procedure = float8ge, leftarg = double precision, rightarg = double precision);

comment on operator pg_catalog.>=(double precision, double precision)
is 'greater than or equal';

create operator pg_catalog.@ (procedure = int2abs, rightarg = smallint);

comment on operator pg_catalog.@(none, smallint)
is 'absolute value';

create operator pg_catalog.+ (procedure = int8pl, leftarg = bigint, rightarg = bigint);

comment on operator pg_catalog.+(bigint, bigint)
is 'add';

create operator pg_catalog.- (procedure = int8mi, leftarg = bigint, rightarg = bigint);

comment on operator pg_catalog.-(bigint, bigint)
is 'subtract';

create operator pg_catalog.* (procedure = int8mul, leftarg = bigint, rightarg = bigint);

comment on operator pg_catalog.*(bigint, bigint)
is 'multiply';

create operator pg_catalog./ (procedure = int8div, leftarg = bigint, rightarg = bigint);

comment on operator pg_catalog./(bigint, bigint)
is 'divide';

create operator pg_catalog.+ (procedure = int84pl, leftarg = bigint, rightarg = integer);

comment on operator pg_catalog.+(bigint, integer)
is 'add';

create operator pg_catalog.- (procedure = int84mi, leftarg = bigint, rightarg = integer);

comment on operator pg_catalog.-(bigint, integer)
is 'subtract';

create operator pg_catalog.* (procedure = int84mul, leftarg = bigint, rightarg = integer);

comment on operator pg_catalog.*(bigint, integer)
is 'multiply';

create operator pg_catalog./ (procedure = int84div, leftarg = bigint, rightarg = integer);

comment on operator pg_catalog./(bigint, integer)
is 'divide';

create operator pg_catalog.+ (procedure = int48pl, leftarg = integer, rightarg = bigint);

comment on operator pg_catalog.+(integer, bigint)
is 'add';

create operator pg_catalog.- (procedure = int48mi, leftarg = integer, rightarg = bigint);

comment on operator pg_catalog.-(integer, bigint)
is 'subtract';

create operator pg_catalog.* (procedure = int48mul, leftarg = integer, rightarg = bigint);

comment on operator pg_catalog.*(integer, bigint)
is 'multiply';

create operator pg_catalog./ (procedure = int48div, leftarg = integer, rightarg = bigint);

comment on operator pg_catalog./(integer, bigint)
is 'divide';

create operator pg_catalog.<-> (procedure = box_distance, leftarg = box, rightarg = box);

comment on operator pg_catalog.<->(box, box)
is 'distance between';

create operator pg_catalog.<-> (procedure = path_distance, leftarg = path, rightarg = path);

comment on operator pg_catalog.<->(path, path)
is 'distance between';

create operator pg_catalog.<-> (procedure = line_distance, leftarg = line, rightarg = line);

comment on operator pg_catalog.<->(line, line)
is 'distance between';

create operator pg_catalog.<-> (procedure = lseg_distance, leftarg = lseg, rightarg = lseg);

comment on operator pg_catalog.<->(lseg, lseg)
is 'distance between';

create operator pg_catalog.<-> (procedure = poly_distance, leftarg = polygon, rightarg = polygon);

comment on operator pg_catalog.<->(polygon, polygon)
is 'distance between';

create operator pg_catalog.<> (procedure = point_ne, leftarg = point, rightarg = point);

comment on operator pg_catalog.<>(point, point)
is 'not equal';

create operator pg_catalog.+ (procedure = point_add, leftarg = point, rightarg = point);

comment on operator pg_catalog.+(point, point)
is 'add points (translate)';

create operator pg_catalog.- (procedure = point_sub, leftarg = point, rightarg = point);

comment on operator pg_catalog.-(point, point)
is 'subtract points (translate)';

create operator pg_catalog.* (procedure = point_mul, leftarg = point, rightarg = point);

comment on operator pg_catalog.*(point, point)
is 'multiply points (scale/rotate)';

create operator pg_catalog./ (procedure = point_div, leftarg = point, rightarg = point);

comment on operator pg_catalog./(point, point)
is 'divide points (scale/rotate)';

create operator pg_catalog.+ (procedure = path_add, leftarg = path, rightarg = path);

comment on operator pg_catalog.+(path, path)
is 'concatenate';

create operator pg_catalog.+ (procedure = path_add_pt, leftarg = path, rightarg = point);

comment on operator pg_catalog.+(path, point)
is 'add (translate path)';

create operator pg_catalog.- (procedure = path_sub_pt, leftarg = path, rightarg = point);

comment on operator pg_catalog.-(path, point)
is 'subtract (translate path)';

create operator pg_catalog.* (procedure = path_mul_pt, leftarg = path, rightarg = point);

comment on operator pg_catalog.*(path, point)
is 'multiply (rotate/scale path)';

create operator pg_catalog./ (procedure = path_div_pt, leftarg = path, rightarg = point);

comment on operator pg_catalog./(path, point)
is 'divide (rotate/scale path)';

create operator pg_catalog.@> (procedure = path_contain_pt, leftarg = path, rightarg = point);

comment on operator pg_catalog.@>(path, point)
is 'contains';

create operator pg_catalog.<@ (procedure = pt_contained_poly, leftarg = point, rightarg = polygon);

comment on operator pg_catalog.<@(point, polygon)
is 'is contained by';

create operator pg_catalog.@> (procedure = poly_contain_pt, leftarg = polygon, rightarg = point);

comment on operator pg_catalog.@>(polygon, point)
is 'contains';

create operator pg_catalog.<@ (procedure = pt_contained_circle, leftarg = point, rightarg = circle);

comment on operator pg_catalog.<@(point, circle)
is 'is contained by';

create operator pg_catalog.@> (procedure = circle_contain_pt, leftarg = circle, rightarg = point);

comment on operator pg_catalog.@>(circle, point)
is 'contains';

create operator pg_catalog.@ (procedure = int4abs, rightarg = integer);

comment on operator pg_catalog.@(none, integer)
is 'absolute value';

create operator pg_catalog.= (procedure = path_n_eq, leftarg = path, rightarg = path);

comment on operator pg_catalog.=(path, path)
is 'equal';

create operator pg_catalog.< (procedure = path_n_lt, leftarg = path, rightarg = path);

comment on operator pg_catalog.<(path, path)
is 'less than';

create operator pg_catalog.> (procedure = path_n_gt, leftarg = path, rightarg = path);

comment on operator pg_catalog.>(path, path)
is 'greater than';

create operator pg_catalog.<= (procedure = path_n_le, leftarg = path, rightarg = path);

comment on operator pg_catalog.<=(path, path)
is 'less than or equal';

create operator pg_catalog.>= (procedure = path_n_ge, leftarg = path, rightarg = path);

comment on operator pg_catalog.>=(path, path)
is 'greater than or equal';

create operator pg_catalog.# (procedure = path_npoints, rightarg = path);

comment on operator pg_catalog.#(none, path)
is 'number of points';

create operator pg_catalog.?# (procedure = path_inter, leftarg = path, rightarg = path);

comment on operator pg_catalog.?#(path, path)
is 'intersect';

create operator pg_catalog.@-@ (procedure = path_length, rightarg = path);

comment on operator pg_catalog.@-@(none, path)
is 'sum of path segment lengths';

create operator pg_catalog.>^ (procedure = box_above_eq, leftarg = box, rightarg = box);

comment on operator pg_catalog.>^(box, box)
is 'is above (allows touching)';

create operator pg_catalog.<^ (procedure = box_below_eq, leftarg = box, rightarg = box);

comment on operator pg_catalog.<^(box, box)
is 'is below (allows touching)';

create operator pg_catalog.?# (procedure = box_overlap, leftarg = box, rightarg = box);

comment on operator pg_catalog.?#(box, box)
is 'deprecated, use && instead';

create operator pg_catalog.# (procedure = box_intersect, leftarg = box, rightarg = box);

comment on operator pg_catalog.#(box, box)
is 'box intersection';

create operator pg_catalog.+ (procedure = box_add, leftarg = box, rightarg = point);

comment on operator pg_catalog.+(box, point)
is 'add point to box (translate)';

create operator pg_catalog.- (procedure = box_sub, leftarg = box, rightarg = point);

comment on operator pg_catalog.-(box, point)
is 'subtract point from box (translate)';

create operator pg_catalog.* (procedure = box_mul, leftarg = box, rightarg = point);

comment on operator pg_catalog.*(box, point)
is 'multiply box by point (scale)';

create operator pg_catalog./ (procedure = box_div, leftarg = box, rightarg = point);

comment on operator pg_catalog./(box, point)
is 'divide box by point (scale)';

create operator pg_catalog.?- (procedure = point_horiz, leftarg = point, rightarg = point);

comment on operator pg_catalog.?-(point, point)
is 'horizontally aligned';

create operator pg_catalog.?| (procedure = point_vert, leftarg = point, rightarg = point);

comment on operator pg_catalog.?|(point, point)
is 'vertically aligned';

create operator pg_catalog.= (procedure = tintervaleq, leftarg = tinterval, rightarg = tinterval);

comment on operator pg_catalog.=(tinterval, tinterval)
is 'equal';

create operator pg_catalog.<> (procedure = tintervalne, leftarg = tinterval, rightarg = tinterval);

comment on operator pg_catalog.<>(tinterval, tinterval)
is 'not equal';

create operator pg_catalog.< (procedure = tintervallt, leftarg = tinterval, rightarg = tinterval);

comment on operator pg_catalog.<(tinterval, tinterval)
is 'less than';

create operator pg_catalog.> (procedure = tintervalgt, leftarg = tinterval, rightarg = tinterval);

comment on operator pg_catalog.>(tinterval, tinterval)
is 'greater than';

create operator pg_catalog.<= (procedure = tintervalle, leftarg = tinterval, rightarg = tinterval);

comment on operator pg_catalog.<=(tinterval, tinterval)
is 'less than or equal';

create operator pg_catalog.>= (procedure = tintervalge, leftarg = tinterval, rightarg = tinterval);

comment on operator pg_catalog.>=(tinterval, tinterval)
is 'greater than or equal';

create operator pg_catalog.+ (procedure = int82pl, leftarg = bigint, rightarg = smallint);

comment on operator pg_catalog.+(bigint, smallint)
is 'add';

create operator pg_catalog.- (procedure = int82mi, leftarg = bigint, rightarg = smallint);

comment on operator pg_catalog.-(bigint, smallint)
is 'subtract';

create operator pg_catalog.* (procedure = int82mul, leftarg = bigint, rightarg = smallint);

comment on operator pg_catalog.*(bigint, smallint)
is 'multiply';

create operator pg_catalog./ (procedure = int82div, leftarg = bigint, rightarg = smallint);

comment on operator pg_catalog./(bigint, smallint)
is 'divide';

create operator pg_catalog.+ (procedure = int28pl, leftarg = smallint, rightarg = bigint);

comment on operator pg_catalog.+(smallint, bigint)
is 'add';

create operator pg_catalog.- (procedure = int28mi, leftarg = smallint, rightarg = bigint);

comment on operator pg_catalog.-(smallint, bigint)
is 'subtract';

create operator pg_catalog.* (procedure = int28mul, leftarg = smallint, rightarg = bigint);

comment on operator pg_catalog.*(smallint, bigint)
is 'multiply';

create operator pg_catalog./ (procedure = int28div, leftarg = smallint, rightarg = bigint);

comment on operator pg_catalog./(smallint, bigint)
is 'divide';

create operator pg_catalog.* (procedure = cash_mul_flt4, leftarg = money, rightarg = real);

comment on operator pg_catalog.*(money, real)
is 'multiply';

create operator pg_catalog./ (procedure = cash_div_flt4, leftarg = money, rightarg = real);

comment on operator pg_catalog./(money, real)
is 'divide';

create operator pg_catalog.* (procedure = flt4_mul_cash, leftarg = real, rightarg = money);

comment on operator pg_catalog.*(real, money)
is 'multiply';

create operator pg_catalog.= (procedure = cash_eq, leftarg = money, rightarg = money);

comment on operator pg_catalog.=(money, money)
is 'equal';

create operator pg_catalog.<> (procedure = cash_ne, leftarg = money, rightarg = money);

comment on operator pg_catalog.<>(money, money)
is 'not equal';

create operator pg_catalog.< (procedure = cash_lt, leftarg = money, rightarg = money);

comment on operator pg_catalog.<(money, money)
is 'less than';

create operator pg_catalog.> (procedure = cash_gt, leftarg = money, rightarg = money);

comment on operator pg_catalog.>(money, money)
is 'greater than';

create operator pg_catalog.<= (procedure = cash_le, leftarg = money, rightarg = money);

comment on operator pg_catalog.<=(money, money)
is 'less than or equal';

create operator pg_catalog.>= (procedure = cash_ge, leftarg = money, rightarg = money);

comment on operator pg_catalog.>=(money, money)
is 'greater than or equal';

create operator pg_catalog.+ (procedure = cash_pl, leftarg = money, rightarg = money);

comment on operator pg_catalog.+(money, money)
is 'add';

create operator pg_catalog.- (procedure = cash_mi, leftarg = money, rightarg = money);

comment on operator pg_catalog.-(money, money)
is 'subtract';

create operator pg_catalog.* (procedure = cash_mul_flt8, leftarg = money, rightarg = double precision);

comment on operator pg_catalog.*(money, double precision)
is 'multiply';

create operator pg_catalog./ (procedure = cash_div_flt8, leftarg = money, rightarg = double precision);

comment on operator pg_catalog./(money, double precision)
is 'divide';

create operator pg_catalog.* (procedure = cash_mul_int4, leftarg = money, rightarg = integer);

comment on operator pg_catalog.*(money, integer)
is 'multiply';

create operator pg_catalog./ (procedure = cash_div_int4, leftarg = money, rightarg = integer);

comment on operator pg_catalog./(money, integer)
is 'divide';

create operator pg_catalog.* (procedure = cash_mul_int2, leftarg = money, rightarg = smallint);

comment on operator pg_catalog.*(money, smallint)
is 'multiply';

create operator pg_catalog./ (procedure = cash_div_int2, leftarg = money, rightarg = smallint);

comment on operator pg_catalog./(money, smallint)
is 'divide';

create operator pg_catalog.* (procedure = flt8_mul_cash, leftarg = double precision, rightarg = money);

comment on operator pg_catalog.*(double precision, money)
is 'multiply';

create operator pg_catalog.* (procedure = int4_mul_cash, leftarg = integer, rightarg = money);

comment on operator pg_catalog.*(integer, money)
is 'multiply';

create operator pg_catalog.* (procedure = int2_mul_cash, leftarg = smallint, rightarg = money);

comment on operator pg_catalog.*(smallint, money)
is 'multiply';

create operator pg_catalog.<< (procedure = network_sub, leftarg = inet, rightarg = inet);

comment on operator pg_catalog.<<(inet, inet)
is 'is subnet';

create operator pg_catalog.<<= (procedure = network_subeq, leftarg = inet, rightarg = inet);

comment on operator pg_catalog.<<=(inet, inet)
is 'is subnet or equal';

create operator pg_catalog.>> (procedure = network_sup, leftarg = inet, rightarg = inet);

comment on operator pg_catalog.>>(inet, inet)
is 'is supernet';

create operator pg_catalog.>>= (procedure = network_supeq, leftarg = inet, rightarg = inet);

comment on operator pg_catalog.>>=(inet, inet)
is 'is supernet or equal';

create operator pg_catalog.^ (procedure = dpow, leftarg = double precision, rightarg = double precision);

comment on operator pg_catalog.^(double precision, double precision)
is 'exponentiation';

create operator pg_catalog.+ (procedure = aclinsert, leftarg = aclitem [], rightarg = aclitem);

comment on operator pg_catalog.+(aclitem [], aclitem)
is 'add/update ACL item';

create operator pg_catalog.- (procedure = aclremove, leftarg = aclitem [], rightarg = aclitem);

comment on operator pg_catalog.-(aclitem [], aclitem)
is 'remove ACL item';

create operator pg_catalog.@> (procedure = aclcontains, leftarg = aclitem [], rightarg = aclitem);

comment on operator pg_catalog.@>(aclitem [], aclitem)
is 'contains';

create operator pg_catalog.@@ (procedure = lseg_center, rightarg = lseg);

comment on operator pg_catalog.@@(none, lseg)
is 'center of';

create operator pg_catalog.@@ (procedure = path_center, rightarg = path);

comment on operator pg_catalog.@@(none, path)
is 'center of';

create operator pg_catalog.@@ (procedure = poly_center, rightarg = polygon);

comment on operator pg_catalog.@@(none, polygon)
is 'center of';

create operator pg_catalog.= (procedure = aclitemeq, leftarg = aclitem, rightarg = aclitem);

comment on operator pg_catalog.=(aclitem, aclitem)
is 'equal';

create operator pg_catalog.^ (procedure = numeric_power, leftarg = numeric, rightarg = numeric);

comment on operator pg_catalog.^(numeric, numeric)
is 'exponentiation';

create operator pg_catalog.= (procedure = bpchareq, leftarg = char, rightarg = char);

comment on operator pg_catalog.=(char, char)
is 'equal';

create operator pg_catalog.~ (procedure = bpcharregexeq, leftarg = char, rightarg = text);

comment on operator pg_catalog.~(char, text)
is 'matches regular expression, case-sensitive';

create operator pg_catalog.!~ (procedure = bpcharregexne, leftarg = char, rightarg = text);

comment on operator pg_catalog.!~(char, text)
is 'does not match regular expression, case-sensitive';

create operator pg_catalog.<> (procedure = bpcharne, leftarg = char, rightarg = char);

comment on operator pg_catalog.<>(char, char)
is 'not equal';

create operator pg_catalog.< (procedure = bpcharlt, leftarg = char, rightarg = char);

comment on operator pg_catalog.<(char, char)
is 'less than';

create operator pg_catalog.<= (procedure = bpcharle, leftarg = char, rightarg = char);

comment on operator pg_catalog.<=(char, char)
is 'less than or equal';

create operator pg_catalog.> (procedure = bpchargt, leftarg = char, rightarg = char);

comment on operator pg_catalog.>(char, char)
is 'greater than';

create operator pg_catalog.>= (procedure = bpcharge, leftarg = char, rightarg = char);

comment on operator pg_catalog.>=(char, char)
is 'greater than or equal';

create operator pg_catalog.= (procedure = array_eq, leftarg = anyarray, rightarg = anyarray);

comment on operator pg_catalog.=(anyarray, anyarray)
is 'equal';

create operator pg_catalog.<> (procedure = array_ne, leftarg = anyarray, rightarg = anyarray);

comment on operator pg_catalog.<>(anyarray, anyarray)
is 'not equal';

create operator pg_catalog.< (procedure = array_lt, leftarg = anyarray, rightarg = anyarray);

comment on operator pg_catalog.<(anyarray, anyarray)
is 'less than';

create operator pg_catalog.> (procedure = array_gt, leftarg = anyarray, rightarg = anyarray);

comment on operator pg_catalog.>(anyarray, anyarray)
is 'greater than';

create operator pg_catalog.<= (procedure = array_le, leftarg = anyarray, rightarg = anyarray);

comment on operator pg_catalog.<=(anyarray, anyarray)
is 'less than or equal';

create operator pg_catalog.>= (procedure = array_ge, leftarg = anyarray, rightarg = anyarray);

comment on operator pg_catalog.>=(anyarray, anyarray)
is 'greater than or equal';

create operator pg_catalog.+ (procedure = date_pl_interval, leftarg = date, rightarg = interval);

comment on operator pg_catalog.+(date, interval)
is 'add';

create operator pg_catalog.- (procedure = date_mi_interval, leftarg = date, rightarg = interval);

comment on operator pg_catalog.-(date, interval)
is 'subtract';

create operator pg_catalog.= (procedure = date_eq, leftarg = date, rightarg = date);

comment on operator pg_catalog.=(date, date)
is 'equal';

create operator pg_catalog.<> (procedure = date_ne, leftarg = date, rightarg = date);

comment on operator pg_catalog.<>(date, date)
is 'not equal';

create operator pg_catalog.< (procedure = date_lt, leftarg = date, rightarg = date);

comment on operator pg_catalog.<(date, date)
is 'less than';

create operator pg_catalog.<= (procedure = date_le, leftarg = date, rightarg = date);

comment on operator pg_catalog.<=(date, date)
is 'less than or equal';

create operator pg_catalog.> (procedure = date_gt, leftarg = date, rightarg = date);

comment on operator pg_catalog.>(date, date)
is 'greater than';

create operator pg_catalog.>= (procedure = date_ge, leftarg = date, rightarg = date);

comment on operator pg_catalog.>=(date, date)
is 'greater than or equal';

create operator pg_catalog.- (procedure = date_mi, leftarg = date, rightarg = date);

comment on operator pg_catalog.-(date, date)
is 'subtract';

create operator pg_catalog.+ (procedure = date_pli, leftarg = date, rightarg = integer);

comment on operator pg_catalog.+(date, integer)
is 'add';

create operator pg_catalog.- (procedure = date_mii, leftarg = date, rightarg = integer);

comment on operator pg_catalog.-(date, integer)
is 'subtract';

create operator pg_catalog.= (procedure = time_eq, leftarg = time, rightarg = time);

comment on operator pg_catalog.=(time, time)
is 'equal';

create operator pg_catalog.<> (procedure = time_ne, leftarg = time, rightarg = time);

comment on operator pg_catalog.<>(time, time)
is 'not equal';

create operator pg_catalog.< (procedure = time_lt, leftarg = time, rightarg = time);

comment on operator pg_catalog.<(time, time)
is 'less than';

create operator pg_catalog.<= (procedure = time_le, leftarg = time, rightarg = time);

comment on operator pg_catalog.<=(time, time)
is 'less than or equal';

create operator pg_catalog.> (procedure = time_gt, leftarg = time, rightarg = time);

comment on operator pg_catalog.>(time, time)
is 'greater than';

create operator pg_catalog.>= (procedure = time_ge, leftarg = time, rightarg = time);

comment on operator pg_catalog.>=(time, time)
is 'greater than or equal';

create operator pg_catalog.+ (procedure = float48pl, leftarg = real, rightarg = double precision);

comment on operator pg_catalog.+(real, double precision)
is 'add';

create operator pg_catalog.- (procedure = float48mi, leftarg = real, rightarg = double precision);

comment on operator pg_catalog.-(real, double precision)
is 'subtract';

create operator pg_catalog./ (procedure = float48div, leftarg = real, rightarg = double precision);

comment on operator pg_catalog./(real, double precision)
is 'divide';

create operator pg_catalog.* (procedure = float48mul, leftarg = real, rightarg = double precision);

comment on operator pg_catalog.*(real, double precision)
is 'multiply';

create operator pg_catalog.= (procedure = float48eq, leftarg = real, rightarg = double precision);

comment on operator pg_catalog.=(real, double precision)
is 'equal';

create operator pg_catalog.<> (procedure = float48ne, leftarg = real, rightarg = double precision);

comment on operator pg_catalog.<>(real, double precision)
is 'not equal';

create operator pg_catalog.< (procedure = float48lt, leftarg = real, rightarg = double precision);

comment on operator pg_catalog.<(real, double precision)
is 'less than';

create operator pg_catalog.> (procedure = float48gt, leftarg = real, rightarg = double precision);

comment on operator pg_catalog.>(real, double precision)
is 'greater than';

create operator pg_catalog.<= (procedure = float48le, leftarg = real, rightarg = double precision);

comment on operator pg_catalog.<=(real, double precision)
is 'less than or equal';

create operator pg_catalog.>= (procedure = float48ge, leftarg = real, rightarg = double precision);

comment on operator pg_catalog.>=(real, double precision)
is 'greater than or equal';

create operator pg_catalog.+ (procedure = float84pl, leftarg = double precision, rightarg = real);

comment on operator pg_catalog.+(double precision, real)
is 'add';

create operator pg_catalog.- (procedure = float84mi, leftarg = double precision, rightarg = real);

comment on operator pg_catalog.-(double precision, real)
is 'subtract';

create operator pg_catalog./ (procedure = float84div, leftarg = double precision, rightarg = real);

comment on operator pg_catalog./(double precision, real)
is 'divide';

create operator pg_catalog.* (procedure = float84mul, leftarg = double precision, rightarg = real);

comment on operator pg_catalog.*(double precision, real)
is 'multiply';

create operator pg_catalog.= (procedure = float84eq, leftarg = double precision, rightarg = real);

comment on operator pg_catalog.=(double precision, real)
is 'equal';

create operator pg_catalog.<> (procedure = float84ne, leftarg = double precision, rightarg = real);

comment on operator pg_catalog.<>(double precision, real)
is 'not equal';

create operator pg_catalog.< (procedure = float84lt, leftarg = double precision, rightarg = real);

comment on operator pg_catalog.<(double precision, real)
is 'less than';

create operator pg_catalog.> (procedure = float84gt, leftarg = double precision, rightarg = real);

comment on operator pg_catalog.>(double precision, real)
is 'greater than';

create operator pg_catalog.<= (procedure = float84le, leftarg = double precision, rightarg = real);

comment on operator pg_catalog.<=(double precision, real)
is 'less than or equal';

create operator pg_catalog.>= (procedure = float84ge, leftarg = double precision, rightarg = real);

comment on operator pg_catalog.>=(double precision, real)
is 'greater than or equal';

create operator pg_catalog.= (procedure = network_eq, leftarg = inet, rightarg = inet);

comment on operator pg_catalog.=(inet, inet)
is 'equal';

create operator pg_catalog.<> (procedure = network_ne, leftarg = inet, rightarg = inet);

comment on operator pg_catalog.<>(inet, inet)
is 'not equal';

create operator pg_catalog.< (procedure = network_lt, leftarg = inet, rightarg = inet);

comment on operator pg_catalog.<(inet, inet)
is 'less than';

create operator pg_catalog.<= (procedure = network_le, leftarg = inet, rightarg = inet);

comment on operator pg_catalog.<=(inet, inet)
is 'less than or equal';

create operator pg_catalog.> (procedure = network_gt, leftarg = inet, rightarg = inet);

comment on operator pg_catalog.>(inet, inet)
is 'greater than';

create operator pg_catalog.>= (procedure = network_ge, leftarg = inet, rightarg = inet);

comment on operator pg_catalog.>=(inet, inet)
is 'greater than or equal';

create operator pg_catalog.~~ (procedure = namelike, leftarg = name, rightarg = text);

comment on operator pg_catalog.~~(name, text)
is 'matches LIKE expression';

create operator pg_catalog.!~~ (procedure = namenlike, leftarg = name, rightarg = text);

comment on operator pg_catalog.!~~(name, text)
is 'does not match LIKE expression';

create operator pg_catalog.~~ (procedure = textlike, leftarg = text, rightarg = text);

comment on operator pg_catalog.~~(text, text)
is 'matches LIKE expression';

create operator pg_catalog.!~~ (procedure = textnlike, leftarg = text, rightarg = text);

comment on operator pg_catalog.!~~(text, text)
is 'does not match LIKE expression';

create operator pg_catalog.~~ (procedure = bpcharlike, leftarg = char, rightarg = text);

comment on operator pg_catalog.~~(char, text)
is 'matches LIKE expression';

create operator pg_catalog.!~~ (procedure = bpcharnlike, leftarg = char, rightarg = text);

comment on operator pg_catalog.!~~(char, text)
is 'does not match LIKE expression';

create operator pg_catalog.= (procedure = macaddr_eq, leftarg = macaddr, rightarg = macaddr);

comment on operator pg_catalog.=(macaddr, macaddr)
is 'equal';

create operator pg_catalog.<> (procedure = macaddr_ne, leftarg = macaddr, rightarg = macaddr);

comment on operator pg_catalog.<>(macaddr, macaddr)
is 'not equal';

create operator pg_catalog.< (procedure = macaddr_lt, leftarg = macaddr, rightarg = macaddr);

comment on operator pg_catalog.<(macaddr, macaddr)
is 'less than';

create operator pg_catalog.<= (procedure = macaddr_le, leftarg = macaddr, rightarg = macaddr);

comment on operator pg_catalog.<=(macaddr, macaddr)
is 'less than or equal';

create operator pg_catalog.> (procedure = macaddr_gt, leftarg = macaddr, rightarg = macaddr);

comment on operator pg_catalog.>(macaddr, macaddr)
is 'greater than';

create operator pg_catalog.>= (procedure = macaddr_ge, leftarg = macaddr, rightarg = macaddr);

comment on operator pg_catalog.>=(macaddr, macaddr)
is 'greater than or equal';

create operator pg_catalog.~* (procedure = nameicregexeq, leftarg = name, rightarg = text);

comment on operator pg_catalog.~*(name, text)
is 'matches regular expression, case-insensitive';

create operator pg_catalog.!~* (procedure = nameicregexne, leftarg = name, rightarg = text);

comment on operator pg_catalog.!~*(name, text)
is 'does not match regular expression, case-insensitive';

create operator pg_catalog.~* (procedure = texticregexeq, leftarg = text, rightarg = text);

comment on operator pg_catalog.~*(text, text)
is 'matches regular expression, case-insensitive';

create operator pg_catalog.!~* (procedure = texticregexne, leftarg = text, rightarg = text);

comment on operator pg_catalog.!~*(text, text)
is 'does not match regular expression, case-insensitive';

create operator pg_catalog.~* (procedure = bpcharicregexeq, leftarg = char, rightarg = text);

comment on operator pg_catalog.~*(char, text)
is 'matches regular expression, case-insensitive';

create operator pg_catalog.!~* (procedure = bpcharicregexne, leftarg = char, rightarg = text);

comment on operator pg_catalog.!~*(char, text)
is 'does not match regular expression, case-insensitive';

create operator pg_catalog.| (procedure = tintervalstart, rightarg = tinterval);

comment on operator pg_catalog.|(none, tinterval)
is 'start of interval';

create operator pg_catalog.= (procedure = timestamptz_eq, leftarg = timestamp with time zone, rightarg = timestamp with time zone);

comment on operator pg_catalog.=(timestamp with time zone, timestamp with time zone)
is 'equal';

create operator pg_catalog.<> (procedure = timestamptz_ne, leftarg = timestamp with time zone, rightarg = timestamp with time zone);

comment on operator pg_catalog.<>(timestamp with time zone, timestamp with time zone)
is 'not equal';

create operator pg_catalog.< (procedure = timestamptz_lt, leftarg = timestamp with time zone, rightarg = timestamp with time zone);

comment on operator pg_catalog.<(timestamp with time zone, timestamp with time zone)
is 'less than';

create operator pg_catalog.<= (procedure = timestamptz_le, leftarg = timestamp with time zone, rightarg = timestamp with time zone);

comment on operator pg_catalog.<=(timestamp with time zone, timestamp with time zone)
is 'less than or equal';

create operator pg_catalog.> (procedure = timestamptz_gt, leftarg = timestamp with time zone, rightarg = timestamp with time zone);

comment on operator pg_catalog.>(timestamp with time zone, timestamp with time zone)
is 'greater than';

create operator pg_catalog.>= (procedure = timestamptz_ge, leftarg = timestamp with time zone, rightarg = timestamp with time zone);

comment on operator pg_catalog.>=(timestamp with time zone, timestamp with time zone)
is 'greater than or equal';

create operator pg_catalog.+ (procedure = timestamptz_pl_interval, leftarg = timestamp with time zone, rightarg = interval);

comment on operator pg_catalog.+(timestamp with time zone, interval)
is 'add';

create operator pg_catalog.- (procedure = timestamptz_mi, leftarg = timestamp with time zone, rightarg = timestamp with time zone);

comment on operator pg_catalog.-(timestamp with time zone, timestamp with time zone)
is 'subtract';

create operator pg_catalog.- (procedure = timestamptz_mi_interval, leftarg = timestamp with time zone, rightarg = interval);

comment on operator pg_catalog.-(timestamp with time zone, interval)
is 'subtract';

create operator pg_catalog.= (procedure = interval_eq, leftarg = interval, rightarg = interval);

comment on operator pg_catalog.=(interval, interval)
is 'equal';

create operator pg_catalog.<> (procedure = interval_ne, leftarg = interval, rightarg = interval);

comment on operator pg_catalog.<>(interval, interval)
is 'not equal';

create operator pg_catalog.< (procedure = interval_lt, leftarg = interval, rightarg = interval);

comment on operator pg_catalog.<(interval, interval)
is 'less than';

create operator pg_catalog.<= (procedure = interval_le, leftarg = interval, rightarg = interval);

comment on operator pg_catalog.<=(interval, interval)
is 'less than or equal';

create operator pg_catalog.> (procedure = interval_gt, leftarg = interval, rightarg = interval);

comment on operator pg_catalog.>(interval, interval)
is 'greater than';

create operator pg_catalog.>= (procedure = interval_ge, leftarg = interval, rightarg = interval);

comment on operator pg_catalog.>=(interval, interval)
is 'greater than or equal';

create operator pg_catalog.- (procedure = interval_um, rightarg = interval);

comment on operator pg_catalog.-(none, interval)
is 'negate';

create operator pg_catalog.+ (procedure = interval_pl, leftarg = interval, rightarg = interval);

comment on operator pg_catalog.+(interval, interval)
is 'add';

create operator pg_catalog.- (procedure = interval_mi, leftarg = interval, rightarg = interval);

comment on operator pg_catalog.-(interval, interval)
is 'subtract';

create operator pg_catalog.+ (procedure = datetime_pl, leftarg = date, rightarg = time);

comment on operator pg_catalog.+(date, time)
is 'convert date and time to timestamp';

create operator pg_catalog.+ (procedure = datetimetz_pl, leftarg = date, rightarg = time with time zone);

comment on operator pg_catalog.+(date, time with time zone)
is 'convert date and time with time zone to timestamp with time zone';

create operator pg_catalog.+ (procedure = timedate_pl, leftarg = time, rightarg = date);

comment on operator pg_catalog.+(time, date)
is 'convert time and date to timestamp';

create operator pg_catalog.+ (procedure = timetzdate_pl, leftarg = time with time zone, rightarg = date);

comment on operator pg_catalog.+(time with time zone, date)
is 'convert time with time zone and date to timestamp with time zone';

create operator pg_catalog.- (procedure = time_mi_time, leftarg = time, rightarg = time);

comment on operator pg_catalog.-(time, time)
is 'subtract';

create operator pg_catalog.@@ (procedure = circle_center, rightarg = circle);

comment on operator pg_catalog.@@(none, circle)
is 'center of';

create operator pg_catalog.= (procedure = circle_eq, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.=(circle, circle)
is 'equal by area';

create operator pg_catalog.<> (procedure = circle_ne, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.<>(circle, circle)
is 'not equal by area';

create operator pg_catalog.< (procedure = circle_lt, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.<(circle, circle)
is 'less than by area';

create operator pg_catalog.> (procedure = circle_gt, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.>(circle, circle)
is 'greater than by area';

create operator pg_catalog.<= (procedure = circle_le, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.<=(circle, circle)
is 'less than or equal by area';

create operator pg_catalog.>= (procedure = circle_ge, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.>=(circle, circle)
is 'greater than or equal by area';

create operator pg_catalog.<< (procedure = circle_left, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.<<(circle, circle)
is 'is left of';

create operator pg_catalog.&< (procedure = circle_overleft, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.&<(circle, circle)
is 'overlaps or is left of';

create operator pg_catalog.&> (procedure = circle_overright, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.&>(circle, circle)
is 'overlaps or is right of';

create operator pg_catalog.>> (procedure = circle_right, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.>>(circle, circle)
is 'is right of';

create operator pg_catalog.<@ (procedure = circle_contained, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.<@(circle, circle)
is 'is contained by';

create operator pg_catalog.@> (procedure = circle_contain, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.@>(circle, circle)
is 'contains';

create operator pg_catalog.~= (procedure = circle_same, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.~=(circle, circle)
is 'same as';

create operator pg_catalog.&& (procedure = circle_overlap, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.&&(circle, circle)
is 'overlaps';

create operator pg_catalog.|>> (procedure = circle_above, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.|>>(circle, circle)
is 'is above';

create operator pg_catalog.<<| (procedure = circle_below, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.<<|(circle, circle)
is 'is below';

create operator pg_catalog.+ (procedure = circle_add_pt, leftarg = circle, rightarg = point);

comment on operator pg_catalog.+(circle, point)
is 'add';

create operator pg_catalog.- (procedure = circle_sub_pt, leftarg = circle, rightarg = point);

comment on operator pg_catalog.-(circle, point)
is 'subtract';

create operator pg_catalog.* (procedure = circle_mul_pt, leftarg = circle, rightarg = point);

comment on operator pg_catalog.*(circle, point)
is 'multiply';

create operator pg_catalog./ (procedure = circle_div_pt, leftarg = circle, rightarg = point);

comment on operator pg_catalog./(circle, point)
is 'divide';

create operator pg_catalog.<-> (procedure = circle_distance, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.<->(circle, circle)
is 'distance between';

create operator pg_catalog.# (procedure = poly_npoints, rightarg = polygon);

comment on operator pg_catalog.#(none, polygon)
is 'number of points';

create operator pg_catalog.<-> (procedure = dist_pc, leftarg = point, rightarg = circle);

comment on operator pg_catalog.<->(point, circle)
is 'distance between';

create operator pg_catalog.<-> (procedure = dist_cpoly, leftarg = circle, rightarg = polygon);

comment on operator pg_catalog.<->(circle, polygon)
is 'distance between';

create operator pg_catalog.<-> (procedure = dist_lb, leftarg = line, rightarg = box);

comment on operator pg_catalog.<->(line, box)
is 'distance between';

create operator pg_catalog.?# (procedure = lseg_intersect, leftarg = lseg, rightarg = lseg);

comment on operator pg_catalog.?#(lseg, lseg)
is 'intersect';

create operator pg_catalog.?|| (procedure = lseg_parallel, leftarg = lseg, rightarg = lseg);

comment on operator pg_catalog.?||(lseg, lseg)
is 'parallel';

create operator pg_catalog.?-| (procedure = lseg_perp, leftarg = lseg, rightarg = lseg);

comment on operator pg_catalog.?-|(lseg, lseg)
is 'perpendicular';

create operator pg_catalog.?- (procedure = lseg_horizontal, rightarg = lseg);

comment on operator pg_catalog.?-(none, lseg)
is 'horizontal';

create operator pg_catalog.?| (procedure = lseg_vertical, rightarg = lseg);

comment on operator pg_catalog.?|(none, lseg)
is 'vertical';

create operator pg_catalog.= (procedure = lseg_eq, leftarg = lseg, rightarg = lseg);

comment on operator pg_catalog.=(lseg, lseg)
is 'equal';

create operator pg_catalog.# (procedure = lseg_interpt, leftarg = lseg, rightarg = lseg);

comment on operator pg_catalog.#(lseg, lseg)
is 'intersection point';

create operator pg_catalog.?# (procedure = inter_sl, leftarg = lseg, rightarg = line);

comment on operator pg_catalog.?#(lseg, line)
is 'intersect';

create operator pg_catalog.?# (procedure = inter_sb, leftarg = lseg, rightarg = box);

comment on operator pg_catalog.?#(lseg, box)
is 'intersect';

create operator pg_catalog.?# (procedure = inter_lb, leftarg = line, rightarg = box);

comment on operator pg_catalog.?#(line, box)
is 'intersect';

create operator pg_catalog.<@ (procedure = on_pl, leftarg = point, rightarg = line);

comment on operator pg_catalog.<@(point, line)
is 'point on line';

create operator pg_catalog.<@ (procedure = on_ps, leftarg = point, rightarg = lseg);

comment on operator pg_catalog.<@(point, lseg)
is 'is contained by';

create operator pg_catalog.<@ (procedure = on_sl, leftarg = lseg, rightarg = line);

comment on operator pg_catalog.<@(lseg, line)
is 'lseg on line';

create operator pg_catalog.<@ (procedure = on_sb, leftarg = lseg, rightarg = box);

comment on operator pg_catalog.<@(lseg, box)
is 'is contained by';

create operator pg_catalog.= (procedure = timetz_eq, leftarg = time with time zone, rightarg = time with time zone);

comment on operator pg_catalog.=(time with time zone, time with time zone)
is 'equal';

create operator pg_catalog.<> (procedure = timetz_ne, leftarg = time with time zone, rightarg = time with time zone);

comment on operator pg_catalog.<>(time with time zone, time with time zone)
is 'not equal';

create operator pg_catalog.< (procedure = timetz_lt, leftarg = time with time zone, rightarg = time with time zone);

comment on operator pg_catalog.<(time with time zone, time with time zone)
is 'less than';

create operator pg_catalog.<= (procedure = timetz_le, leftarg = time with time zone, rightarg = time with time zone);

comment on operator pg_catalog.<=(time with time zone, time with time zone)
is 'less than or equal';

create operator pg_catalog.> (procedure = timetz_gt, leftarg = time with time zone, rightarg = time with time zone);

comment on operator pg_catalog.>(time with time zone, time with time zone)
is 'greater than';

create operator pg_catalog.>= (procedure = timetz_ge, leftarg = time with time zone, rightarg = time with time zone);

comment on operator pg_catalog.>=(time with time zone, time with time zone)
is 'greater than or equal';

create operator pg_catalog.## (procedure = close_pl, leftarg = point, rightarg = line);

comment on operator pg_catalog.##(point, line)
is 'closest point to A on B';

create operator pg_catalog.## (procedure = close_ps, leftarg = point, rightarg = lseg);

comment on operator pg_catalog.##(point, lseg)
is 'closest point to A on B';

create operator pg_catalog.## (procedure = close_pb, leftarg = point, rightarg = box);

comment on operator pg_catalog.##(point, box)
is 'closest point to A on B';

create operator pg_catalog.## (procedure = close_sl, leftarg = lseg, rightarg = line);

comment on operator pg_catalog.##(lseg, line)
is 'closest point to A on B';

create operator pg_catalog.## (procedure = close_sb, leftarg = lseg, rightarg = box);

comment on operator pg_catalog.##(lseg, box)
is 'closest point to A on B';

create operator pg_catalog.## (procedure = close_lb, leftarg = line, rightarg = box);

comment on operator pg_catalog.##(line, box)
is 'closest point to A on B';

create operator pg_catalog.## (procedure = close_ls, leftarg = line, rightarg = lseg);

comment on operator pg_catalog.##(line, lseg)
is 'closest point to A on B';

create operator pg_catalog.## (procedure = close_lseg, leftarg = lseg, rightarg = lseg);

comment on operator pg_catalog.##(lseg, lseg)
is 'closest point to A on B';

create operator pg_catalog.* (procedure = interval_mul, leftarg = interval, rightarg = double precision);

comment on operator pg_catalog.*(interval, double precision)
is 'multiply';

create operator pg_catalog.* (procedure = mul_d_interval, leftarg = double precision, rightarg = interval);

comment on operator pg_catalog.*(double precision, interval)
is 'multiply';

create operator pg_catalog./ (procedure = interval_div, leftarg = interval, rightarg = double precision);

comment on operator pg_catalog./(interval, double precision)
is 'divide';

create operator pg_catalog.<> (procedure = lseg_ne, leftarg = lseg, rightarg = lseg);

comment on operator pg_catalog.<>(lseg, lseg)
is 'not equal';

create operator pg_catalog.< (procedure = lseg_lt, leftarg = lseg, rightarg = lseg);

comment on operator pg_catalog.<(lseg, lseg)
is 'less than by length';

create operator pg_catalog.<= (procedure = lseg_le, leftarg = lseg, rightarg = lseg);

comment on operator pg_catalog.<=(lseg, lseg)
is 'less than or equal by length';

create operator pg_catalog.> (procedure = lseg_gt, leftarg = lseg, rightarg = lseg);

comment on operator pg_catalog.>(lseg, lseg)
is 'greater than by length';

create operator pg_catalog.>= (procedure = lseg_ge, leftarg = lseg, rightarg = lseg);

comment on operator pg_catalog.>=(lseg, lseg)
is 'greater than or equal by length';

create operator pg_catalog.@-@ (procedure = lseg_length, rightarg = lseg);

comment on operator pg_catalog.@-@(none, lseg)
is 'distance between endpoints';

create operator pg_catalog.?# (procedure = line_intersect, leftarg = line, rightarg = line);

comment on operator pg_catalog.?#(line, line)
is 'intersect';

create operator pg_catalog.?|| (procedure = line_parallel, leftarg = line, rightarg = line);

comment on operator pg_catalog.?||(line, line)
is 'parallel';

create operator pg_catalog.?-| (procedure = line_perp, leftarg = line, rightarg = line);

comment on operator pg_catalog.?-|(line, line)
is 'perpendicular';

create operator pg_catalog.?- (procedure = line_horizontal, rightarg = line);

comment on operator pg_catalog.?-(none, line)
is 'horizontal';

create operator pg_catalog.?| (procedure = line_vertical, rightarg = line);

comment on operator pg_catalog.?|(none, line)
is 'vertical';

create operator pg_catalog.= (procedure = line_eq, leftarg = line, rightarg = line);

comment on operator pg_catalog.=(line, line)
is 'equal';

create operator pg_catalog.# (procedure = line_interpt, leftarg = line, rightarg = line);

comment on operator pg_catalog.#(line, line)
is 'intersection point';

create operator pg_catalog.~~* (procedure = nameiclike, leftarg = name, rightarg = text);

comment on operator pg_catalog.~~*(name, text)
is 'matches LIKE expression, case-insensitive';

create operator pg_catalog.!~~* (procedure = nameicnlike, leftarg = name, rightarg = text);

comment on operator pg_catalog.!~~*(name, text)
is 'does not match LIKE expression, case-insensitive';

create operator pg_catalog.~~* (procedure = texticlike, leftarg = text, rightarg = text);

comment on operator pg_catalog.~~*(text, text)
is 'matches LIKE expression, case-insensitive';

create operator pg_catalog.!~~* (procedure = texticnlike, leftarg = text, rightarg = text);

comment on operator pg_catalog.!~~*(text, text)
is 'does not match LIKE expression, case-insensitive';

create operator pg_catalog.~~* (procedure = bpchariclike, leftarg = char, rightarg = text);

comment on operator pg_catalog.~~*(char, text)
is 'matches LIKE expression, case-insensitive';

create operator pg_catalog.!~~* (procedure = bpcharicnlike, leftarg = char, rightarg = text);

comment on operator pg_catalog.!~~*(char, text)
is 'does not match LIKE expression, case-insensitive';

create operator pg_catalog.<= (procedure = boolle, leftarg = boolean, rightarg = boolean);

comment on operator pg_catalog.<=(boolean, boolean)
is 'less than or equal';

create operator pg_catalog.>= (procedure = boolge, leftarg = boolean, rightarg = boolean);

comment on operator pg_catalog.>=(boolean, boolean)
is 'greater than or equal';

create operator pg_catalog.- (procedure = numeric_uminus, rightarg = numeric);

comment on operator pg_catalog.-(none, numeric)
is 'negate';

create operator pg_catalog.= (procedure = numeric_eq, leftarg = numeric, rightarg = numeric);

comment on operator pg_catalog.=(numeric, numeric)
is 'equal';

create operator pg_catalog.<> (procedure = numeric_ne, leftarg = numeric, rightarg = numeric);

comment on operator pg_catalog.<>(numeric, numeric)
is 'not equal';

create operator pg_catalog.< (procedure = numeric_lt, leftarg = numeric, rightarg = numeric);

comment on operator pg_catalog.<(numeric, numeric)
is 'less than';

create operator pg_catalog.<= (procedure = numeric_le, leftarg = numeric, rightarg = numeric);

comment on operator pg_catalog.<=(numeric, numeric)
is 'less than or equal';

create operator pg_catalog.> (procedure = numeric_gt, leftarg = numeric, rightarg = numeric);

comment on operator pg_catalog.>(numeric, numeric)
is 'greater than';

create operator pg_catalog.>= (procedure = numeric_ge, leftarg = numeric, rightarg = numeric);

comment on operator pg_catalog.>=(numeric, numeric)
is 'greater than or equal';

create operator pg_catalog.+ (procedure = numeric_add, leftarg = numeric, rightarg = numeric);

comment on operator pg_catalog.+(numeric, numeric)
is 'add';

create operator pg_catalog.- (procedure = numeric_sub, leftarg = numeric, rightarg = numeric);

comment on operator pg_catalog.-(numeric, numeric)
is 'subtract';

create operator pg_catalog.* (procedure = numeric_mul, leftarg = numeric, rightarg = numeric);

comment on operator pg_catalog.*(numeric, numeric)
is 'multiply';

create operator pg_catalog./ (procedure = numeric_div, leftarg = numeric, rightarg = numeric);

comment on operator pg_catalog./(numeric, numeric)
is 'divide';

create operator pg_catalog.% (procedure = numeric_mod, leftarg = numeric, rightarg = numeric);

comment on operator pg_catalog.%(numeric, numeric)
is 'modulus';

create operator pg_catalog.@ (procedure = numeric_abs, rightarg = numeric);

comment on operator pg_catalog.@(none, numeric)
is 'absolute value';

create operator pg_catalog.= (procedure = biteq, leftarg = bit, rightarg = bit);

comment on operator pg_catalog.=(bit, bit)
is 'equal';

create operator pg_catalog.<> (procedure = bitne, leftarg = bit, rightarg = bit);

comment on operator pg_catalog.<>(bit, bit)
is 'not equal';

create operator pg_catalog.< (procedure = bitlt, leftarg = bit, rightarg = bit);

comment on operator pg_catalog.<(bit, bit)
is 'less than';

create operator pg_catalog.> (procedure = bitgt, leftarg = bit, rightarg = bit);

comment on operator pg_catalog.>(bit, bit)
is 'greater than';

create operator pg_catalog.<= (procedure = bitle, leftarg = bit, rightarg = bit);

comment on operator pg_catalog.<=(bit, bit)
is 'less than or equal';

create operator pg_catalog.>= (procedure = bitge, leftarg = bit, rightarg = bit);

comment on operator pg_catalog.>=(bit, bit)
is 'greater than or equal';

create operator pg_catalog.& (procedure = bitand, leftarg = bit, rightarg = bit);

comment on operator pg_catalog.&(bit, bit)
is 'bitwise and';

create operator pg_catalog.| (procedure = bitor, leftarg = bit, rightarg = bit);

comment on operator pg_catalog.|(bit, bit)
is 'bitwise or';

create operator pg_catalog.# (procedure = bitxor, leftarg = bit, rightarg = bit);

comment on operator pg_catalog.#(bit, bit)
is 'bitwise exclusive or';

create operator pg_catalog.~ (procedure = bitnot, rightarg = bit);

comment on operator pg_catalog.~(none, bit)
is 'bitwise not';

create operator pg_catalog.<< (procedure = bitshiftleft, leftarg = bit, rightarg = integer);

comment on operator pg_catalog.<<(bit, integer)
is 'bitwise shift left';

create operator pg_catalog.>> (procedure = bitshiftright, leftarg = bit, rightarg = integer);

comment on operator pg_catalog.>>(bit, integer)
is 'bitwise shift right';

create operator pg_catalog.|| (procedure = bitcat, leftarg = bit varying, rightarg = bit varying);

comment on operator pg_catalog.||(bit varying, bit varying)
is 'concatenate';

create operator pg_catalog.+ (procedure = time_pl_interval, leftarg = time, rightarg = interval);

comment on operator pg_catalog.+(time, interval)
is 'add';

create operator pg_catalog.- (procedure = time_mi_interval, leftarg = time, rightarg = interval);

comment on operator pg_catalog.-(time, interval)
is 'subtract';

create operator pg_catalog.+ (procedure = timetz_pl_interval, leftarg = time with time zone, rightarg = interval);

comment on operator pg_catalog.+(time with time zone, interval)
is 'add';

create operator pg_catalog.- (procedure = timetz_mi_interval, leftarg = time with time zone, rightarg = interval);

comment on operator pg_catalog.-(time with time zone, interval)
is 'subtract';

create operator pg_catalog.= (procedure = varbiteq, leftarg = bit varying, rightarg = bit varying);

comment on operator pg_catalog.=(bit varying, bit varying)
is 'equal';

create operator pg_catalog.<> (procedure = varbitne, leftarg = bit varying, rightarg = bit varying);

comment on operator pg_catalog.<>(bit varying, bit varying)
is 'not equal';

create operator pg_catalog.< (procedure = varbitlt, leftarg = bit varying, rightarg = bit varying);

comment on operator pg_catalog.<(bit varying, bit varying)
is 'less than';

create operator pg_catalog.> (procedure = varbitgt, leftarg = bit varying, rightarg = bit varying);

comment on operator pg_catalog.>(bit varying, bit varying)
is 'greater than';

create operator pg_catalog.<= (procedure = varbitle, leftarg = bit varying, rightarg = bit varying);

comment on operator pg_catalog.<=(bit varying, bit varying)
is 'less than or equal';

create operator pg_catalog.>= (procedure = varbitge, leftarg = bit varying, rightarg = bit varying);

comment on operator pg_catalog.>=(bit varying, bit varying)
is 'greater than or equal';

create operator pg_catalog.+ (procedure = interval_pl_time, leftarg = interval, rightarg = time);

comment on operator pg_catalog.+(interval, time)
is 'add';

create operator pg_catalog.= (procedure = int28eq, leftarg = smallint, rightarg = bigint);

comment on operator pg_catalog.=(smallint, bigint)
is 'equal';

create operator pg_catalog.<> (procedure = int28ne, leftarg = smallint, rightarg = bigint);

comment on operator pg_catalog.<>(smallint, bigint)
is 'not equal';

create operator pg_catalog.< (procedure = int28lt, leftarg = smallint, rightarg = bigint);

comment on operator pg_catalog.<(smallint, bigint)
is 'less than';

create operator pg_catalog.> (procedure = int28gt, leftarg = smallint, rightarg = bigint);

comment on operator pg_catalog.>(smallint, bigint)
is 'greater than';

create operator pg_catalog.<= (procedure = int28le, leftarg = smallint, rightarg = bigint);

comment on operator pg_catalog.<=(smallint, bigint)
is 'less than or equal';

create operator pg_catalog.>= (procedure = int28ge, leftarg = smallint, rightarg = bigint);

comment on operator pg_catalog.>=(smallint, bigint)
is 'greater than or equal';

create operator pg_catalog.= (procedure = int82eq, leftarg = bigint, rightarg = smallint);

comment on operator pg_catalog.=(bigint, smallint)
is 'equal';

create operator pg_catalog.<> (procedure = int82ne, leftarg = bigint, rightarg = smallint);

comment on operator pg_catalog.<>(bigint, smallint)
is 'not equal';

create operator pg_catalog.< (procedure = int82lt, leftarg = bigint, rightarg = smallint);

comment on operator pg_catalog.<(bigint, smallint)
is 'less than';

create operator pg_catalog.> (procedure = int82gt, leftarg = bigint, rightarg = smallint);

comment on operator pg_catalog.>(bigint, smallint)
is 'greater than';

create operator pg_catalog.<= (procedure = int82le, leftarg = bigint, rightarg = smallint);

comment on operator pg_catalog.<=(bigint, smallint)
is 'less than or equal';

create operator pg_catalog.>= (procedure = int82ge, leftarg = bigint, rightarg = smallint);

comment on operator pg_catalog.>=(bigint, smallint)
is 'greater than or equal';

create operator pg_catalog.& (procedure = int2and, leftarg = smallint, rightarg = smallint);

comment on operator pg_catalog.&(smallint, smallint)
is 'bitwise and';

create operator pg_catalog.| (procedure = int2or, leftarg = smallint, rightarg = smallint);

comment on operator pg_catalog.|(smallint, smallint)
is 'bitwise or';

create operator pg_catalog.# (procedure = int2xor, leftarg = smallint, rightarg = smallint);

comment on operator pg_catalog.#(smallint, smallint)
is 'bitwise exclusive or';

create operator pg_catalog.~ (procedure = int2not, rightarg = smallint);

comment on operator pg_catalog.~(none, smallint)
is 'bitwise not';

create operator pg_catalog.<< (procedure = int2shl, leftarg = smallint, rightarg = integer);

comment on operator pg_catalog.<<(smallint, integer)
is 'bitwise shift left';

create operator pg_catalog.>> (procedure = int2shr, leftarg = smallint, rightarg = integer);

comment on operator pg_catalog.>>(smallint, integer)
is 'bitwise shift right';

create operator pg_catalog.& (procedure = int4and, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.&(integer, integer)
is 'bitwise and';

create operator pg_catalog.| (procedure = int4or, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.|(integer, integer)
is 'bitwise or';

create operator pg_catalog.# (procedure = int4xor, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.#(integer, integer)
is 'bitwise exclusive or';

create operator pg_catalog.~ (procedure = int4not, rightarg = integer);

comment on operator pg_catalog.~(none, integer)
is 'bitwise not';

create operator pg_catalog.<< (procedure = int4shl, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.<<(integer, integer)
is 'bitwise shift left';

create operator pg_catalog.>> (procedure = int4shr, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.>>(integer, integer)
is 'bitwise shift right';

create operator pg_catalog.& (procedure = int8and, leftarg = bigint, rightarg = bigint);

comment on operator pg_catalog.&(bigint, bigint)
is 'bitwise and';

create operator pg_catalog.| (procedure = int8or, leftarg = bigint, rightarg = bigint);

comment on operator pg_catalog.|(bigint, bigint)
is 'bitwise or';

create operator pg_catalog.# (procedure = int8xor, leftarg = bigint, rightarg = bigint);

comment on operator pg_catalog.#(bigint, bigint)
is 'bitwise exclusive or';

create operator pg_catalog.~ (procedure = int8not, rightarg = bigint);

comment on operator pg_catalog.~(none, bigint)
is 'bitwise not';

create operator pg_catalog.<< (procedure = int8shl, leftarg = bigint, rightarg = integer);

comment on operator pg_catalog.<<(bigint, integer)
is 'bitwise shift left';

create operator pg_catalog.>> (procedure = int8shr, leftarg = bigint, rightarg = integer);

comment on operator pg_catalog.>>(bigint, integer)
is 'bitwise shift right';

create operator pg_catalog.+ (procedure = int8up, rightarg = bigint);

comment on operator pg_catalog.+(none, bigint)
is 'unary plus';

create operator pg_catalog.+ (procedure = int2up, rightarg = smallint);

comment on operator pg_catalog.+(none, smallint)
is 'unary plus';

create operator pg_catalog.+ (procedure = int4up, rightarg = integer);

comment on operator pg_catalog.+(none, integer)
is 'unary plus';

create operator pg_catalog.+ (procedure = float4up, rightarg = real);

comment on operator pg_catalog.+(none, real)
is 'unary plus';

create operator pg_catalog.+ (procedure = float8up, rightarg = double precision);

comment on operator pg_catalog.+(none, double precision)
is 'unary plus';

create operator pg_catalog.+ (procedure = numeric_uplus, rightarg = numeric);

comment on operator pg_catalog.+(none, numeric)
is 'unary plus';

create operator pg_catalog.= (procedure = byteaeq, leftarg = bytea, rightarg = bytea);

comment on operator pg_catalog.=(bytea, bytea)
is 'equal';

create operator pg_catalog.<> (procedure = byteane, leftarg = bytea, rightarg = bytea);

comment on operator pg_catalog.<>(bytea, bytea)
is 'not equal';

create operator pg_catalog.< (procedure = bytealt, leftarg = bytea, rightarg = bytea);

comment on operator pg_catalog.<(bytea, bytea)
is 'less than';

create operator pg_catalog.<= (procedure = byteale, leftarg = bytea, rightarg = bytea);

comment on operator pg_catalog.<=(bytea, bytea)
is 'less than or equal';

create operator pg_catalog.> (procedure = byteagt, leftarg = bytea, rightarg = bytea);

comment on operator pg_catalog.>(bytea, bytea)
is 'greater than';

create operator pg_catalog.>= (procedure = byteage, leftarg = bytea, rightarg = bytea);

comment on operator pg_catalog.>=(bytea, bytea)
is 'greater than or equal';

create operator pg_catalog.~~ (procedure = bytealike, leftarg = bytea, rightarg = bytea);

comment on operator pg_catalog.~~(bytea, bytea)
is 'matches LIKE expression';

create operator pg_catalog.!~~ (procedure = byteanlike, leftarg = bytea, rightarg = bytea);

comment on operator pg_catalog.!~~(bytea, bytea)
is 'does not match LIKE expression';

create operator pg_catalog.|| (procedure = byteacat, leftarg = bytea, rightarg = bytea);

comment on operator pg_catalog.||(bytea, bytea)
is 'concatenate';

create operator pg_catalog.= (procedure = timestamp_eq, leftarg = timestamp, rightarg = timestamp);

comment on operator pg_catalog.=(timestamp, timestamp)
is 'equal';

create operator pg_catalog.<> (procedure = timestamp_ne, leftarg = timestamp, rightarg = timestamp);

comment on operator pg_catalog.<>(timestamp, timestamp)
is 'not equal';

create operator pg_catalog.< (procedure = timestamp_lt, leftarg = timestamp, rightarg = timestamp);

comment on operator pg_catalog.<(timestamp, timestamp)
is 'less than';

create operator pg_catalog.<= (procedure = timestamp_le, leftarg = timestamp, rightarg = timestamp);

comment on operator pg_catalog.<=(timestamp, timestamp)
is 'less than or equal';

create operator pg_catalog.> (procedure = timestamp_gt, leftarg = timestamp, rightarg = timestamp);

comment on operator pg_catalog.>(timestamp, timestamp)
is 'greater than';

create operator pg_catalog.>= (procedure = timestamp_ge, leftarg = timestamp, rightarg = timestamp);

comment on operator pg_catalog.>=(timestamp, timestamp)
is 'greater than or equal';

create operator pg_catalog.+ (procedure = timestamp_pl_interval, leftarg = timestamp, rightarg = interval);

comment on operator pg_catalog.+(timestamp, interval)
is 'add';

create operator pg_catalog.- (procedure = timestamp_mi, leftarg = timestamp, rightarg = timestamp);

comment on operator pg_catalog.-(timestamp, timestamp)
is 'subtract';

create operator pg_catalog.- (procedure = timestamp_mi_interval, leftarg = timestamp, rightarg = interval);

comment on operator pg_catalog.-(timestamp, interval)
is 'subtract';

create operator pg_catalog.~<~ (procedure = text_pattern_lt, leftarg = text, rightarg = text);

comment on operator pg_catalog.~<~(text, text)
is 'less than';

create operator pg_catalog.~<=~ (procedure = text_pattern_le, leftarg = text, rightarg = text);

comment on operator pg_catalog.~<=~(text, text)
is 'less than or equal';

create operator pg_catalog.~>=~ (procedure = text_pattern_ge, leftarg = text, rightarg = text);

comment on operator pg_catalog.~>=~(text, text)
is 'greater than or equal';

create operator pg_catalog.~>~ (procedure = text_pattern_gt, leftarg = text, rightarg = text);

comment on operator pg_catalog.~>~(text, text)
is 'greater than';

create operator pg_catalog.~<~ (procedure = bpchar_pattern_lt, leftarg = char, rightarg = char);

comment on operator pg_catalog.~<~(char, char)
is 'less than';

create operator pg_catalog.~<=~ (procedure = bpchar_pattern_le, leftarg = char, rightarg = char);

comment on operator pg_catalog.~<=~(char, char)
is 'less than or equal';

create operator pg_catalog.~>=~ (procedure = bpchar_pattern_ge, leftarg = char, rightarg = char);

comment on operator pg_catalog.~>=~(char, char)
is 'greater than or equal';

create operator pg_catalog.~>~ (procedure = bpchar_pattern_gt, leftarg = char, rightarg = char);

comment on operator pg_catalog.~>~(char, char)
is 'greater than';

create operator pg_catalog.< (procedure = date_lt_timestamp, leftarg = date, rightarg = timestamp);

comment on operator pg_catalog.<(date, timestamp)
is 'less than';

create operator pg_catalog.<= (procedure = date_le_timestamp, leftarg = date, rightarg = timestamp);

comment on operator pg_catalog.<=(date, timestamp)
is 'less than or equal';

create operator pg_catalog.= (procedure = date_eq_timestamp, leftarg = date, rightarg = timestamp);

comment on operator pg_catalog.=(date, timestamp)
is 'equal';

create operator pg_catalog.>= (procedure = date_ge_timestamp, leftarg = date, rightarg = timestamp);

comment on operator pg_catalog.>=(date, timestamp)
is 'greater than or equal';

create operator pg_catalog.> (procedure = date_gt_timestamp, leftarg = date, rightarg = timestamp);

comment on operator pg_catalog.>(date, timestamp)
is 'greater than';

create operator pg_catalog.<> (procedure = date_ne_timestamp, leftarg = date, rightarg = timestamp);

comment on operator pg_catalog.<>(date, timestamp)
is 'not equal';

create operator pg_catalog.< (procedure = date_lt_timestamptz, leftarg = date, rightarg = timestamp with time zone);

comment on operator pg_catalog.<(date, timestamp with time zone)
is 'less than';

create operator pg_catalog.<= (procedure = date_le_timestamptz, leftarg = date, rightarg = timestamp with time zone);

comment on operator pg_catalog.<=(date, timestamp with time zone)
is 'less than or equal';

create operator pg_catalog.= (procedure = date_eq_timestamptz, leftarg = date, rightarg = timestamp with time zone);

comment on operator pg_catalog.=(date, timestamp with time zone)
is 'equal';

create operator pg_catalog.>= (procedure = date_ge_timestamptz, leftarg = date, rightarg = timestamp with time zone);

comment on operator pg_catalog.>=(date, timestamp with time zone)
is 'greater than or equal';

create operator pg_catalog.> (procedure = date_gt_timestamptz, leftarg = date, rightarg = timestamp with time zone);

comment on operator pg_catalog.>(date, timestamp with time zone)
is 'greater than';

create operator pg_catalog.<> (procedure = date_ne_timestamptz, leftarg = date, rightarg = timestamp with time zone);

comment on operator pg_catalog.<>(date, timestamp with time zone)
is 'not equal';

create operator pg_catalog.< (procedure = timestamp_lt_date, leftarg = timestamp, rightarg = date);

comment on operator pg_catalog.<(timestamp, date)
is 'less than';

create operator pg_catalog.<= (procedure = timestamp_le_date, leftarg = timestamp, rightarg = date);

comment on operator pg_catalog.<=(timestamp, date)
is 'less than or equal';

create operator pg_catalog.= (procedure = timestamp_eq_date, leftarg = timestamp, rightarg = date);

comment on operator pg_catalog.=(timestamp, date)
is 'equal';

create operator pg_catalog.>= (procedure = timestamp_ge_date, leftarg = timestamp, rightarg = date);

comment on operator pg_catalog.>=(timestamp, date)
is 'greater than or equal';

create operator pg_catalog.> (procedure = timestamp_gt_date, leftarg = timestamp, rightarg = date);

comment on operator pg_catalog.>(timestamp, date)
is 'greater than';

create operator pg_catalog.<> (procedure = timestamp_ne_date, leftarg = timestamp, rightarg = date);

comment on operator pg_catalog.<>(timestamp, date)
is 'not equal';

create operator pg_catalog.< (procedure = timestamptz_lt_date, leftarg = timestamp with time zone, rightarg = date);

comment on operator pg_catalog.<(timestamp with time zone, date)
is 'less than';

create operator pg_catalog.<= (procedure = timestamptz_le_date, leftarg = timestamp with time zone, rightarg = date);

comment on operator pg_catalog.<=(timestamp with time zone, date)
is 'less than or equal';

create operator pg_catalog.= (procedure = timestamptz_eq_date, leftarg = timestamp with time zone, rightarg = date);

comment on operator pg_catalog.=(timestamp with time zone, date)
is 'equal';

create operator pg_catalog.>= (procedure = timestamptz_ge_date, leftarg = timestamp with time zone, rightarg = date);

comment on operator pg_catalog.>=(timestamp with time zone, date)
is 'greater than or equal';

create operator pg_catalog.> (procedure = timestamptz_gt_date, leftarg = timestamp with time zone, rightarg = date);

comment on operator pg_catalog.>(timestamp with time zone, date)
is 'greater than';

create operator pg_catalog.<> (procedure = timestamptz_ne_date, leftarg = timestamp with time zone, rightarg = date);

comment on operator pg_catalog.<>(timestamp with time zone, date)
is 'not equal';

create operator pg_catalog.< (procedure = timestamp_lt_timestamptz, leftarg = timestamp, rightarg = timestamp with time zone);

comment on operator pg_catalog.<(timestamp, timestamp with time zone)
is 'less than';

create operator pg_catalog.<= (procedure = timestamp_le_timestamptz, leftarg = timestamp, rightarg = timestamp with time zone);

comment on operator pg_catalog.<=(timestamp, timestamp with time zone)
is 'less than or equal';

create operator pg_catalog.= (procedure = timestamp_eq_timestamptz, leftarg = timestamp, rightarg = timestamp with time zone);

comment on operator pg_catalog.=(timestamp, timestamp with time zone)
is 'equal';

create operator pg_catalog.>= (procedure = timestamp_ge_timestamptz, leftarg = timestamp, rightarg = timestamp with time zone);

comment on operator pg_catalog.>=(timestamp, timestamp with time zone)
is 'greater than or equal';

create operator pg_catalog.> (procedure = timestamp_gt_timestamptz, leftarg = timestamp, rightarg = timestamp with time zone);

comment on operator pg_catalog.>(timestamp, timestamp with time zone)
is 'greater than';

create operator pg_catalog.<> (procedure = timestamp_ne_timestamptz, leftarg = timestamp, rightarg = timestamp with time zone);

comment on operator pg_catalog.<>(timestamp, timestamp with time zone)
is 'not equal';

create operator pg_catalog.< (procedure = timestamptz_lt_timestamp, leftarg = timestamp with time zone, rightarg = timestamp);

comment on operator pg_catalog.<(timestamp with time zone, timestamp)
is 'less than';

create operator pg_catalog.<= (procedure = timestamptz_le_timestamp, leftarg = timestamp with time zone, rightarg = timestamp);

comment on operator pg_catalog.<=(timestamp with time zone, timestamp)
is 'less than or equal';

create operator pg_catalog.= (procedure = timestamptz_eq_timestamp, leftarg = timestamp with time zone, rightarg = timestamp);

comment on operator pg_catalog.=(timestamp with time zone, timestamp)
is 'equal';

create operator pg_catalog.>= (procedure = timestamptz_ge_timestamp, leftarg = timestamp with time zone, rightarg = timestamp);

comment on operator pg_catalog.>=(timestamp with time zone, timestamp)
is 'greater than or equal';

create operator pg_catalog.> (procedure = timestamptz_gt_timestamp, leftarg = timestamp with time zone, rightarg = timestamp);

comment on operator pg_catalog.>(timestamp with time zone, timestamp)
is 'greater than';

create operator pg_catalog.<> (procedure = timestamptz_ne_timestamp, leftarg = timestamp with time zone, rightarg = timestamp);

comment on operator pg_catalog.<>(timestamp with time zone, timestamp)
is 'not equal';

create operator pg_catalog.+ (procedure = interval_pl_date, leftarg = interval, rightarg = date);

comment on operator pg_catalog.+(interval, date)
is 'add';

create operator pg_catalog.+ (procedure = interval_pl_timetz, leftarg = interval, rightarg = time with time zone);

comment on operator pg_catalog.+(interval, time with time zone)
is 'add';

create operator pg_catalog.+ (procedure = interval_pl_timestamp, leftarg = interval, rightarg = timestamp);

comment on operator pg_catalog.+(interval, timestamp)
is 'add';

create operator pg_catalog.+ (procedure = interval_pl_timestamptz, leftarg = interval, rightarg = timestamp with time zone);

comment on operator pg_catalog.+(interval, timestamp with time zone)
is 'add';

create operator pg_catalog.+ (procedure = integer_pl_date, leftarg = integer, rightarg = date);

comment on operator pg_catalog.+(integer, date)
is 'add';

create operator pg_catalog.<<| (procedure = box_below, leftarg = box, rightarg = box);

comment on operator pg_catalog.<<|(box, box)
is 'is below';

create operator pg_catalog.&<| (procedure = box_overbelow, leftarg = box, rightarg = box);

comment on operator pg_catalog.&<|(box, box)
is 'overlaps or is below';

create operator pg_catalog.|&> (procedure = box_overabove, leftarg = box, rightarg = box);

comment on operator pg_catalog.|&>(box, box)
is 'overlaps or is above';

create operator pg_catalog.|>> (procedure = box_above, leftarg = box, rightarg = box);

comment on operator pg_catalog.|>>(box, box)
is 'is above';

create operator pg_catalog.<<| (procedure = poly_below, leftarg = polygon, rightarg = polygon);

comment on operator pg_catalog.<<|(polygon, polygon)
is 'is below';

create operator pg_catalog.&<| (procedure = poly_overbelow, leftarg = polygon, rightarg = polygon);

comment on operator pg_catalog.&<|(polygon, polygon)
is 'overlaps or is below';

create operator pg_catalog.|&> (procedure = poly_overabove, leftarg = polygon, rightarg = polygon);

comment on operator pg_catalog.|&>(polygon, polygon)
is 'overlaps or is above';

create operator pg_catalog.|>> (procedure = poly_above, leftarg = polygon, rightarg = polygon);

comment on operator pg_catalog.|>>(polygon, polygon)
is 'is above';

create operator pg_catalog.&<| (procedure = circle_overbelow, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.&<|(circle, circle)
is 'overlaps or is below';

create operator pg_catalog.|&> (procedure = circle_overabove, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.|&>(circle, circle)
is 'overlaps or is above';

create operator pg_catalog.~ (procedure = inetnot, rightarg = inet);

comment on operator pg_catalog.~(none, inet)
is 'bitwise not';

create operator pg_catalog.& (procedure = inetand, leftarg = inet, rightarg = inet);

comment on operator pg_catalog.&(inet, inet)
is 'bitwise and';

create operator pg_catalog.| (procedure = inetor, leftarg = inet, rightarg = inet);

comment on operator pg_catalog.|(inet, inet)
is 'bitwise or';

create operator pg_catalog.+ (procedure = inetpl, leftarg = inet, rightarg = bigint);

comment on operator pg_catalog.+(inet, bigint)
is 'add';

create operator pg_catalog.+ (procedure = int8pl_inet, leftarg = bigint, rightarg = inet);

comment on operator pg_catalog.+(bigint, inet)
is 'add';

create operator pg_catalog.- (procedure = inetmi_int8, leftarg = inet, rightarg = bigint);

comment on operator pg_catalog.-(inet, bigint)
is 'subtract';

create operator pg_catalog.- (procedure = inetmi, leftarg = inet, rightarg = inet);

comment on operator pg_catalog.-(inet, inet)
is 'subtract';

create operator pg_catalog.&& (procedure = arrayoverlap, leftarg = anyarray, rightarg = anyarray);

comment on operator pg_catalog.&&(anyarray, anyarray)
is 'overlaps';

create operator pg_catalog.@> (procedure = arraycontains, leftarg = anyarray, rightarg = anyarray);

comment on operator pg_catalog.@>(anyarray, anyarray)
is 'contains';

create operator pg_catalog.<@ (procedure = arraycontained, leftarg = anyarray, rightarg = anyarray);

comment on operator pg_catalog.<@(anyarray, anyarray)
is 'is contained by';

create operator pg_catalog.|| (procedure = textanycat, leftarg = text, rightarg = anynonarray);

comment on operator pg_catalog.||(text, anynonarray)
is 'concatenate';

create operator pg_catalog.|| (procedure = anytextcat, leftarg = anynonarray, rightarg = text);

comment on operator pg_catalog.||(anynonarray, text)
is 'concatenate';

create operator pg_catalog.< (procedure = tidlt, leftarg = tid, rightarg = tid);

comment on operator pg_catalog.<(tid, tid)
is 'less than';

create operator pg_catalog.> (procedure = tidgt, leftarg = tid, rightarg = tid);

comment on operator pg_catalog.>(tid, tid)
is 'greater than';

create operator pg_catalog.<= (procedure = tidle, leftarg = tid, rightarg = tid);

comment on operator pg_catalog.<=(tid, tid)
is 'less than or equal';

create operator pg_catalog.>= (procedure = tidge, leftarg = tid, rightarg = tid);

comment on operator pg_catalog.>=(tid, tid)
is 'greater than or equal';

create operator pg_catalog.@ (procedure = poly_contained, leftarg = polygon, rightarg = polygon);

comment on operator pg_catalog.@(polygon, polygon)
is 'deprecated, use <@ instead';

create operator pg_catalog.~ (procedure = poly_contain, leftarg = polygon, rightarg = polygon);

comment on operator pg_catalog.~(polygon, polygon)
is 'deprecated, use @> instead';

create operator pg_catalog.@ (procedure = box_contained, leftarg = box, rightarg = box);

comment on operator pg_catalog.@(box, box)
is 'deprecated, use <@ instead';

create operator pg_catalog.~ (procedure = box_contain, leftarg = box, rightarg = box);

comment on operator pg_catalog.~(box, box)
is 'deprecated, use @> instead';

create operator pg_catalog.@ (procedure = circle_contained, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.@(circle, circle)
is 'deprecated, use <@ instead';

create operator pg_catalog.~ (procedure = circle_contain, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.~(circle, circle)
is 'deprecated, use @> instead';

create operator pg_catalog.@ (procedure = on_pb, leftarg = point, rightarg = box);

comment on operator pg_catalog.@(point, box)
is 'deprecated, use <@ instead';

create operator pg_catalog.@ (procedure = on_ppath, leftarg = point, rightarg = path);

comment on operator pg_catalog.@(point, path)
is 'deprecated, use <@ instead';

create operator pg_catalog.~ (procedure = path_contain_pt, leftarg = path, rightarg = point);

comment on operator pg_catalog.~(path, point)
is 'deprecated, use @> instead';

create operator pg_catalog.@ (procedure = pt_contained_poly, leftarg = point, rightarg = polygon);

comment on operator pg_catalog.@(point, polygon)
is 'deprecated, use <@ instead';

create operator pg_catalog.~ (procedure = poly_contain_pt, leftarg = polygon, rightarg = point);

comment on operator pg_catalog.~(polygon, point)
is 'deprecated, use @> instead';

create operator pg_catalog.@ (procedure = pt_contained_circle, leftarg = point, rightarg = circle);

comment on operator pg_catalog.@(point, circle)
is 'deprecated, use <@ instead';

create operator pg_catalog.~ (procedure = circle_contain_pt, leftarg = circle, rightarg = point);

comment on operator pg_catalog.~(circle, point)
is 'deprecated, use @> instead';

create operator pg_catalog.@ (procedure = on_pl, leftarg = point, rightarg = line);

comment on operator pg_catalog.@(point, line)
is 'deprecated, use <@ instead';

create operator pg_catalog.@ (procedure = on_ps, leftarg = point, rightarg = lseg);

comment on operator pg_catalog.@(point, lseg)
is 'deprecated, use <@ instead';

create operator pg_catalog.@ (procedure = on_sl, leftarg = lseg, rightarg = line);

comment on operator pg_catalog.@(lseg, line)
is 'deprecated, use <@ instead';

create operator pg_catalog.@ (procedure = on_sb, leftarg = lseg, rightarg = box);

comment on operator pg_catalog.@(lseg, box)
is 'deprecated, use <@ instead';

create operator pg_catalog.~ (procedure = aclcontains, leftarg = aclitem [], rightarg = aclitem);

comment on operator pg_catalog.~(aclitem [], aclitem)
is 'deprecated, use @> instead';

create operator pg_catalog.= (procedure = uuid_eq, leftarg = uuid, rightarg = uuid);

comment on operator pg_catalog.=(uuid, uuid)
is 'equal';

create operator pg_catalog.<> (procedure = uuid_ne, leftarg = uuid, rightarg = uuid);

comment on operator pg_catalog.<>(uuid, uuid)
is 'not equal';

create operator pg_catalog.< (procedure = uuid_lt, leftarg = uuid, rightarg = uuid);

comment on operator pg_catalog.<(uuid, uuid)
is 'less than';

create operator pg_catalog.> (procedure = uuid_gt, leftarg = uuid, rightarg = uuid);

comment on operator pg_catalog.>(uuid, uuid)
is 'greater than';

create operator pg_catalog.<= (procedure = uuid_le, leftarg = uuid, rightarg = uuid);

comment on operator pg_catalog.<=(uuid, uuid)
is 'less than or equal';

create operator pg_catalog.>= (procedure = uuid_ge, leftarg = uuid, rightarg = uuid);

comment on operator pg_catalog.>=(uuid, uuid)
is 'greater than or equal';

create operator pg_catalog.= (procedure = record_eq, leftarg = record, rightarg = record);

comment on operator pg_catalog.=(record, record)
is 'equal';

create operator pg_catalog.<> (procedure = record_ne, leftarg = record, rightarg = record);

comment on operator pg_catalog.<>(record, record)
is 'not equal';

create operator pg_catalog.< (procedure = record_lt, leftarg = record, rightarg = record);

comment on operator pg_catalog.<(record, record)
is 'less than';

create operator pg_catalog.> (procedure = record_gt, leftarg = record, rightarg = record);

comment on operator pg_catalog.>(record, record)
is 'greater than';

create operator pg_catalog.<= (procedure = record_le, leftarg = record, rightarg = record);

comment on operator pg_catalog.<=(record, record)
is 'less than or equal';

create operator pg_catalog.>= (procedure = record_ge, leftarg = record, rightarg = record);

comment on operator pg_catalog.>=(record, record)
is 'greater than or equal';

create operator pg_catalog.~ (procedure = macaddr_not, rightarg = macaddr);

comment on operator pg_catalog.~(none, macaddr)
is 'bitwise not';

create operator pg_catalog.& (procedure = macaddr_and, leftarg = macaddr, rightarg = macaddr);

comment on operator pg_catalog.&(macaddr, macaddr)
is 'bitwise and';

create operator pg_catalog.| (procedure = macaddr_or, leftarg = macaddr, rightarg = macaddr);

comment on operator pg_catalog.|(macaddr, macaddr)
is 'bitwise or';

create operator pg_catalog.*= (procedure = record_image_eq, leftarg = record, rightarg = record);

comment on operator pg_catalog.*=(record, record)
is 'identical';

create operator pg_catalog.*<> (procedure = record_image_ne, leftarg = record, rightarg = record);

comment on operator pg_catalog.*<>(record, record)
is 'not identical';

create operator pg_catalog.*< (procedure = record_image_lt, leftarg = record, rightarg = record);

comment on operator pg_catalog.*<(record, record)
is 'less than';

create operator pg_catalog.*> (procedure = record_image_gt, leftarg = record, rightarg = record);

comment on operator pg_catalog.*>(record, record)
is 'greater than';

create operator pg_catalog.*<= (procedure = record_image_le, leftarg = record, rightarg = record);

comment on operator pg_catalog.*<=(record, record)
is 'less than or equal';

create operator pg_catalog.*>= (procedure = record_image_ge, leftarg = record, rightarg = record);

comment on operator pg_catalog.*>=(record, record)
is 'greater than or equal';

create operator pg_catalog.#>> (procedure = jsonb_extract_path_text, leftarg = jsonb, rightarg = text []);

comment on operator pg_catalog.#>>(jsonb, text [])
is 'get value from jsonb as text with path elements';

create operator pg_catalog.-> (procedure = jsonb_object_field, leftarg = jsonb, rightarg = text);

comment on operator pg_catalog.->(jsonb, text)
is 'get jsonb object field';

create operator pg_catalog.-> (procedure = jsonb_array_element, leftarg = jsonb, rightarg = integer);

comment on operator pg_catalog.->(jsonb, integer)
is 'get jsonb array element';

create operator pg_catalog.#> (procedure = jsonb_extract_path, leftarg = jsonb, rightarg = text []);

comment on operator pg_catalog.#>(jsonb, text [])
is 'get value from jsonb with path elements';

create operator pg_catalog.= (procedure = pg_lsn_eq, leftarg = pg_lsn, rightarg = pg_lsn);

comment on operator pg_catalog.=(pg_lsn, pg_lsn)
is 'equal';

create operator pg_catalog.<> (procedure = pg_lsn_ne, leftarg = pg_lsn, rightarg = pg_lsn);

comment on operator pg_catalog.<>(pg_lsn, pg_lsn)
is 'not equal';

create operator pg_catalog.< (procedure = pg_lsn_lt, leftarg = pg_lsn, rightarg = pg_lsn);

comment on operator pg_catalog.<(pg_lsn, pg_lsn)
is 'less than';

create operator pg_catalog.> (procedure = pg_lsn_gt, leftarg = pg_lsn, rightarg = pg_lsn);

comment on operator pg_catalog.>(pg_lsn, pg_lsn)
is 'greater than';

create operator pg_catalog.<= (procedure = pg_lsn_le, leftarg = pg_lsn, rightarg = pg_lsn);

comment on operator pg_catalog.<=(pg_lsn, pg_lsn)
is 'less than or equal';

create operator pg_catalog.>= (procedure = pg_lsn_ge, leftarg = pg_lsn, rightarg = pg_lsn);

comment on operator pg_catalog.>=(pg_lsn, pg_lsn)
is 'greater than or equal';

create operator pg_catalog.- (procedure = pg_lsn_mi, leftarg = pg_lsn, rightarg = pg_lsn);

comment on operator pg_catalog.-(pg_lsn, pg_lsn)
is 'minus';

create operator pg_catalog.= (procedure = jsonb_eq, leftarg = jsonb, rightarg = jsonb);

comment on operator pg_catalog.=(jsonb, jsonb)
is 'equal';

create operator pg_catalog.<> (procedure = jsonb_ne, leftarg = jsonb, rightarg = jsonb);

comment on operator pg_catalog.<>(jsonb, jsonb)
is 'not equal';

create operator pg_catalog.< (procedure = jsonb_lt, leftarg = jsonb, rightarg = jsonb);

comment on operator pg_catalog.<(jsonb, jsonb)
is 'less than';

create operator pg_catalog.> (procedure = jsonb_gt, leftarg = jsonb, rightarg = jsonb);

comment on operator pg_catalog.>(jsonb, jsonb)
is 'greater than';

create operator pg_catalog.<= (procedure = jsonb_le, leftarg = jsonb, rightarg = jsonb);

comment on operator pg_catalog.<=(jsonb, jsonb)
is 'less than or equal';

create operator pg_catalog.>= (procedure = jsonb_ge, leftarg = jsonb, rightarg = jsonb);

comment on operator pg_catalog.>=(jsonb, jsonb)
is 'greater than or equal';

create operator pg_catalog.@> (procedure = jsonb_contains, leftarg = jsonb, rightarg = jsonb);

comment on operator pg_catalog.@>(jsonb, jsonb)
is 'contains';

create operator pg_catalog.? ( procedure = jsonb_exists, leftarg = jsonb, rightarg = text);

comment on operator pg_catalog.? (jsonb, text) is 'key exists';

create operator pg_catalog.?| (procedure = jsonb_exists_any, leftarg = jsonb, rightarg = text []);

comment on operator pg_catalog.?|(jsonb, text [])
is 'any key exists';

create operator pg_catalog.?& (procedure = jsonb_exists_all, leftarg = jsonb, rightarg = text []);

comment on operator pg_catalog.?&(jsonb, text [])
is 'all keys exist';

create operator pg_catalog.<@ (procedure = jsonb_contained, leftarg = jsonb, rightarg = jsonb);

comment on operator pg_catalog.<@(jsonb, jsonb)
is 'is contained by';

create operator pg_catalog.<-> (procedure = dist_ppoly, leftarg = point, rightarg = polygon);

comment on operator pg_catalog.<->(point, polygon)
is 'distance between';

create operator pg_catalog.|| (procedure = jsonb_concat, leftarg = jsonb, rightarg = jsonb);

comment on operator pg_catalog.||(jsonb, jsonb)
is 'concatenate';

create operator pg_catalog.- (procedure = "pg_catalog.jsonb_delete", leftarg = jsonb, rightarg = text);

comment on operator pg_catalog.-(jsonb, text)
is 'delete object field';

create operator pg_catalog.- (procedure = "pg_catalog.jsonb_delete", leftarg = jsonb, rightarg = integer);

comment on operator pg_catalog.-(jsonb, integer)
is 'delete array element';

create operator pg_catalog.#- (procedure = jsonb_delete_path, leftarg = jsonb, rightarg = text []);

comment on operator pg_catalog.#-(jsonb, text [])
is 'delete path';

create operator pg_catalog.<-> (procedure = dist_polyp, leftarg = polygon, rightarg = point);

comment on operator pg_catalog.<->(polygon, point)
is 'distance between';

create operator pg_catalog.<-> (procedure = dist_cpoint, leftarg = circle, rightarg = point);

comment on operator pg_catalog.<->(circle, point)
is 'distance between';

create operator pg_catalog.<> (procedure = xidneq, leftarg = xid, rightarg = xid);

comment on operator pg_catalog.<>(xid, xid)
is 'not equal';

create operator pg_catalog.<> (procedure = xidneqint4, leftarg = xid, rightarg = integer);

comment on operator pg_catalog.<>(xid, integer)
is 'not equal';

create operator pg_catalog.* (procedure = cash_mul_int8, leftarg = money, rightarg = bigint);

comment on operator pg_catalog.*(money, bigint)
is 'multiply';

create operator pg_catalog./ (procedure = cash_div_int8, leftarg = money, rightarg = bigint);

comment on operator pg_catalog./(money, bigint)
is 'divide';

create operator pg_catalog.* (procedure = int8_mul_cash, leftarg = bigint, rightarg = money);

comment on operator pg_catalog.*(bigint, money)
is 'multiply';

create operator pg_catalog.= (procedure = macaddr8_eq, leftarg = macaddr8, rightarg = macaddr8);

comment on operator pg_catalog.=(macaddr8, macaddr8)
is 'equal';

create operator pg_catalog.<> (procedure = macaddr8_ne, leftarg = macaddr8, rightarg = macaddr8);

comment on operator pg_catalog.<>(macaddr8, macaddr8)
is 'not equal';

create operator pg_catalog.< (procedure = macaddr8_lt, leftarg = macaddr8, rightarg = macaddr8);

comment on operator pg_catalog.<(macaddr8, macaddr8)
is 'less than';

create operator pg_catalog.<= (procedure = macaddr8_le, leftarg = macaddr8, rightarg = macaddr8);

comment on operator pg_catalog.<=(macaddr8, macaddr8)
is 'less than or equal';

create operator pg_catalog.> (procedure = macaddr8_gt, leftarg = macaddr8, rightarg = macaddr8);

comment on operator pg_catalog.>(macaddr8, macaddr8)
is 'greater than';

create operator pg_catalog.>= (procedure = macaddr8_ge, leftarg = macaddr8, rightarg = macaddr8);

comment on operator pg_catalog.>=(macaddr8, macaddr8)
is 'greater than or equal';

create operator pg_catalog.~ (procedure = macaddr8_not, rightarg = macaddr8);

comment on operator pg_catalog.~(none, macaddr8)
is 'bitwise not';

create operator pg_catalog.& (procedure = macaddr8_and, leftarg = macaddr8, rightarg = macaddr8);

comment on operator pg_catalog.&(macaddr8, macaddr8)
is 'bitwise and';

create operator pg_catalog.| (procedure = macaddr8_or, leftarg = macaddr8, rightarg = macaddr8);

comment on operator pg_catalog.|(macaddr8, macaddr8)
is 'bitwise or';

create operator pg_catalog.- (procedure = "pg_catalog.jsonb_delete", leftarg = jsonb, rightarg = text []);

comment on operator pg_catalog.-(jsonb, text [])
is 'delete object fields';

create operator pg_catalog.->> (procedure = jsonb_object_field_text, leftarg = jsonb, rightarg = text);

comment on operator pg_catalog.->>(jsonb, text)
is 'get jsonb object field as text';

create operator pg_catalog.->> (procedure = jsonb_array_element_text, leftarg = jsonb, rightarg = integer);

comment on operator pg_catalog.->>(jsonb, integer)
is 'get jsonb array element as text';

create operator pg_catalog.= (procedure = enum_eq, leftarg = anyenum, rightarg = anyenum);

comment on operator pg_catalog.=(anyenum, anyenum)
is 'equal';

create operator pg_catalog.<> (procedure = enum_ne, leftarg = anyenum, rightarg = anyenum);

comment on operator pg_catalog.<>(anyenum, anyenum)
is 'not equal';

create operator pg_catalog.< (procedure = enum_lt, leftarg = anyenum, rightarg = anyenum);

comment on operator pg_catalog.<(anyenum, anyenum)
is 'less than';

create operator pg_catalog.> (procedure = enum_gt, leftarg = anyenum, rightarg = anyenum);

comment on operator pg_catalog.>(anyenum, anyenum)
is 'greater than';

create operator pg_catalog.<= (procedure = enum_le, leftarg = anyenum, rightarg = anyenum);

comment on operator pg_catalog.<=(anyenum, anyenum)
is 'less than or equal';

create operator pg_catalog.>= (procedure = enum_ge, leftarg = anyenum, rightarg = anyenum);

comment on operator pg_catalog.>=(anyenum, anyenum)
is 'greater than or equal';

create operator pg_catalog.&& (procedure = network_overlap, leftarg = inet, rightarg = inet);

comment on operator pg_catalog.&&(inet, inet)
is 'overlaps (is subnet or supernet)';

create operator pg_catalog.< (procedure = tsvector_lt, leftarg = tsvector, rightarg = tsvector);

comment on operator pg_catalog.<(tsvector, tsvector)
is 'less than';

create operator pg_catalog.<= (procedure = tsvector_le, leftarg = tsvector, rightarg = tsvector);

comment on operator pg_catalog.<=(tsvector, tsvector)
is 'less than or equal';

create operator pg_catalog.= (procedure = tsvector_eq, leftarg = tsvector, rightarg = tsvector);

comment on operator pg_catalog.=(tsvector, tsvector)
is 'equal';

create operator pg_catalog.<> (procedure = tsvector_ne, leftarg = tsvector, rightarg = tsvector);

comment on operator pg_catalog.<>(tsvector, tsvector)
is 'not equal';

create operator pg_catalog.>= (procedure = tsvector_ge, leftarg = tsvector, rightarg = tsvector);

comment on operator pg_catalog.>=(tsvector, tsvector)
is 'greater than or equal';

create operator pg_catalog.> (procedure = tsvector_gt, leftarg = tsvector, rightarg = tsvector);

comment on operator pg_catalog.>(tsvector, tsvector)
is 'greater than';

create operator pg_catalog.|| (procedure = tsvector_concat, leftarg = tsvector, rightarg = tsvector);

comment on operator pg_catalog.||(tsvector, tsvector)
is 'concatenate';

create operator pg_catalog.@@ (procedure = ts_match_vq, leftarg = tsvector, rightarg = tsquery);

comment on operator pg_catalog.@@(tsvector, tsquery)
is 'text search match';

create operator pg_catalog.@@ (procedure = ts_match_qv, leftarg = tsquery, rightarg = tsvector);

comment on operator pg_catalog.@@(tsquery, tsvector)
is 'text search match';

create operator pg_catalog.@@@ (procedure = ts_match_vq, leftarg = tsvector, rightarg = tsquery);

comment on operator pg_catalog.@@@(tsvector, tsquery)
is 'deprecated, use @@ instead';

create operator pg_catalog.@@@ (procedure = ts_match_qv, leftarg = tsquery, rightarg = tsvector);

comment on operator pg_catalog.@@@(tsquery, tsvector)
is 'deprecated, use @@ instead';

create operator pg_catalog.< (procedure = tsquery_lt, leftarg = tsquery, rightarg = tsquery);

comment on operator pg_catalog.<(tsquery, tsquery)
is 'less than';

create operator pg_catalog.<= (procedure = tsquery_le, leftarg = tsquery, rightarg = tsquery);

comment on operator pg_catalog.<=(tsquery, tsquery)
is 'less than or equal';

create operator pg_catalog.= (procedure = tsquery_eq, leftarg = tsquery, rightarg = tsquery);

comment on operator pg_catalog.=(tsquery, tsquery)
is 'equal';

create operator pg_catalog.<> (procedure = tsquery_ne, leftarg = tsquery, rightarg = tsquery);

comment on operator pg_catalog.<>(tsquery, tsquery)
is 'not equal';

create operator pg_catalog.>= (procedure = tsquery_ge, leftarg = tsquery, rightarg = tsquery);

comment on operator pg_catalog.>=(tsquery, tsquery)
is 'greater than or equal';

create operator pg_catalog.> (procedure = tsquery_gt, leftarg = tsquery, rightarg = tsquery);

comment on operator pg_catalog.>(tsquery, tsquery)
is 'greater than';

create operator pg_catalog.&& (procedure = tsquery_and, leftarg = tsquery, rightarg = tsquery);

comment on operator pg_catalog.&&(tsquery, tsquery)
is 'AND-concatenate';

create operator pg_catalog.|| (procedure = tsquery_or, leftarg = tsquery, rightarg = tsquery);

comment on operator pg_catalog.||(tsquery, tsquery)
is 'OR-concatenate';

create operator pg_catalog.!! (procedure = tsquery_not, rightarg = tsquery);

comment on operator pg_catalog.!!(none, tsquery)
is 'NOT tsquery';

create operator pg_catalog.@> (procedure = tsq_mcontains, leftarg = tsquery, rightarg = tsquery);

comment on operator pg_catalog.@>(tsquery, tsquery)
is 'contains';

create operator pg_catalog.<@ (procedure = tsq_mcontained, leftarg = tsquery, rightarg = tsquery);

comment on operator pg_catalog.<@(tsquery, tsquery)
is 'is contained by';

create operator pg_catalog.@@ (procedure = ts_match_tt, leftarg = text, rightarg = text);

comment on operator pg_catalog.@@(text, text)
is 'text search match';

create operator pg_catalog.@@ (procedure = ts_match_tq, leftarg = text, rightarg = tsquery);

comment on operator pg_catalog.@@(text, tsquery)
is 'text search match';

create operator pg_catalog./ (procedure = cash_div_cash, leftarg = money, rightarg = money);

comment on operator pg_catalog./(money, money)
is 'divide';

create operator pg_catalog.^@ (procedure = starts_with, leftarg = text, rightarg = text);

comment on operator pg_catalog.^@(text, text)
is 'starts with';

create operator pg_catalog.= (procedure = range_eq, leftarg = anyrange, rightarg = anyrange);

comment on operator pg_catalog.=(anyrange, anyrange)
is 'equal';

create operator pg_catalog.<> (procedure = range_ne, leftarg = anyrange, rightarg = anyrange);

comment on operator pg_catalog.<>(anyrange, anyrange)
is 'not equal';

create operator pg_catalog.< (procedure = range_lt, leftarg = anyrange, rightarg = anyrange);

comment on operator pg_catalog.<(anyrange, anyrange)
is 'less than';

create operator pg_catalog.<= (procedure = range_le, leftarg = anyrange, rightarg = anyrange);

comment on operator pg_catalog.<=(anyrange, anyrange)
is 'less than or equal';

create operator pg_catalog.>= (procedure = range_ge, leftarg = anyrange, rightarg = anyrange);

comment on operator pg_catalog.>=(anyrange, anyrange)
is 'greater than or equal';

create operator pg_catalog.> (procedure = range_gt, leftarg = anyrange, rightarg = anyrange);

comment on operator pg_catalog.>(anyrange, anyrange)
is 'greater than';

create operator pg_catalog.&& (procedure = range_overlaps, leftarg = anyrange, rightarg = anyrange);

comment on operator pg_catalog.&&(anyrange, anyrange)
is 'overlaps';

create operator pg_catalog.@> (procedure = range_contains_elem, leftarg = anyrange, rightarg = anyelement);

comment on operator pg_catalog.@>(anyrange, anyelement)
is 'contains';

create operator pg_catalog.@> (procedure = range_contains, leftarg = anyrange, rightarg = anyrange);

comment on operator pg_catalog.@>(anyrange, anyrange)
is 'contains';

create operator pg_catalog.<@ (procedure = elem_contained_by_range, leftarg = anyelement, rightarg = anyrange);

comment on operator pg_catalog.<@(anyelement, anyrange)
is 'is contained by';

create operator pg_catalog.<@ (procedure = range_contained_by, leftarg = anyrange, rightarg = anyrange);

comment on operator pg_catalog.<@(anyrange, anyrange)
is 'is contained by';

create operator pg_catalog.<< (procedure = range_before, leftarg = anyrange, rightarg = anyrange);

comment on operator pg_catalog.<<(anyrange, anyrange)
is 'is left of';

create operator pg_catalog.>> (procedure = range_after, leftarg = anyrange, rightarg = anyrange);

comment on operator pg_catalog.>>(anyrange, anyrange)
is 'is right of';

create operator pg_catalog.&< (procedure = range_overleft, leftarg = anyrange, rightarg = anyrange);

comment on operator pg_catalog.&<(anyrange, anyrange)
is 'overlaps or is left of';

create operator pg_catalog.&> (procedure = range_overright, leftarg = anyrange, rightarg = anyrange);

comment on operator pg_catalog.&>(anyrange, anyrange)
is 'overlaps or is right of';

create operator pg_catalog.-|- (procedure = range_adjacent, leftarg = anyrange, rightarg = anyrange);

comment on operator pg_catalog.-|-(anyrange, anyrange)
is 'is adjacent to';

create operator pg_catalog.+ (procedure = range_union, leftarg = anyrange, rightarg = anyrange);

comment on operator pg_catalog.+(anyrange, anyrange)
is 'range union';

create operator pg_catalog.- (procedure = range_minus, leftarg = anyrange, rightarg = anyrange);

comment on operator pg_catalog.-(anyrange, anyrange)
is 'range difference';

create operator pg_catalog.* (procedure = range_intersect, leftarg = anyrange, rightarg = anyrange);

comment on operator pg_catalog.*(anyrange, anyrange)
is 'range intersection';

create operator pg_catalog.-> (procedure = json_object_field, leftarg = json, rightarg = text);

comment on operator pg_catalog.->(json, text)
is 'get json object field';

create operator pg_catalog.->> (procedure = json_object_field_text, leftarg = json, rightarg = text);

comment on operator pg_catalog.->>(json, text)
is 'get json object field as text';

create operator pg_catalog.-> (procedure = json_array_element, leftarg = json, rightarg = integer);

comment on operator pg_catalog.->(json, integer)
is 'get json array element';

create operator pg_catalog.->> (procedure = json_array_element_text, leftarg = json, rightarg = integer);

comment on operator pg_catalog.->>(json, integer)
is 'get json array element as text';

create operator pg_catalog.#> (procedure = json_extract_path, leftarg = json, rightarg = text []);

comment on operator pg_catalog.#>(json, text [])
is 'get value from json with path elements';

create operator pg_catalog.#>> (procedure = json_extract_path_text, leftarg = json, rightarg = text []);

comment on operator pg_catalog.#>>(json, text [])
is 'get value from json as text with path elements';

create operator pg_catalog.<-> (procedure = "pg_catalog.tsquery_phrase", leftarg = tsquery, rightarg = tsquery);

comment on operator pg_catalog.<->(tsquery, tsquery)
is 'phrase-concatenate';

comment on collation pg_catalog."default"
is 'database''s default collation';

create collation if not exists pg_catalog."C" (
  locale = 'C'
);

comment on collation pg_catalog."C"
is 'standard C collation';

create collation if not exists pg_catalog."POSIX" (
  locale = 'POSIX'
);

comment on collation pg_catalog."POSIX"
is 'standard POSIX collation';

create collation if not exists pg_catalog.ucs_basic (
  locale = 'C'
);

create collation if not exists pg_catalog."af-x-icu" (
  locale = 'af'
);

comment on collation pg_catalog."af-x-icu"
is 'Afrikaans';

create collation if not exists pg_catalog."af-NA-x-icu" (
  locale = 'af_NA'
);

comment on collation pg_catalog."af-NA-x-icu"
is 'Afrikaans (Namibia)';

create collation if not exists pg_catalog."af-ZA-x-icu" (
  locale = 'af_ZA'
);

comment on collation pg_catalog."af-ZA-x-icu"
is 'Afrikaans (South Africa)';

create collation if not exists pg_catalog."agq-x-icu" (
  locale = 'agq'
);

comment on collation pg_catalog."agq-x-icu"
is 'Aghem';

create collation if not exists pg_catalog."agq-CM-x-icu" (
  locale = 'agq_CM'
);

comment on collation pg_catalog."agq-CM-x-icu"
is 'Aghem (Cameroon)';

create collation if not exists pg_catalog."ak-x-icu" (
  locale = 'ak'
);

comment on collation pg_catalog."ak-x-icu"
is 'Akan';

create collation if not exists pg_catalog."ak-GH-x-icu" (
  locale = 'ak_GH'
);

comment on collation pg_catalog."ak-GH-x-icu"
is 'Akan (Ghana)';

create collation if not exists pg_catalog."am-x-icu" (
  locale = 'am'
);

comment on collation pg_catalog."am-x-icu"
is 'Amharic';

create collation if not exists pg_catalog."am-ET-x-icu" (
  locale = 'am_ET'
);

comment on collation pg_catalog."am-ET-x-icu"
is 'Amharic (Ethiopia)';

create collation if not exists pg_catalog."ar-x-icu" (
  locale = 'ar'
);

comment on collation pg_catalog."ar-x-icu"
is 'Arabic';

create collation if not exists pg_catalog."ar-001-x-icu" (
  locale = 'ar_001'
);

comment on collation pg_catalog."ar-001-x-icu"
is 'Arabic (World)';

create collation if not exists pg_catalog."ar-AE-x-icu" (
  locale = 'ar_AE'
);

comment on collation pg_catalog."ar-AE-x-icu"
is 'Arabic (United Arab Emirates)';

create collation if not exists pg_catalog."ar-BH-x-icu" (
  locale = 'ar_BH'
);

comment on collation pg_catalog."ar-BH-x-icu"
is 'Arabic (Bahrain)';

create collation if not exists pg_catalog."ar-DJ-x-icu" (
  locale = 'ar_DJ'
);

comment on collation pg_catalog."ar-DJ-x-icu"
is 'Arabic (Djibouti)';

create collation if not exists pg_catalog."ar-DZ-x-icu" (
  locale = 'ar_DZ'
);

comment on collation pg_catalog."ar-DZ-x-icu"
is 'Arabic (Algeria)';

create collation if not exists pg_catalog."ar-EG-x-icu" (
  locale = 'ar_EG'
);

comment on collation pg_catalog."ar-EG-x-icu"
is 'Arabic (Egypt)';

create collation if not exists pg_catalog."ar-EH-x-icu" (
  locale = 'ar_EH'
);

comment on collation pg_catalog."ar-EH-x-icu"
is 'Arabic (Western Sahara)';

create collation if not exists pg_catalog."ar-ER-x-icu" (
  locale = 'ar_ER'
);

comment on collation pg_catalog."ar-ER-x-icu"
is 'Arabic (Eritrea)';

create collation if not exists pg_catalog."ar-IL-x-icu" (
  locale = 'ar_IL'
);

comment on collation pg_catalog."ar-IL-x-icu"
is 'Arabic (Israel)';

create collation if not exists pg_catalog."ar-IQ-x-icu" (
  locale = 'ar_IQ'
);

comment on collation pg_catalog."ar-IQ-x-icu"
is 'Arabic (Iraq)';

create collation if not exists pg_catalog."ar-JO-x-icu" (
  locale = 'ar_JO'
);

comment on collation pg_catalog."ar-JO-x-icu"
is 'Arabic (Jordan)';

create collation if not exists pg_catalog."ar-KM-x-icu" (
  locale = 'ar_KM'
);

comment on collation pg_catalog."ar-KM-x-icu"
is 'Arabic (Comoros)';

create collation if not exists pg_catalog."ar-KW-x-icu" (
  locale = 'ar_KW'
);

comment on collation pg_catalog."ar-KW-x-icu"
is 'Arabic (Kuwait)';

create collation if not exists pg_catalog."ar-LB-x-icu" (
  locale = 'ar_LB'
);

comment on collation pg_catalog."ar-LB-x-icu"
is 'Arabic (Lebanon)';

create collation if not exists pg_catalog."ar-LY-x-icu" (
  locale = 'ar_LY'
);

comment on collation pg_catalog."ar-LY-x-icu"
is 'Arabic (Libya)';

create collation if not exists pg_catalog."ar-MA-x-icu" (
  locale = 'ar_MA'
);

comment on collation pg_catalog."ar-MA-x-icu"
is 'Arabic (Morocco)';

create collation if not exists pg_catalog."ar-MR-x-icu" (
  locale = 'ar_MR'
);

comment on collation pg_catalog."ar-MR-x-icu"
is 'Arabic (Mauritania)';

create collation if not exists pg_catalog."ar-OM-x-icu" (
  locale = 'ar_OM'
);

comment on collation pg_catalog."ar-OM-x-icu"
is 'Arabic (Oman)';

create collation if not exists pg_catalog."ar-PS-x-icu" (
  locale = 'ar_PS'
);

comment on collation pg_catalog."ar-PS-x-icu"
is 'Arabic (Palestinian Territories)';

create collation if not exists pg_catalog."ar-QA-x-icu" (
  locale = 'ar_QA'
);

comment on collation pg_catalog."ar-QA-x-icu"
is 'Arabic (Qatar)';

create collation if not exists pg_catalog."ar-SA-x-icu" (
  locale = 'ar_SA'
);

comment on collation pg_catalog."ar-SA-x-icu"
is 'Arabic (Saudi Arabia)';

create collation if not exists pg_catalog."ar-SD-x-icu" (
  locale = 'ar_SD'
);

comment on collation pg_catalog."ar-SD-x-icu"
is 'Arabic (Sudan)';

create collation if not exists pg_catalog."ar-SO-x-icu" (
  locale = 'ar_SO'
);

comment on collation pg_catalog."ar-SO-x-icu"
is 'Arabic (Somalia)';

create collation if not exists pg_catalog."ar-SS-x-icu" (
  locale = 'ar_SS'
);

comment on collation pg_catalog."ar-SS-x-icu"
is 'Arabic (South Sudan)';

create collation if not exists pg_catalog."ar-SY-x-icu" (
  locale = 'ar_SY'
);

comment on collation pg_catalog."ar-SY-x-icu"
is 'Arabic (Syria)';

create collation if not exists pg_catalog."ar-TD-x-icu" (
  locale = 'ar_TD'
);

comment on collation pg_catalog."ar-TD-x-icu"
is 'Arabic (Chad)';

create collation if not exists pg_catalog."ar-TN-x-icu" (
  locale = 'ar_TN'
);

comment on collation pg_catalog."ar-TN-x-icu"
is 'Arabic (Tunisia)';

create collation if not exists pg_catalog."ar-YE-x-icu" (
  locale = 'ar_YE'
);

comment on collation pg_catalog."ar-YE-x-icu"
is 'Arabic (Yemen)';

create collation if not exists pg_catalog."as-x-icu" (
  locale = 'as'
);

comment on collation pg_catalog."as-x-icu"
is 'Assamese';

create collation if not exists pg_catalog."as-IN-x-icu" (
  locale = 'as_IN'
);

comment on collation pg_catalog."as-IN-x-icu"
is 'Assamese (India)';

create collation if not exists pg_catalog."asa-x-icu" (
  locale = 'asa'
);

comment on collation pg_catalog."asa-x-icu"
is 'Asu';

create collation if not exists pg_catalog."asa-TZ-x-icu" (
  locale = 'asa_TZ'
);

comment on collation pg_catalog."asa-TZ-x-icu"
is 'Asu (Tanzania)';

create collation if not exists pg_catalog."az-x-icu" (
  locale = 'az'
);

comment on collation pg_catalog."az-x-icu"
is 'Azerbaijani';

create collation if not exists pg_catalog."az-Cyrl-x-icu" (
  locale = 'az_Cyrl'
);

comment on collation pg_catalog."az-Cyrl-x-icu"
is 'Azerbaijani (Cyrillic)';

create collation if not exists pg_catalog."az-Cyrl-AZ-x-icu" (
  locale = 'az_Cyrl_AZ'
);

comment on collation pg_catalog."az-Cyrl-AZ-x-icu"
is 'Azerbaijani (Cyrillic, Azerbaijan)';

create collation if not exists pg_catalog."az-Latn-x-icu" (
  locale = 'az_Latn'
);

comment on collation pg_catalog."az-Latn-x-icu"
is 'Azerbaijani (Latin)';

create collation if not exists pg_catalog."az-Latn-AZ-x-icu" (
  locale = 'az_Latn_AZ'
);

comment on collation pg_catalog."az-Latn-AZ-x-icu"
is 'Azerbaijani (Latin, Azerbaijan)';

create collation if not exists pg_catalog."bas-x-icu" (
  locale = 'bas'
);

comment on collation pg_catalog."bas-x-icu"
is 'Basaa';

create collation if not exists pg_catalog."bas-CM-x-icu" (
  locale = 'bas_CM'
);

comment on collation pg_catalog."bas-CM-x-icu"
is 'Basaa (Cameroon)';

create collation if not exists pg_catalog."be-x-icu" (
  locale = 'be'
);

comment on collation pg_catalog."be-x-icu"
is 'Belarusian';

create collation if not exists pg_catalog."be-BY-x-icu" (
  locale = 'be_BY'
);

comment on collation pg_catalog."be-BY-x-icu"
is 'Belarusian (Belarus)';

create collation if not exists pg_catalog."bem-x-icu" (
  locale = 'bem'
);

comment on collation pg_catalog."bem-x-icu"
is 'Bemba';

create collation if not exists pg_catalog."bem-ZM-x-icu" (
  locale = 'bem_ZM'
);

comment on collation pg_catalog."bem-ZM-x-icu"
is 'Bemba (Zambia)';

create collation if not exists pg_catalog."bez-x-icu" (
  locale = 'bez'
);

comment on collation pg_catalog."bez-x-icu"
is 'Bena';

create collation if not exists pg_catalog."bez-TZ-x-icu" (
  locale = 'bez_TZ'
);

comment on collation pg_catalog."bez-TZ-x-icu"
is 'Bena (Tanzania)';

create collation if not exists pg_catalog."bg-x-icu" (
  locale = 'bg'
);

comment on collation pg_catalog."bg-x-icu"
is 'Bulgarian';

create collation if not exists pg_catalog."bg-BG-x-icu" (
  locale = 'bg_BG'
);

comment on collation pg_catalog."bg-BG-x-icu"
is 'Bulgarian (Bulgaria)';

create collation if not exists pg_catalog."bm-x-icu" (
  locale = 'bm'
);

comment on collation pg_catalog."bm-x-icu"
is 'Bambara';

create collation if not exists pg_catalog."bm-ML-x-icu" (
  locale = 'bm_ML'
);

comment on collation pg_catalog."bm-ML-x-icu"
is 'Bambara (Mali)';

create collation if not exists pg_catalog."bn-x-icu" (
  locale = 'bn'
);

comment on collation pg_catalog."bn-x-icu"
is 'Bengali';

create collation if not exists pg_catalog."bn-BD-x-icu" (
  locale = 'bn_BD'
);

comment on collation pg_catalog."bn-BD-x-icu"
is 'Bengali (Bangladesh)';

create collation if not exists pg_catalog."bn-IN-x-icu" (
  locale = 'bn_IN'
);

comment on collation pg_catalog."bn-IN-x-icu"
is 'Bengali (India)';

create collation if not exists pg_catalog."bo-x-icu" (
  locale = 'bo'
);

comment on collation pg_catalog."bo-x-icu"
is 'Tibetan';

create collation if not exists pg_catalog."bo-CN-x-icu" (
  locale = 'bo_CN'
);

comment on collation pg_catalog."bo-CN-x-icu"
is 'Tibetan (China)';

create collation if not exists pg_catalog."bo-IN-x-icu" (
  locale = 'bo_IN'
);

comment on collation pg_catalog."bo-IN-x-icu"
is 'Tibetan (India)';

create collation if not exists pg_catalog."br-x-icu" (
  locale = 'br'
);

comment on collation pg_catalog."br-x-icu"
is 'Breton';

create collation if not exists pg_catalog."br-FR-x-icu" (
  locale = 'br_FR'
);

comment on collation pg_catalog."br-FR-x-icu"
is 'Breton (France)';

create collation if not exists pg_catalog."brx-x-icu" (
  locale = 'brx'
);

comment on collation pg_catalog."brx-x-icu"
is 'Bodo';

create collation if not exists pg_catalog."brx-IN-x-icu" (
  locale = 'brx_IN'
);

comment on collation pg_catalog."brx-IN-x-icu"
is 'Bodo (India)';

create collation if not exists pg_catalog."bs-x-icu" (
  locale = 'bs'
);

comment on collation pg_catalog."bs-x-icu"
is 'Bosnian';

create collation if not exists pg_catalog."bs-Cyrl-x-icu" (
  locale = 'bs_Cyrl'
);

comment on collation pg_catalog."bs-Cyrl-x-icu"
is 'Bosnian (Cyrillic)';

create collation if not exists pg_catalog."bs-Cyrl-BA-x-icu" (
  locale = 'bs_Cyrl_BA'
);

comment on collation pg_catalog."bs-Cyrl-BA-x-icu"
is 'Bosnian (Cyrillic, Bosnia and Herzegovina)';

create collation if not exists pg_catalog."bs-Latn-x-icu" (
  locale = 'bs_Latn'
);

comment on collation pg_catalog."bs-Latn-x-icu"
is 'Bosnian (Latin)';

create collation if not exists pg_catalog."bs-Latn-BA-x-icu" (
  locale = 'bs_Latn_BA'
);

comment on collation pg_catalog."bs-Latn-BA-x-icu"
is 'Bosnian (Latin, Bosnia and Herzegovina)';

create collation if not exists pg_catalog."ca-x-icu" (
  locale = 'ca'
);

comment on collation pg_catalog."ca-x-icu"
is 'Catalan';

create collation if not exists pg_catalog."ca-AD-x-icu" (
  locale = 'ca_AD'
);

comment on collation pg_catalog."ca-AD-x-icu"
is 'Catalan (Andorra)';

create collation if not exists pg_catalog."ca-ES-x-icu" (
  locale = 'ca_ES'
);

comment on collation pg_catalog."ca-ES-x-icu"
is 'Catalan (Spain)';

create collation if not exists pg_catalog."ca-FR-x-icu" (
  locale = 'ca_FR'
);

comment on collation pg_catalog."ca-FR-x-icu"
is 'Catalan (France)';

create collation if not exists pg_catalog."ca-IT-x-icu" (
  locale = 'ca_IT'
);

comment on collation pg_catalog."ca-IT-x-icu"
is 'Catalan (Italy)';

create collation if not exists pg_catalog."cgg-x-icu" (
  locale = 'cgg'
);

comment on collation pg_catalog."cgg-x-icu"
is 'Chiga';

create collation if not exists pg_catalog."cgg-UG-x-icu" (
  locale = 'cgg_UG'
);

comment on collation pg_catalog."cgg-UG-x-icu"
is 'Chiga (Uganda)';

create collation if not exists pg_catalog."chr-x-icu" (
  locale = 'chr'
);

comment on collation pg_catalog."chr-x-icu"
is 'Cherokee';

create collation if not exists pg_catalog."chr-US-x-icu" (
  locale = 'chr_US'
);

comment on collation pg_catalog."chr-US-x-icu"
is 'Cherokee (United States)';

create collation if not exists pg_catalog."cs-x-icu" (
  locale = 'cs'
);

comment on collation pg_catalog."cs-x-icu"
is 'Czech';

create collation if not exists pg_catalog."cs-CZ-x-icu" (
  locale = 'cs_CZ'
);

comment on collation pg_catalog."cs-CZ-x-icu"
is 'Czech (Czech Republic)';

create collation if not exists pg_catalog."cy-x-icu" (
  locale = 'cy'
);

comment on collation pg_catalog."cy-x-icu"
is 'Welsh';

create collation if not exists pg_catalog."cy-GB-x-icu" (
  locale = 'cy_GB'
);

comment on collation pg_catalog."cy-GB-x-icu"
is 'Welsh (United Kingdom)';

create collation if not exists pg_catalog."da-x-icu" (
  locale = 'da'
);

comment on collation pg_catalog."da-x-icu"
is 'Danish';

create collation if not exists pg_catalog."da-DK-x-icu" (
  locale = 'da_DK'
);

comment on collation pg_catalog."da-DK-x-icu"
is 'Danish (Denmark)';

create collation if not exists pg_catalog."da-GL-x-icu" (
  locale = 'da_GL'
);

comment on collation pg_catalog."da-GL-x-icu"
is 'Danish (Greenland)';

create collation if not exists pg_catalog."dav-x-icu" (
  locale = 'dav'
);

comment on collation pg_catalog."dav-x-icu"
is 'Taita';

create collation if not exists pg_catalog."dav-KE-x-icu" (
  locale = 'dav_KE'
);

comment on collation pg_catalog."dav-KE-x-icu"
is 'Taita (Kenya)';

create collation if not exists pg_catalog."de-x-icu" (
  locale = 'de'
);

comment on collation pg_catalog."de-x-icu"
is 'German';

create collation if not exists pg_catalog."de-AT-x-icu" (
  locale = 'de_AT'
);

comment on collation pg_catalog."de-AT-x-icu"
is 'German (Austria)';

create collation if not exists pg_catalog."de-BE-x-icu" (
  locale = 'de_BE'
);

comment on collation pg_catalog."de-BE-x-icu"
is 'German (Belgium)';

create collation if not exists pg_catalog."de-CH-x-icu" (
  locale = 'de_CH'
);

comment on collation pg_catalog."de-CH-x-icu"
is 'German (Switzerland)';

create collation if not exists pg_catalog."de-DE-x-icu" (
  locale = 'de_DE'
);

comment on collation pg_catalog."de-DE-x-icu"
is 'German (Germany)';

create collation if not exists pg_catalog."de-LI-x-icu" (
  locale = 'de_LI'
);

comment on collation pg_catalog."de-LI-x-icu"
is 'German (Liechtenstein)';

create collation if not exists pg_catalog."de-LU-x-icu" (
  locale = 'de_LU'
);

comment on collation pg_catalog."de-LU-x-icu"
is 'German (Luxembourg)';

create collation if not exists pg_catalog."dje-x-icu" (
  locale = 'dje'
);

comment on collation pg_catalog."dje-x-icu"
is 'Zarma';

create collation if not exists pg_catalog."dje-NE-x-icu" (
  locale = 'dje_NE'
);

comment on collation pg_catalog."dje-NE-x-icu"
is 'Zarma (Niger)';

create collation if not exists pg_catalog."dua-x-icu" (
  locale = 'dua'
);

comment on collation pg_catalog."dua-x-icu"
is 'Duala';

create collation if not exists pg_catalog."dua-CM-x-icu" (
  locale = 'dua_CM'
);

comment on collation pg_catalog."dua-CM-x-icu"
is 'Duala (Cameroon)';

create collation if not exists pg_catalog."dyo-x-icu" (
  locale = 'dyo'
);

comment on collation pg_catalog."dyo-x-icu"
is 'Jola-Fonyi';

create collation if not exists pg_catalog."dyo-SN-x-icu" (
  locale = 'dyo_SN'
);

comment on collation pg_catalog."dyo-SN-x-icu"
is 'Jola-Fonyi (Senegal)';

create collation if not exists pg_catalog."dz-x-icu" (
  locale = 'dz'
);

comment on collation pg_catalog."dz-x-icu"
is 'Dzongkha';

create collation if not exists pg_catalog."dz-BT-x-icu" (
  locale = 'dz_BT'
);

comment on collation pg_catalog."dz-BT-x-icu"
is 'Dzongkha (Bhutan)';

create collation if not exists pg_catalog."ebu-x-icu" (
  locale = 'ebu'
);

comment on collation pg_catalog."ebu-x-icu"
is 'Embu';

create collation if not exists pg_catalog."ebu-KE-x-icu" (
  locale = 'ebu_KE'
);

comment on collation pg_catalog."ebu-KE-x-icu"
is 'Embu (Kenya)';

create collation if not exists pg_catalog."ee-x-icu" (
  locale = 'ee'
);

comment on collation pg_catalog."ee-x-icu"
is 'Ewe';

create collation if not exists pg_catalog."ee-GH-x-icu" (
  locale = 'ee_GH'
);

comment on collation pg_catalog."ee-GH-x-icu"
is 'Ewe (Ghana)';

create collation if not exists pg_catalog."ee-TG-x-icu" (
  locale = 'ee_TG'
);

comment on collation pg_catalog."ee-TG-x-icu"
is 'Ewe (Togo)';

create collation if not exists pg_catalog."el-x-icu" (
  locale = 'el'
);

comment on collation pg_catalog."el-x-icu"
is 'Greek';

create collation if not exists pg_catalog."el-CY-x-icu" (
  locale = 'el_CY'
);

comment on collation pg_catalog."el-CY-x-icu"
is 'Greek (Cyprus)';

create collation if not exists pg_catalog."el-GR-x-icu" (
  locale = 'el_GR'
);

comment on collation pg_catalog."el-GR-x-icu"
is 'Greek (Greece)';

create collation if not exists pg_catalog."en-x-icu" (
  locale = 'en'
);

comment on collation pg_catalog."en-x-icu"
is 'English';

create collation if not exists pg_catalog."en-001-x-icu" (
  locale = 'en_001'
);

comment on collation pg_catalog."en-001-x-icu"
is 'English (World)';

create collation if not exists pg_catalog."en-150-x-icu" (
  locale = 'en_150'
);

comment on collation pg_catalog."en-150-x-icu"
is 'English (Europe)';

create collation if not exists pg_catalog."en-AG-x-icu" (
  locale = 'en_AG'
);

comment on collation pg_catalog."en-AG-x-icu"
is 'English (Antigua and Barbuda)';

create collation if not exists pg_catalog."en-AI-x-icu" (
  locale = 'en_AI'
);

comment on collation pg_catalog."en-AI-x-icu"
is 'English (Anguilla)';

create collation if not exists pg_catalog."en-AS-x-icu" (
  locale = 'en_AS'
);

comment on collation pg_catalog."en-AS-x-icu"
is 'English (American Samoa)';

create collation if not exists pg_catalog."en-AU-x-icu" (
  locale = 'en_AU'
);

comment on collation pg_catalog."en-AU-x-icu"
is 'English (Australia)';

create collation if not exists pg_catalog."en-BB-x-icu" (
  locale = 'en_BB'
);

comment on collation pg_catalog."en-BB-x-icu"
is 'English (Barbados)';

create collation if not exists pg_catalog."en-BE-x-icu" (
  locale = 'en_BE'
);

comment on collation pg_catalog."en-BE-x-icu"
is 'English (Belgium)';

create collation if not exists pg_catalog."en-BM-x-icu" (
  locale = 'en_BM'
);

comment on collation pg_catalog."en-BM-x-icu"
is 'English (Bermuda)';

create collation if not exists pg_catalog."en-BS-x-icu" (
  locale = 'en_BS'
);

comment on collation pg_catalog."en-BS-x-icu"
is 'English (Bahamas)';

create collation if not exists pg_catalog."en-BW-x-icu" (
  locale = 'en_BW'
);

comment on collation pg_catalog."en-BW-x-icu"
is 'English (Botswana)';

create collation if not exists pg_catalog."en-BZ-x-icu" (
  locale = 'en_BZ'
);

comment on collation pg_catalog."en-BZ-x-icu"
is 'English (Belize)';

create collation if not exists pg_catalog."en-CA-x-icu" (
  locale = 'en_CA'
);

comment on collation pg_catalog."en-CA-x-icu"
is 'English (Canada)';

create collation if not exists pg_catalog."en-CC-x-icu" (
  locale = 'en_CC'
);

comment on collation pg_catalog."en-CC-x-icu"
is 'English (Cocos [Keeling] Islands)';

create collation if not exists pg_catalog."en-CK-x-icu" (
  locale = 'en_CK'
);

comment on collation pg_catalog."en-CK-x-icu"
is 'English (Cook Islands)';

create collation if not exists pg_catalog."en-CM-x-icu" (
  locale = 'en_CM'
);

comment on collation pg_catalog."en-CM-x-icu"
is 'English (Cameroon)';

create collation if not exists pg_catalog."en-CX-x-icu" (
  locale = 'en_CX'
);

comment on collation pg_catalog."en-CX-x-icu"
is 'English (Christmas Island)';

create collation if not exists pg_catalog."en-DG-x-icu" (
  locale = 'en_DG'
);

comment on collation pg_catalog."en-DG-x-icu"
is 'English (Diego Garcia)';

create collation if not exists pg_catalog."en-DM-x-icu" (
  locale = 'en_DM'
);

comment on collation pg_catalog."en-DM-x-icu"
is 'English (Dominica)';

create collation if not exists pg_catalog."en-ER-x-icu" (
  locale = 'en_ER'
);

comment on collation pg_catalog."en-ER-x-icu"
is 'English (Eritrea)';

create collation if not exists pg_catalog."en-FJ-x-icu" (
  locale = 'en_FJ'
);

comment on collation pg_catalog."en-FJ-x-icu"
is 'English (Fiji)';

create collation if not exists pg_catalog."en-FK-x-icu" (
  locale = 'en_FK'
);

comment on collation pg_catalog."en-FK-x-icu"
is 'English (Falkland Islands)';

create collation if not exists pg_catalog."en-FM-x-icu" (
  locale = 'en_FM'
);

comment on collation pg_catalog."en-FM-x-icu"
is 'English (Micronesia)';

create collation if not exists pg_catalog."en-GB-x-icu" (
  locale = 'en_GB'
);

comment on collation pg_catalog."en-GB-x-icu"
is 'English (United Kingdom)';

create collation if not exists pg_catalog."en-GD-x-icu" (
  locale = 'en_GD'
);

comment on collation pg_catalog."en-GD-x-icu"
is 'English (Grenada)';

create collation if not exists pg_catalog."en-GG-x-icu" (
  locale = 'en_GG'
);

comment on collation pg_catalog."en-GG-x-icu"
is 'English (Guernsey)';

create collation if not exists pg_catalog."en-GH-x-icu" (
  locale = 'en_GH'
);

comment on collation pg_catalog."en-GH-x-icu"
is 'English (Ghana)';

create collation if not exists pg_catalog."en-GI-x-icu" (
  locale = 'en_GI'
);

comment on collation pg_catalog."en-GI-x-icu"
is 'English (Gibraltar)';

create collation if not exists pg_catalog."en-GM-x-icu" (
  locale = 'en_GM'
);

comment on collation pg_catalog."en-GM-x-icu"
is 'English (Gambia)';

create collation if not exists pg_catalog."en-GU-x-icu" (
  locale = 'en_GU'
);

comment on collation pg_catalog."en-GU-x-icu"
is 'English (Guam)';

create collation if not exists pg_catalog."en-GY-x-icu" (
  locale = 'en_GY'
);

comment on collation pg_catalog."en-GY-x-icu"
is 'English (Guyana)';

create collation if not exists pg_catalog."en-HK-x-icu" (
  locale = 'en_HK'
);

comment on collation pg_catalog."en-HK-x-icu"
is 'English (Hong Kong SAR China)';

create collation if not exists pg_catalog."en-IE-x-icu" (
  locale = 'en_IE'
);

comment on collation pg_catalog."en-IE-x-icu"
is 'English (Ireland)';

create collation if not exists pg_catalog."en-IM-x-icu" (
  locale = 'en_IM'
);

comment on collation pg_catalog."en-IM-x-icu"
is 'English (Isle of Man)';

create collation if not exists pg_catalog."en-IN-x-icu" (
  locale = 'en_IN'
);

comment on collation pg_catalog."en-IN-x-icu"
is 'English (India)';

create collation if not exists pg_catalog."en-IO-x-icu" (
  locale = 'en_IO'
);

comment on collation pg_catalog."en-IO-x-icu"
is 'English (British Indian Ocean Territory)';

create collation if not exists pg_catalog."en-JE-x-icu" (
  locale = 'en_JE'
);

comment on collation pg_catalog."en-JE-x-icu"
is 'English (Jersey)';

create collation if not exists pg_catalog."en-JM-x-icu" (
  locale = 'en_JM'
);

comment on collation pg_catalog."en-JM-x-icu"
is 'English (Jamaica)';

create collation if not exists pg_catalog."en-KE-x-icu" (
  locale = 'en_KE'
);

comment on collation pg_catalog."en-KE-x-icu"
is 'English (Kenya)';

create collation if not exists pg_catalog."en-KI-x-icu" (
  locale = 'en_KI'
);

comment on collation pg_catalog."en-KI-x-icu"
is 'English (Kiribati)';

create collation if not exists pg_catalog."en-KN-x-icu" (
  locale = 'en_KN'
);

comment on collation pg_catalog."en-KN-x-icu"
is 'English (Saint Kitts and Nevis)';

create collation if not exists pg_catalog."en-KY-x-icu" (
  locale = 'en_KY'
);

comment on collation pg_catalog."en-KY-x-icu"
is 'English (Cayman Islands)';

create collation if not exists pg_catalog."en-LC-x-icu" (
  locale = 'en_LC'
);

comment on collation pg_catalog."en-LC-x-icu"
is 'English (Saint Lucia)';

create collation if not exists pg_catalog."en-LR-x-icu" (
  locale = 'en_LR'
);

comment on collation pg_catalog."en-LR-x-icu"
is 'English (Liberia)';

create collation if not exists pg_catalog."en-LS-x-icu" (
  locale = 'en_LS'
);

comment on collation pg_catalog."en-LS-x-icu"
is 'English (Lesotho)';

create collation if not exists pg_catalog."en-MG-x-icu" (
  locale = 'en_MG'
);

comment on collation pg_catalog."en-MG-x-icu"
is 'English (Madagascar)';

create collation if not exists pg_catalog."en-MH-x-icu" (
  locale = 'en_MH'
);

comment on collation pg_catalog."en-MH-x-icu"
is 'English (Marshall Islands)';

create collation if not exists pg_catalog."en-MO-x-icu" (
  locale = 'en_MO'
);

comment on collation pg_catalog."en-MO-x-icu"
is 'English (Macau SAR China)';

create collation if not exists pg_catalog."en-MP-x-icu" (
  locale = 'en_MP'
);

comment on collation pg_catalog."en-MP-x-icu"
is 'English (Northern Mariana Islands)';

create collation if not exists pg_catalog."en-MS-x-icu" (
  locale = 'en_MS'
);

comment on collation pg_catalog."en-MS-x-icu"
is 'English (Montserrat)';

create collation if not exists pg_catalog."en-MT-x-icu" (
  locale = 'en_MT'
);

comment on collation pg_catalog."en-MT-x-icu"
is 'English (Malta)';

create collation if not exists pg_catalog."en-MU-x-icu" (
  locale = 'en_MU'
);

comment on collation pg_catalog."en-MU-x-icu"
is 'English (Mauritius)';

create collation if not exists pg_catalog."en-MW-x-icu" (
  locale = 'en_MW'
);

comment on collation pg_catalog."en-MW-x-icu"
is 'English (Malawi)';

create collation if not exists pg_catalog."en-NA-x-icu" (
  locale = 'en_NA'
);

comment on collation pg_catalog."en-NA-x-icu"
is 'English (Namibia)';

create collation if not exists pg_catalog."en-NF-x-icu" (
  locale = 'en_NF'
);

comment on collation pg_catalog."en-NF-x-icu"
is 'English (Norfolk Island)';

create collation if not exists pg_catalog."en-NG-x-icu" (
  locale = 'en_NG'
);

comment on collation pg_catalog."en-NG-x-icu"
is 'English (Nigeria)';

create collation if not exists pg_catalog."en-NR-x-icu" (
  locale = 'en_NR'
);

comment on collation pg_catalog."en-NR-x-icu"
is 'English (Nauru)';

create collation if not exists pg_catalog."en-NU-x-icu" (
  locale = 'en_NU'
);

comment on collation pg_catalog."en-NU-x-icu"
is 'English (Niue)';

create collation if not exists pg_catalog."en-NZ-x-icu" (
  locale = 'en_NZ'
);

comment on collation pg_catalog."en-NZ-x-icu"
is 'English (New Zealand)';

create collation if not exists pg_catalog."en-PG-x-icu" (
  locale = 'en_PG'
);

comment on collation pg_catalog."en-PG-x-icu"
is 'English (Papua New Guinea)';

create collation if not exists pg_catalog."en-PH-x-icu" (
  locale = 'en_PH'
);

comment on collation pg_catalog."en-PH-x-icu"
is 'English (Philippines)';

create collation if not exists pg_catalog."en-PK-x-icu" (
  locale = 'en_PK'
);

comment on collation pg_catalog."en-PK-x-icu"
is 'English (Pakistan)';

create collation if not exists pg_catalog."en-PN-x-icu" (
  locale = 'en_PN'
);

comment on collation pg_catalog."en-PN-x-icu"
is 'English (Pitcairn Islands)';

create collation if not exists pg_catalog."en-PR-x-icu" (
  locale = 'en_PR'
);

comment on collation pg_catalog."en-PR-x-icu"
is 'English (Puerto Rico)';

create collation if not exists pg_catalog."en-PW-x-icu" (
  locale = 'en_PW'
);

comment on collation pg_catalog."en-PW-x-icu"
is 'English (Palau)';

create collation if not exists pg_catalog."en-RW-x-icu" (
  locale = 'en_RW'
);

comment on collation pg_catalog."en-RW-x-icu"
is 'English (Rwanda)';

create collation if not exists pg_catalog."en-SB-x-icu" (
  locale = 'en_SB'
);

comment on collation pg_catalog."en-SB-x-icu"
is 'English (Solomon Islands)';

create collation if not exists pg_catalog."en-SC-x-icu" (
  locale = 'en_SC'
);

comment on collation pg_catalog."en-SC-x-icu"
is 'English (Seychelles)';

create collation if not exists pg_catalog."en-SD-x-icu" (
  locale = 'en_SD'
);

comment on collation pg_catalog."en-SD-x-icu"
is 'English (Sudan)';

create collation if not exists pg_catalog."en-SG-x-icu" (
  locale = 'en_SG'
);

comment on collation pg_catalog."en-SG-x-icu"
is 'English (Singapore)';

create collation if not exists pg_catalog."en-SH-x-icu" (
  locale = 'en_SH'
);

comment on collation pg_catalog."en-SH-x-icu"
is 'English (Saint Helena)';

create collation if not exists pg_catalog."en-SL-x-icu" (
  locale = 'en_SL'
);

comment on collation pg_catalog."en-SL-x-icu"
is 'English (Sierra Leone)';

create collation if not exists pg_catalog."en-SS-x-icu" (
  locale = 'en_SS'
);

comment on collation pg_catalog."en-SS-x-icu"
is 'English (South Sudan)';

create collation if not exists pg_catalog."en-SX-x-icu" (
  locale = 'en_SX'
);

comment on collation pg_catalog."en-SX-x-icu"
is 'English (Sint Maarten)';

create collation if not exists pg_catalog."en-SZ-x-icu" (
  locale = 'en_SZ'
);

comment on collation pg_catalog."en-SZ-x-icu"
is 'English (Swaziland)';

create collation if not exists pg_catalog."en-TC-x-icu" (
  locale = 'en_TC'
);

comment on collation pg_catalog."en-TC-x-icu"
is 'English (Turks and Caicos Islands)';

create collation if not exists pg_catalog."en-TK-x-icu" (
  locale = 'en_TK'
);

comment on collation pg_catalog."en-TK-x-icu"
is 'English (Tokelau)';

create collation if not exists pg_catalog."en-TO-x-icu" (
  locale = 'en_TO'
);

comment on collation pg_catalog."en-TO-x-icu"
is 'English (Tonga)';

create collation if not exists pg_catalog."en-TT-x-icu" (
  locale = 'en_TT'
);

comment on collation pg_catalog."en-TT-x-icu"
is 'English (Trinidad and Tobago)';

create collation if not exists pg_catalog."en-TV-x-icu" (
  locale = 'en_TV'
);

comment on collation pg_catalog."en-TV-x-icu"
is 'English (Tuvalu)';

create collation if not exists pg_catalog."en-TZ-x-icu" (
  locale = 'en_TZ'
);

comment on collation pg_catalog."en-TZ-x-icu"
is 'English (Tanzania)';

create collation if not exists pg_catalog."en-UG-x-icu" (
  locale = 'en_UG'
);

comment on collation pg_catalog."en-UG-x-icu"
is 'English (Uganda)';

create collation if not exists pg_catalog."en-UM-x-icu" (
  locale = 'en_UM'
);

comment on collation pg_catalog."en-UM-x-icu"
is 'English (U.S. Outlying Islands)';

create collation if not exists pg_catalog."en-US-x-icu" (
  locale = 'en_US'
);

comment on collation pg_catalog."en-US-x-icu"
is 'English (United States)';

create collation if not exists pg_catalog."en-US-u-va-posix-x-icu" (
  locale = 'en_US_POSIX'
);

comment on collation pg_catalog."en-US-u-va-posix-x-icu"
is 'English (United States, Computer)';

create collation if not exists pg_catalog."en-VC-x-icu" (
  locale = 'en_VC'
);

comment on collation pg_catalog."en-VC-x-icu"
is 'English (St. Vincent & Grenadines)';

create collation if not exists pg_catalog."en-VG-x-icu" (
  locale = 'en_VG'
);

comment on collation pg_catalog."en-VG-x-icu"
is 'English (British Virgin Islands)';

create collation if not exists pg_catalog."en-VI-x-icu" (
  locale = 'en_VI'
);

comment on collation pg_catalog."en-VI-x-icu"
is 'English (U.S. Virgin Islands)';

create collation if not exists pg_catalog."en-VU-x-icu" (
  locale = 'en_VU'
);

comment on collation pg_catalog."en-VU-x-icu"
is 'English (Vanuatu)';

create collation if not exists pg_catalog."en-WS-x-icu" (
  locale = 'en_WS'
);

comment on collation pg_catalog."en-WS-x-icu"
is 'English (Samoa)';

create collation if not exists pg_catalog."en-ZA-x-icu" (
  locale = 'en_ZA'
);

comment on collation pg_catalog."en-ZA-x-icu"
is 'English (South Africa)';

create collation if not exists pg_catalog."en-ZM-x-icu" (
  locale = 'en_ZM'
);

comment on collation pg_catalog."en-ZM-x-icu"
is 'English (Zambia)';

create collation if not exists pg_catalog."en-ZW-x-icu" (
  locale = 'en_ZW'
);

comment on collation pg_catalog."en-ZW-x-icu"
is 'English (Zimbabwe)';

create collation if not exists pg_catalog."eo-x-icu" (
  locale = 'eo'
);

comment on collation pg_catalog."eo-x-icu"
is 'Esperanto';

create collation if not exists pg_catalog."es-x-icu" (
  locale = 'es'
);

comment on collation pg_catalog."es-x-icu"
is 'Spanish';

create collation if not exists pg_catalog."es-419-x-icu" (
  locale = 'es_419'
);

comment on collation pg_catalog."es-419-x-icu"
is 'Spanish (Latin America)';

create collation if not exists pg_catalog."es-AR-x-icu" (
  locale = 'es_AR'
);

comment on collation pg_catalog."es-AR-x-icu"
is 'Spanish (Argentina)';

create collation if not exists pg_catalog."es-BO-x-icu" (
  locale = 'es_BO'
);

comment on collation pg_catalog."es-BO-x-icu"
is 'Spanish (Bolivia)';

create collation if not exists pg_catalog."es-CL-x-icu" (
  locale = 'es_CL'
);

comment on collation pg_catalog."es-CL-x-icu"
is 'Spanish (Chile)';

create collation if not exists pg_catalog."es-CO-x-icu" (
  locale = 'es_CO'
);

comment on collation pg_catalog."es-CO-x-icu"
is 'Spanish (Colombia)';

create collation if not exists pg_catalog."es-CR-x-icu" (
  locale = 'es_CR'
);

comment on collation pg_catalog."es-CR-x-icu"
is 'Spanish (Costa Rica)';

create collation if not exists pg_catalog."es-CU-x-icu" (
  locale = 'es_CU'
);

comment on collation pg_catalog."es-CU-x-icu"
is 'Spanish (Cuba)';

create collation if not exists pg_catalog."es-DO-x-icu" (
  locale = 'es_DO'
);

comment on collation pg_catalog."es-DO-x-icu"
is 'Spanish (Dominican Republic)';

create collation if not exists pg_catalog."es-EA-x-icu" (
  locale = 'es_EA'
);

comment on collation pg_catalog."es-EA-x-icu"
is 'Spanish (Ceuta and Melilla)';

create collation if not exists pg_catalog."es-EC-x-icu" (
  locale = 'es_EC'
);

comment on collation pg_catalog."es-EC-x-icu"
is 'Spanish (Ecuador)';

create collation if not exists pg_catalog."es-ES-x-icu" (
  locale = 'es_ES'
);

comment on collation pg_catalog."es-ES-x-icu"
is 'Spanish (Spain)';

create collation if not exists pg_catalog."es-GQ-x-icu" (
  locale = 'es_GQ'
);

comment on collation pg_catalog."es-GQ-x-icu"
is 'Spanish (Equatorial Guinea)';

create collation if not exists pg_catalog."es-GT-x-icu" (
  locale = 'es_GT'
);

comment on collation pg_catalog."es-GT-x-icu"
is 'Spanish (Guatemala)';

create collation if not exists pg_catalog."es-HN-x-icu" (
  locale = 'es_HN'
);

comment on collation pg_catalog."es-HN-x-icu"
is 'Spanish (Honduras)';

create collation if not exists pg_catalog."es-IC-x-icu" (
  locale = 'es_IC'
);

comment on collation pg_catalog."es-IC-x-icu"
is 'Spanish (Canary Islands)';

create collation if not exists pg_catalog."es-MX-x-icu" (
  locale = 'es_MX'
);

comment on collation pg_catalog."es-MX-x-icu"
is 'Spanish (Mexico)';

create collation if not exists pg_catalog."es-NI-x-icu" (
  locale = 'es_NI'
);

comment on collation pg_catalog."es-NI-x-icu"
is 'Spanish (Nicaragua)';

create collation if not exists pg_catalog."es-PA-x-icu" (
  locale = 'es_PA'
);

comment on collation pg_catalog."es-PA-x-icu"
is 'Spanish (Panama)';

create collation if not exists pg_catalog."es-PE-x-icu" (
  locale = 'es_PE'
);

comment on collation pg_catalog."es-PE-x-icu"
is 'Spanish (Peru)';

create collation if not exists pg_catalog."es-PH-x-icu" (
  locale = 'es_PH'
);

comment on collation pg_catalog."es-PH-x-icu"
is 'Spanish (Philippines)';

create collation if not exists pg_catalog."es-PR-x-icu" (
  locale = 'es_PR'
);

comment on collation pg_catalog."es-PR-x-icu"
is 'Spanish (Puerto Rico)';

create collation if not exists pg_catalog."es-PY-x-icu" (
  locale = 'es_PY'
);

comment on collation pg_catalog."es-PY-x-icu"
is 'Spanish (Paraguay)';

create collation if not exists pg_catalog."es-SV-x-icu" (
  locale = 'es_SV'
);

comment on collation pg_catalog."es-SV-x-icu"
is 'Spanish (El Salvador)';

create collation if not exists pg_catalog."es-US-x-icu" (
  locale = 'es_US'
);

comment on collation pg_catalog."es-US-x-icu"
is 'Spanish (United States)';

create collation if not exists pg_catalog."es-UY-x-icu" (
  locale = 'es_UY'
);

comment on collation pg_catalog."es-UY-x-icu"
is 'Spanish (Uruguay)';

create collation if not exists pg_catalog."es-VE-x-icu" (
  locale = 'es_VE'
);

comment on collation pg_catalog."es-VE-x-icu"
is 'Spanish (Venezuela)';

create collation if not exists pg_catalog."et-x-icu" (
  locale = 'et'
);

comment on collation pg_catalog."et-x-icu"
is 'Estonian';

create collation if not exists pg_catalog."et-EE-x-icu" (
  locale = 'et_EE'
);

comment on collation pg_catalog."et-EE-x-icu"
is 'Estonian (Estonia)';

create collation if not exists pg_catalog."eu-x-icu" (
  locale = 'eu'
);

comment on collation pg_catalog."eu-x-icu"
is 'Basque';

create collation if not exists pg_catalog."eu-ES-x-icu" (
  locale = 'eu_ES'
);

comment on collation pg_catalog."eu-ES-x-icu"
is 'Basque (Spain)';

create collation if not exists pg_catalog."ewo-x-icu" (
  locale = 'ewo'
);

comment on collation pg_catalog."ewo-x-icu"
is 'Ewondo';

create collation if not exists pg_catalog."ewo-CM-x-icu" (
  locale = 'ewo_CM'
);

comment on collation pg_catalog."ewo-CM-x-icu"
is 'Ewondo (Cameroon)';

create collation if not exists pg_catalog."fa-x-icu" (
  locale = 'fa'
);

comment on collation pg_catalog."fa-x-icu"
is 'Persian';

create collation if not exists pg_catalog."fa-AF-x-icu" (
  locale = 'fa_AF'
);

comment on collation pg_catalog."fa-AF-x-icu"
is 'Persian (Afghanistan)';

create collation if not exists pg_catalog."fa-IR-x-icu" (
  locale = 'fa_IR'
);

comment on collation pg_catalog."fa-IR-x-icu"
is 'Persian (Iran)';

create collation if not exists pg_catalog."ff-x-icu" (
  locale = 'ff'
);

comment on collation pg_catalog."ff-x-icu"
is 'Fulah';

create collation if not exists pg_catalog."ff-SN-x-icu" (
  locale = 'ff_SN'
);

comment on collation pg_catalog."ff-SN-x-icu"
is 'Fulah (Senegal)';

create collation if not exists pg_catalog."fi-x-icu" (
  locale = 'fi'
);

comment on collation pg_catalog."fi-x-icu"
is 'Finnish';

create collation if not exists pg_catalog."fi-FI-x-icu" (
  locale = 'fi_FI'
);

comment on collation pg_catalog."fi-FI-x-icu"
is 'Finnish (Finland)';

create collation if not exists pg_catalog."fil-x-icu" (
  locale = 'fil'
);

comment on collation pg_catalog."fil-x-icu"
is 'Filipino';

create collation if not exists pg_catalog."fil-PH-x-icu" (
  locale = 'fil_PH'
);

comment on collation pg_catalog."fil-PH-x-icu"
is 'Filipino (Philippines)';

create collation if not exists pg_catalog."fo-x-icu" (
  locale = 'fo'
);

comment on collation pg_catalog."fo-x-icu"
is 'Faroese';

create collation if not exists pg_catalog."fo-FO-x-icu" (
  locale = 'fo_FO'
);

comment on collation pg_catalog."fo-FO-x-icu"
is 'Faroese (Faroe Islands)';

create collation if not exists pg_catalog."fr-x-icu" (
  locale = 'fr'
);

comment on collation pg_catalog."fr-x-icu"
is 'French';

create collation if not exists pg_catalog."fr-BE-x-icu" (
  locale = 'fr_BE'
);

comment on collation pg_catalog."fr-BE-x-icu"
is 'French (Belgium)';

create collation if not exists pg_catalog."fr-BF-x-icu" (
  locale = 'fr_BF'
);

comment on collation pg_catalog."fr-BF-x-icu"
is 'French (Burkina Faso)';

create collation if not exists pg_catalog."fr-BI-x-icu" (
  locale = 'fr_BI'
);

comment on collation pg_catalog."fr-BI-x-icu"
is 'French (Burundi)';

create collation if not exists pg_catalog."fr-BJ-x-icu" (
  locale = 'fr_BJ'
);

comment on collation pg_catalog."fr-BJ-x-icu"
is 'French (Benin)';

create collation if not exists pg_catalog."fr-BL-x-icu" (
  locale = 'fr_BL'
);

create collation if not exists pg_catalog."fr-CA-x-icu" (
  locale = 'fr_CA'
);

comment on collation pg_catalog."fr-CA-x-icu"
is 'French (Canada)';

create collation if not exists pg_catalog."fr-CD-x-icu" (
  locale = 'fr_CD'
);

comment on collation pg_catalog."fr-CD-x-icu"
is 'French (Congo - Kinshasa)';

create collation if not exists pg_catalog."fr-CF-x-icu" (
  locale = 'fr_CF'
);

comment on collation pg_catalog."fr-CF-x-icu"
is 'French (Central African Republic)';

create collation if not exists pg_catalog."fr-CG-x-icu" (
  locale = 'fr_CG'
);

comment on collation pg_catalog."fr-CG-x-icu"
is 'French (Congo - Brazzaville)';

create collation if not exists pg_catalog."fr-CH-x-icu" (
  locale = 'fr_CH'
);

comment on collation pg_catalog."fr-CH-x-icu"
is 'French (Switzerland)';

create collation if not exists pg_catalog."fr-CI-x-icu" (
  locale = 'fr_CI'
);

create collation if not exists pg_catalog."fr-CM-x-icu" (
  locale = 'fr_CM'
);

comment on collation pg_catalog."fr-CM-x-icu"
is 'French (Cameroon)';

create collation if not exists pg_catalog."fr-DJ-x-icu" (
  locale = 'fr_DJ'
);

comment on collation pg_catalog."fr-DJ-x-icu"
is 'French (Djibouti)';

create collation if not exists pg_catalog."fr-DZ-x-icu" (
  locale = 'fr_DZ'
);

comment on collation pg_catalog."fr-DZ-x-icu"
is 'French (Algeria)';

create collation if not exists pg_catalog."fr-FR-x-icu" (
  locale = 'fr_FR'
);

comment on collation pg_catalog."fr-FR-x-icu"
is 'French (France)';

create collation if not exists pg_catalog."fr-GA-x-icu" (
  locale = 'fr_GA'
);

comment on collation pg_catalog."fr-GA-x-icu"
is 'French (Gabon)';

create collation if not exists pg_catalog."fr-GF-x-icu" (
  locale = 'fr_GF'
);

comment on collation pg_catalog."fr-GF-x-icu"
is 'French (French Guiana)';

create collation if not exists pg_catalog."fr-GN-x-icu" (
  locale = 'fr_GN'
);

comment on collation pg_catalog."fr-GN-x-icu"
is 'French (Guinea)';

create collation if not exists pg_catalog."fr-GP-x-icu" (
  locale = 'fr_GP'
);

comment on collation pg_catalog."fr-GP-x-icu"
is 'French (Guadeloupe)';

create collation if not exists pg_catalog."fr-GQ-x-icu" (
  locale = 'fr_GQ'
);

comment on collation pg_catalog."fr-GQ-x-icu"
is 'French (Equatorial Guinea)';

create collation if not exists pg_catalog."fr-HT-x-icu" (
  locale = 'fr_HT'
);

comment on collation pg_catalog."fr-HT-x-icu"
is 'French (Haiti)';

create collation if not exists pg_catalog."fr-KM-x-icu" (
  locale = 'fr_KM'
);

comment on collation pg_catalog."fr-KM-x-icu"
is 'French (Comoros)';

create collation if not exists pg_catalog."fr-LU-x-icu" (
  locale = 'fr_LU'
);

comment on collation pg_catalog."fr-LU-x-icu"
is 'French (Luxembourg)';

create collation if not exists pg_catalog."fr-MA-x-icu" (
  locale = 'fr_MA'
);

comment on collation pg_catalog."fr-MA-x-icu"
is 'French (Morocco)';

create collation if not exists pg_catalog."fr-MC-x-icu" (
  locale = 'fr_MC'
);

comment on collation pg_catalog."fr-MC-x-icu"
is 'French (Monaco)';

create collation if not exists pg_catalog."fr-MF-x-icu" (
  locale = 'fr_MF'
);

comment on collation pg_catalog."fr-MF-x-icu"
is 'French (Saint Martin)';

create collation if not exists pg_catalog."fr-MG-x-icu" (
  locale = 'fr_MG'
);

comment on collation pg_catalog."fr-MG-x-icu"
is 'French (Madagascar)';

create collation if not exists pg_catalog."fr-ML-x-icu" (
  locale = 'fr_ML'
);

comment on collation pg_catalog."fr-ML-x-icu"
is 'French (Mali)';

create collation if not exists pg_catalog."fr-MQ-x-icu" (
  locale = 'fr_MQ'
);

comment on collation pg_catalog."fr-MQ-x-icu"
is 'French (Martinique)';

create collation if not exists pg_catalog."fr-MR-x-icu" (
  locale = 'fr_MR'
);

comment on collation pg_catalog."fr-MR-x-icu"
is 'French (Mauritania)';

create collation if not exists pg_catalog."fr-MU-x-icu" (
  locale = 'fr_MU'
);

comment on collation pg_catalog."fr-MU-x-icu"
is 'French (Mauritius)';

create collation if not exists pg_catalog."fr-NC-x-icu" (
  locale = 'fr_NC'
);

comment on collation pg_catalog."fr-NC-x-icu"
is 'French (New Caledonia)';

create collation if not exists pg_catalog."fr-NE-x-icu" (
  locale = 'fr_NE'
);

comment on collation pg_catalog."fr-NE-x-icu"
is 'French (Niger)';

create collation if not exists pg_catalog."fr-PF-x-icu" (
  locale = 'fr_PF'
);

comment on collation pg_catalog."fr-PF-x-icu"
is 'French (French Polynesia)';

create collation if not exists pg_catalog."fr-PM-x-icu" (
  locale = 'fr_PM'
);

comment on collation pg_catalog."fr-PM-x-icu"
is 'French (Saint Pierre and Miquelon)';

create collation if not exists pg_catalog."fr-RE-x-icu" (
  locale = 'fr_RE'
);

create collation if not exists pg_catalog."fr-RW-x-icu" (
  locale = 'fr_RW'
);

comment on collation pg_catalog."fr-RW-x-icu"
is 'French (Rwanda)';

create collation if not exists pg_catalog."fr-SC-x-icu" (
  locale = 'fr_SC'
);

comment on collation pg_catalog."fr-SC-x-icu"
is 'French (Seychelles)';

create collation if not exists pg_catalog."fr-SN-x-icu" (
  locale = 'fr_SN'
);

comment on collation pg_catalog."fr-SN-x-icu"
is 'French (Senegal)';

create collation if not exists pg_catalog."fr-SY-x-icu" (
  locale = 'fr_SY'
);

comment on collation pg_catalog."fr-SY-x-icu"
is 'French (Syria)';

create collation if not exists pg_catalog."fr-TD-x-icu" (
  locale = 'fr_TD'
);

comment on collation pg_catalog."fr-TD-x-icu"
is 'French (Chad)';

create collation if not exists pg_catalog."fr-TG-x-icu" (
  locale = 'fr_TG'
);

comment on collation pg_catalog."fr-TG-x-icu"
is 'French (Togo)';

create collation if not exists pg_catalog."fr-TN-x-icu" (
  locale = 'fr_TN'
);

comment on collation pg_catalog."fr-TN-x-icu"
is 'French (Tunisia)';

create collation if not exists pg_catalog."fr-VU-x-icu" (
  locale = 'fr_VU'
);

comment on collation pg_catalog."fr-VU-x-icu"
is 'French (Vanuatu)';

create collation if not exists pg_catalog."fr-WF-x-icu" (
  locale = 'fr_WF'
);

comment on collation pg_catalog."fr-WF-x-icu"
is 'French (Wallis and Futuna)';

create collation if not exists pg_catalog."fr-YT-x-icu" (
  locale = 'fr_YT'
);

comment on collation pg_catalog."fr-YT-x-icu"
is 'French (Mayotte)';

create collation if not exists pg_catalog."ga-x-icu" (
  locale = 'ga'
);

comment on collation pg_catalog."ga-x-icu"
is 'Irish';

create collation if not exists pg_catalog."ga-IE-x-icu" (
  locale = 'ga_IE'
);

comment on collation pg_catalog."ga-IE-x-icu"
is 'Irish (Ireland)';

create collation if not exists pg_catalog."gl-x-icu" (
  locale = 'gl'
);

comment on collation pg_catalog."gl-x-icu"
is 'Galician';

create collation if not exists pg_catalog."gl-ES-x-icu" (
  locale = 'gl_ES'
);

comment on collation pg_catalog."gl-ES-x-icu"
is 'Galician (Spain)';

create collation if not exists pg_catalog."gsw-x-icu" (
  locale = 'gsw'
);

comment on collation pg_catalog."gsw-x-icu"
is 'Swiss German';

create collation if not exists pg_catalog."gsw-CH-x-icu" (
  locale = 'gsw_CH'
);

comment on collation pg_catalog."gsw-CH-x-icu"
is 'Swiss German (Switzerland)';

create collation if not exists pg_catalog."gsw-LI-x-icu" (
  locale = 'gsw_LI'
);

comment on collation pg_catalog."gsw-LI-x-icu"
is 'Swiss German (Liechtenstein)';

create collation if not exists pg_catalog."gu-x-icu" (
  locale = 'gu'
);

comment on collation pg_catalog."gu-x-icu"
is 'Gujarati';

create collation if not exists pg_catalog."gu-IN-x-icu" (
  locale = 'gu_IN'
);

comment on collation pg_catalog."gu-IN-x-icu"
is 'Gujarati (India)';

create collation if not exists pg_catalog."guz-x-icu" (
  locale = 'guz'
);

comment on collation pg_catalog."guz-x-icu"
is 'Gusii';

create collation if not exists pg_catalog."guz-KE-x-icu" (
  locale = 'guz_KE'
);

comment on collation pg_catalog."guz-KE-x-icu"
is 'Gusii (Kenya)';

create collation if not exists pg_catalog."gv-x-icu" (
  locale = 'gv'
);

comment on collation pg_catalog."gv-x-icu"
is 'Manx';

create collation if not exists pg_catalog."gv-IM-x-icu" (
  locale = 'gv_IM'
);

comment on collation pg_catalog."gv-IM-x-icu"
is 'Manx (Isle of Man)';

create collation if not exists pg_catalog."ha-x-icu" (
  locale = 'ha'
);

comment on collation pg_catalog."ha-x-icu"
is 'Hausa';

create collation if not exists pg_catalog."ha-Latn-x-icu" (
  locale = 'ha_Latn'
);

comment on collation pg_catalog."ha-Latn-x-icu"
is 'Hausa (Latin)';

create collation if not exists pg_catalog."ha-Latn-GH-x-icu" (
  locale = 'ha_Latn_GH'
);

comment on collation pg_catalog."ha-Latn-GH-x-icu"
is 'Hausa (Latin, Ghana)';

create collation if not exists pg_catalog."ha-Latn-NE-x-icu" (
  locale = 'ha_Latn_NE'
);

comment on collation pg_catalog."ha-Latn-NE-x-icu"
is 'Hausa (Latin, Niger)';

create collation if not exists pg_catalog."ha-Latn-NG-x-icu" (
  locale = 'ha_Latn_NG'
);

comment on collation pg_catalog."ha-Latn-NG-x-icu"
is 'Hausa (Latin, Nigeria)';

create collation if not exists pg_catalog."haw-x-icu" (
  locale = 'haw'
);

comment on collation pg_catalog."haw-x-icu"
is 'Hawaiian';

create collation if not exists pg_catalog."haw-US-x-icu" (
  locale = 'haw_US'
);

comment on collation pg_catalog."haw-US-x-icu"
is 'Hawaiian (United States)';

create collation if not exists pg_catalog."he-x-icu" (
  locale = 'he'
);

comment on collation pg_catalog."he-x-icu"
is 'Hebrew';

create collation if not exists pg_catalog."he-IL-x-icu" (
  locale = 'he_IL'
);

comment on collation pg_catalog."he-IL-x-icu"
is 'Hebrew (Israel)';

create collation if not exists pg_catalog."hi-x-icu" (
  locale = 'hi'
);

comment on collation pg_catalog."hi-x-icu"
is 'Hindi';

create collation if not exists pg_catalog."hi-IN-x-icu" (
  locale = 'hi_IN'
);

comment on collation pg_catalog."hi-IN-x-icu"
is 'Hindi (India)';

create collation if not exists pg_catalog."hr-x-icu" (
  locale = 'hr'
);

comment on collation pg_catalog."hr-x-icu"
is 'Croatian';

create collation if not exists pg_catalog."hr-BA-x-icu" (
  locale = 'hr_BA'
);

comment on collation pg_catalog."hr-BA-x-icu"
is 'Croatian (Bosnia and Herzegovina)';

create collation if not exists pg_catalog."hr-HR-x-icu" (
  locale = 'hr_HR'
);

comment on collation pg_catalog."hr-HR-x-icu"
is 'Croatian (Croatia)';

create collation if not exists pg_catalog."hu-x-icu" (
  locale = 'hu'
);

comment on collation pg_catalog."hu-x-icu"
is 'Hungarian';

create collation if not exists pg_catalog."hu-HU-x-icu" (
  locale = 'hu_HU'
);

comment on collation pg_catalog."hu-HU-x-icu"
is 'Hungarian (Hungary)';

create collation if not exists pg_catalog."hy-x-icu" (
  locale = 'hy'
);

comment on collation pg_catalog."hy-x-icu"
is 'Armenian';

create collation if not exists pg_catalog."hy-AM-x-icu" (
  locale = 'hy_AM'
);

comment on collation pg_catalog."hy-AM-x-icu"
is 'Armenian (Armenia)';

create collation if not exists pg_catalog."id-x-icu" (
  locale = 'id'
);

comment on collation pg_catalog."id-x-icu"
is 'Indonesian';

create collation if not exists pg_catalog."id-ID-x-icu" (
  locale = 'id_ID'
);

comment on collation pg_catalog."id-ID-x-icu"
is 'Indonesian (Indonesia)';

create collation if not exists pg_catalog."ig-x-icu" (
  locale = 'ig'
);

comment on collation pg_catalog."ig-x-icu"
is 'Igbo';

create collation if not exists pg_catalog."ig-NG-x-icu" (
  locale = 'ig_NG'
);

comment on collation pg_catalog."ig-NG-x-icu"
is 'Igbo (Nigeria)';

create collation if not exists pg_catalog."ii-x-icu" (
  locale = 'ii'
);

comment on collation pg_catalog."ii-x-icu"
is 'Sichuan Yi';

create collation if not exists pg_catalog."ii-CN-x-icu" (
  locale = 'ii_CN'
);

comment on collation pg_catalog."ii-CN-x-icu"
is 'Sichuan Yi (China)';

create collation if not exists pg_catalog."is-x-icu" (
  locale = 'is'
);

comment on collation pg_catalog."is-x-icu"
is 'Icelandic';

create collation if not exists pg_catalog."is-IS-x-icu" (
  locale = 'is_IS'
);

comment on collation pg_catalog."is-IS-x-icu"
is 'Icelandic (Iceland)';

create collation if not exists pg_catalog."it-x-icu" (
  locale = 'it'
);

comment on collation pg_catalog."it-x-icu"
is 'Italian';

create collation if not exists pg_catalog."it-CH-x-icu" (
  locale = 'it_CH'
);

comment on collation pg_catalog."it-CH-x-icu"
is 'Italian (Switzerland)';

create collation if not exists pg_catalog."it-IT-x-icu" (
  locale = 'it_IT'
);

comment on collation pg_catalog."it-IT-x-icu"
is 'Italian (Italy)';

create collation if not exists pg_catalog."it-SM-x-icu" (
  locale = 'it_SM'
);

comment on collation pg_catalog."it-SM-x-icu"
is 'Italian (San Marino)';

create collation if not exists pg_catalog."ja-x-icu" (
  locale = 'ja'
);

comment on collation pg_catalog."ja-x-icu"
is 'Japanese';

create collation if not exists pg_catalog."ja-JP-x-icu" (
  locale = 'ja_JP'
);

comment on collation pg_catalog."ja-JP-x-icu"
is 'Japanese (Japan)';

create collation if not exists pg_catalog."jgo-x-icu" (
  locale = 'jgo'
);

comment on collation pg_catalog."jgo-x-icu"
is 'Ngomba';

create collation if not exists pg_catalog."jgo-CM-x-icu" (
  locale = 'jgo_CM'
);

comment on collation pg_catalog."jgo-CM-x-icu"
is 'Ngomba (Cameroon)';

create collation if not exists pg_catalog."jmc-x-icu" (
  locale = 'jmc'
);

comment on collation pg_catalog."jmc-x-icu"
is 'Machame';

create collation if not exists pg_catalog."jmc-TZ-x-icu" (
  locale = 'jmc_TZ'
);

comment on collation pg_catalog."jmc-TZ-x-icu"
is 'Machame (Tanzania)';

create collation if not exists pg_catalog."ka-x-icu" (
  locale = 'ka'
);

comment on collation pg_catalog."ka-x-icu"
is 'Georgian';

create collation if not exists pg_catalog."ka-GE-x-icu" (
  locale = 'ka_GE'
);

comment on collation pg_catalog."ka-GE-x-icu"
is 'Georgian (Georgia)';

create collation if not exists pg_catalog."kab-x-icu" (
  locale = 'kab'
);

comment on collation pg_catalog."kab-x-icu"
is 'Kabyle';

create collation if not exists pg_catalog."kab-DZ-x-icu" (
  locale = 'kab_DZ'
);

comment on collation pg_catalog."kab-DZ-x-icu"
is 'Kabyle (Algeria)';

create collation if not exists pg_catalog."kam-x-icu" (
  locale = 'kam'
);

comment on collation pg_catalog."kam-x-icu"
is 'Kamba';

create collation if not exists pg_catalog."kam-KE-x-icu" (
  locale = 'kam_KE'
);

comment on collation pg_catalog."kam-KE-x-icu"
is 'Kamba (Kenya)';

create collation if not exists pg_catalog."kde-x-icu" (
  locale = 'kde'
);

comment on collation pg_catalog."kde-x-icu"
is 'Makonde';

create collation if not exists pg_catalog."kde-TZ-x-icu" (
  locale = 'kde_TZ'
);

comment on collation pg_catalog."kde-TZ-x-icu"
is 'Makonde (Tanzania)';

create collation if not exists pg_catalog."kea-x-icu" (
  locale = 'kea'
);

comment on collation pg_catalog."kea-x-icu"
is 'Kabuverdianu';

create collation if not exists pg_catalog."kea-CV-x-icu" (
  locale = 'kea_CV'
);

comment on collation pg_catalog."kea-CV-x-icu"
is 'Kabuverdianu (Cape Verde)';

create collation if not exists pg_catalog."khq-x-icu" (
  locale = 'khq'
);

comment on collation pg_catalog."khq-x-icu"
is 'Koyra Chiini';

create collation if not exists pg_catalog."khq-ML-x-icu" (
  locale = 'khq_ML'
);

comment on collation pg_catalog."khq-ML-x-icu"
is 'Koyra Chiini (Mali)';

create collation if not exists pg_catalog."ki-x-icu" (
  locale = 'ki'
);

comment on collation pg_catalog."ki-x-icu"
is 'Kikuyu';

create collation if not exists pg_catalog."ki-KE-x-icu" (
  locale = 'ki_KE'
);

comment on collation pg_catalog."ki-KE-x-icu"
is 'Kikuyu (Kenya)';

create collation if not exists pg_catalog."kk-x-icu" (
  locale = 'kk'
);

comment on collation pg_catalog."kk-x-icu"
is 'Kazakh';

create collation if not exists pg_catalog."kk-Cyrl-x-icu" (
  locale = 'kk_Cyrl'
);

comment on collation pg_catalog."kk-Cyrl-x-icu"
is 'Kazakh (Cyrillic)';

create collation if not exists pg_catalog."kk-Cyrl-KZ-x-icu" (
  locale = 'kk_Cyrl_KZ'
);

comment on collation pg_catalog."kk-Cyrl-KZ-x-icu"
is 'Kazakh (Cyrillic, Kazakhstan)';

create collation if not exists pg_catalog."kkj-x-icu" (
  locale = 'kkj'
);

comment on collation pg_catalog."kkj-x-icu"
is 'Kako';

create collation if not exists pg_catalog."kkj-CM-x-icu" (
  locale = 'kkj_CM'
);

comment on collation pg_catalog."kkj-CM-x-icu"
is 'Kako (Cameroon)';

create collation if not exists pg_catalog."kl-x-icu" (
  locale = 'kl'
);

comment on collation pg_catalog."kl-x-icu"
is 'Kalaallisut';

create collation if not exists pg_catalog."kl-GL-x-icu" (
  locale = 'kl_GL'
);

comment on collation pg_catalog."kl-GL-x-icu"
is 'Kalaallisut (Greenland)';

create collation if not exists pg_catalog."kln-x-icu" (
  locale = 'kln'
);

comment on collation pg_catalog."kln-x-icu"
is 'Kalenjin';

create collation if not exists pg_catalog."kln-KE-x-icu" (
  locale = 'kln_KE'
);

comment on collation pg_catalog."kln-KE-x-icu"
is 'Kalenjin (Kenya)';

create collation if not exists pg_catalog."km-x-icu" (
  locale = 'km'
);

comment on collation pg_catalog."km-x-icu"
is 'Khmer';

create collation if not exists pg_catalog."km-KH-x-icu" (
  locale = 'km_KH'
);

comment on collation pg_catalog."km-KH-x-icu"
is 'Khmer (Cambodia)';

create collation if not exists pg_catalog."kn-x-icu" (
  locale = 'kn'
);

comment on collation pg_catalog."kn-x-icu"
is 'Kannada';

create collation if not exists pg_catalog."kn-IN-x-icu" (
  locale = 'kn_IN'
);

comment on collation pg_catalog."kn-IN-x-icu"
is 'Kannada (India)';

create collation if not exists pg_catalog."ko-x-icu" (
  locale = 'ko'
);

comment on collation pg_catalog."ko-x-icu"
is 'Korean';

create collation if not exists pg_catalog."ko-KP-x-icu" (
  locale = 'ko_KP'
);

comment on collation pg_catalog."ko-KP-x-icu"
is 'Korean (North Korea)';

create collation if not exists pg_catalog."ko-KR-x-icu" (
  locale = 'ko_KR'
);

comment on collation pg_catalog."ko-KR-x-icu"
is 'Korean (South Korea)';

create collation if not exists pg_catalog."kok-x-icu" (
  locale = 'kok'
);

comment on collation pg_catalog."kok-x-icu"
is 'Konkani';

create collation if not exists pg_catalog."kok-IN-x-icu" (
  locale = 'kok_IN'
);

comment on collation pg_catalog."kok-IN-x-icu"
is 'Konkani (India)';

create collation if not exists pg_catalog."ks-x-icu" (
  locale = 'ks'
);

comment on collation pg_catalog."ks-x-icu"
is 'Kashmiri';

create collation if not exists pg_catalog."ks-Arab-x-icu" (
  locale = 'ks_Arab'
);

comment on collation pg_catalog."ks-Arab-x-icu"
is 'Kashmiri (Arabic)';

create collation if not exists pg_catalog."ks-Arab-IN-x-icu" (
  locale = 'ks_Arab_IN'
);

comment on collation pg_catalog."ks-Arab-IN-x-icu"
is 'Kashmiri (Arabic, India)';

create collation if not exists pg_catalog."ksb-x-icu" (
  locale = 'ksb'
);

comment on collation pg_catalog."ksb-x-icu"
is 'Shambala';

create collation if not exists pg_catalog."ksb-TZ-x-icu" (
  locale = 'ksb_TZ'
);

comment on collation pg_catalog."ksb-TZ-x-icu"
is 'Shambala (Tanzania)';

create collation if not exists pg_catalog."ksf-x-icu" (
  locale = 'ksf'
);

comment on collation pg_catalog."ksf-x-icu"
is 'Bafia';

create collation if not exists pg_catalog."ksf-CM-x-icu" (
  locale = 'ksf_CM'
);

comment on collation pg_catalog."ksf-CM-x-icu"
is 'Bafia (Cameroon)';

create collation if not exists pg_catalog."kw-x-icu" (
  locale = 'kw'
);

comment on collation pg_catalog."kw-x-icu"
is 'Cornish';

create collation if not exists pg_catalog."kw-GB-x-icu" (
  locale = 'kw_GB'
);

comment on collation pg_catalog."kw-GB-x-icu"
is 'Cornish (United Kingdom)';

create collation if not exists pg_catalog."ky-x-icu" (
  locale = 'ky'
);

comment on collation pg_catalog."ky-x-icu"
is 'Kyrgyz';

create collation if not exists pg_catalog."ky-Cyrl-x-icu" (
  locale = 'ky_Cyrl'
);

comment on collation pg_catalog."ky-Cyrl-x-icu"
is 'Kyrgyz (Cyrillic)';

create collation if not exists pg_catalog."ky-Cyrl-KG-x-icu" (
  locale = 'ky_Cyrl_KG'
);

comment on collation pg_catalog."ky-Cyrl-KG-x-icu"
is 'Kyrgyz (Cyrillic, Kyrgyzstan)';

create collation if not exists pg_catalog."lag-x-icu" (
  locale = 'lag'
);

comment on collation pg_catalog."lag-x-icu"
is 'Langi';

create collation if not exists pg_catalog."lag-TZ-x-icu" (
  locale = 'lag_TZ'
);

comment on collation pg_catalog."lag-TZ-x-icu"
is 'Langi (Tanzania)';

create collation if not exists pg_catalog."lg-x-icu" (
  locale = 'lg'
);

comment on collation pg_catalog."lg-x-icu"
is 'Ganda';

create collation if not exists pg_catalog."lg-UG-x-icu" (
  locale = 'lg_UG'
);

comment on collation pg_catalog."lg-UG-x-icu"
is 'Ganda (Uganda)';

create collation if not exists pg_catalog."lkt-x-icu" (
  locale = 'lkt'
);

comment on collation pg_catalog."lkt-x-icu"
is 'Lakota';

create collation if not exists pg_catalog."lkt-US-x-icu" (
  locale = 'lkt_US'
);

comment on collation pg_catalog."lkt-US-x-icu"
is 'Lakota (United States)';

create collation if not exists pg_catalog."ln-x-icu" (
  locale = 'ln'
);

comment on collation pg_catalog."ln-x-icu"
is 'Lingala';

create collation if not exists pg_catalog."ln-AO-x-icu" (
  locale = 'ln_AO'
);

comment on collation pg_catalog."ln-AO-x-icu"
is 'Lingala (Angola)';

create collation if not exists pg_catalog."ln-CD-x-icu" (
  locale = 'ln_CD'
);

comment on collation pg_catalog."ln-CD-x-icu"
is 'Lingala (Congo - Kinshasa)';

create collation if not exists pg_catalog."ln-CF-x-icu" (
  locale = 'ln_CF'
);

comment on collation pg_catalog."ln-CF-x-icu"
is 'Lingala (Central African Republic)';

create collation if not exists pg_catalog."ln-CG-x-icu" (
  locale = 'ln_CG'
);

comment on collation pg_catalog."ln-CG-x-icu"
is 'Lingala (Congo - Brazzaville)';

create collation if not exists pg_catalog."lo-x-icu" (
  locale = 'lo'
);

comment on collation pg_catalog."lo-x-icu"
is 'Lao';

create collation if not exists pg_catalog."lo-LA-x-icu" (
  locale = 'lo_LA'
);

comment on collation pg_catalog."lo-LA-x-icu"
is 'Lao (Laos)';

create collation if not exists pg_catalog."lt-x-icu" (
  locale = 'lt'
);

comment on collation pg_catalog."lt-x-icu"
is 'Lithuanian';

create collation if not exists pg_catalog."lt-LT-x-icu" (
  locale = 'lt_LT'
);

comment on collation pg_catalog."lt-LT-x-icu"
is 'Lithuanian (Lithuania)';

create collation if not exists pg_catalog."lu-x-icu" (
  locale = 'lu'
);

comment on collation pg_catalog."lu-x-icu"
is 'Luba-Katanga';

create collation if not exists pg_catalog."lu-CD-x-icu" (
  locale = 'lu_CD'
);

comment on collation pg_catalog."lu-CD-x-icu"
is 'Luba-Katanga (Congo - Kinshasa)';

create collation if not exists pg_catalog."luo-x-icu" (
  locale = 'luo'
);

comment on collation pg_catalog."luo-x-icu"
is 'Luo';

create collation if not exists pg_catalog."luo-KE-x-icu" (
  locale = 'luo_KE'
);

comment on collation pg_catalog."luo-KE-x-icu"
is 'Luo (Kenya)';

create collation if not exists pg_catalog."luy-x-icu" (
  locale = 'luy'
);

comment on collation pg_catalog."luy-x-icu"
is 'Luyia';

create collation if not exists pg_catalog."luy-KE-x-icu" (
  locale = 'luy_KE'
);

comment on collation pg_catalog."luy-KE-x-icu"
is 'Luyia (Kenya)';

create collation if not exists pg_catalog."lv-x-icu" (
  locale = 'lv'
);

comment on collation pg_catalog."lv-x-icu"
is 'Latvian';

create collation if not exists pg_catalog."lv-LV-x-icu" (
  locale = 'lv_LV'
);

comment on collation pg_catalog."lv-LV-x-icu"
is 'Latvian (Latvia)';

create collation if not exists pg_catalog."mas-x-icu" (
  locale = 'mas'
);

comment on collation pg_catalog."mas-x-icu"
is 'Masai';

create collation if not exists pg_catalog."mas-KE-x-icu" (
  locale = 'mas_KE'
);

comment on collation pg_catalog."mas-KE-x-icu"
is 'Masai (Kenya)';

create collation if not exists pg_catalog."mas-TZ-x-icu" (
  locale = 'mas_TZ'
);

comment on collation pg_catalog."mas-TZ-x-icu"
is 'Masai (Tanzania)';

create collation if not exists pg_catalog."mer-x-icu" (
  locale = 'mer'
);

comment on collation pg_catalog."mer-x-icu"
is 'Meru';

create collation if not exists pg_catalog."mer-KE-x-icu" (
  locale = 'mer_KE'
);

comment on collation pg_catalog."mer-KE-x-icu"
is 'Meru (Kenya)';

create collation if not exists pg_catalog."mfe-x-icu" (
  locale = 'mfe'
);

comment on collation pg_catalog."mfe-x-icu"
is 'Morisyen';

create collation if not exists pg_catalog."mfe-MU-x-icu" (
  locale = 'mfe_MU'
);

comment on collation pg_catalog."mfe-MU-x-icu"
is 'Morisyen (Mauritius)';

create collation if not exists pg_catalog."mg-x-icu" (
  locale = 'mg'
);

comment on collation pg_catalog."mg-x-icu"
is 'Malagasy';

create collation if not exists pg_catalog."mg-MG-x-icu" (
  locale = 'mg_MG'
);

comment on collation pg_catalog."mg-MG-x-icu"
is 'Malagasy (Madagascar)';

create collation if not exists pg_catalog."mgh-x-icu" (
  locale = 'mgh'
);

comment on collation pg_catalog."mgh-x-icu"
is 'Makhuwa-Meetto';

create collation if not exists pg_catalog."mgh-MZ-x-icu" (
  locale = 'mgh_MZ'
);

comment on collation pg_catalog."mgh-MZ-x-icu"
is 'Makhuwa-Meetto (Mozambique)';

create collation if not exists pg_catalog."mgo-x-icu" (
  locale = 'mgo'
);

comment on collation pg_catalog."mgo-x-icu"
is 'Meta''';

create collation if not exists pg_catalog."mgo-CM-x-icu" (
  locale = 'mgo_CM'
);

comment on collation pg_catalog."mgo-CM-x-icu"
is 'Meta'' (Cameroon)';

create collation if not exists pg_catalog."mk-x-icu" (
  locale = 'mk'
);

comment on collation pg_catalog."mk-x-icu"
is 'Macedonian';

create collation if not exists pg_catalog."mk-MK-x-icu" (
  locale = 'mk_MK'
);

comment on collation pg_catalog."mk-MK-x-icu"
is 'Macedonian (Macedonia)';

create collation if not exists pg_catalog."ml-x-icu" (
  locale = 'ml'
);

comment on collation pg_catalog."ml-x-icu"
is 'Malayalam';

create collation if not exists pg_catalog."ml-IN-x-icu" (
  locale = 'ml_IN'
);

comment on collation pg_catalog."ml-IN-x-icu"
is 'Malayalam (India)';

create collation if not exists pg_catalog."mn-x-icu" (
  locale = 'mn'
);

comment on collation pg_catalog."mn-x-icu"
is 'Mongolian';

create collation if not exists pg_catalog."mn-Cyrl-x-icu" (
  locale = 'mn_Cyrl'
);

comment on collation pg_catalog."mn-Cyrl-x-icu"
is 'Mongolian (Cyrillic)';

create collation if not exists pg_catalog."mn-Cyrl-MN-x-icu" (
  locale = 'mn_Cyrl_MN'
);

comment on collation pg_catalog."mn-Cyrl-MN-x-icu"
is 'Mongolian (Cyrillic, Mongolia)';

create collation if not exists pg_catalog."mr-x-icu" (
  locale = 'mr'
);

comment on collation pg_catalog."mr-x-icu"
is 'Marathi';

create collation if not exists pg_catalog."mr-IN-x-icu" (
  locale = 'mr_IN'
);

comment on collation pg_catalog."mr-IN-x-icu"
is 'Marathi (India)';

create collation if not exists pg_catalog."ms-x-icu" (
  locale = 'ms'
);

comment on collation pg_catalog."ms-x-icu"
is 'Malay';

create collation if not exists pg_catalog."ms-Latn-x-icu" (
  locale = 'ms_Latn'
);

comment on collation pg_catalog."ms-Latn-x-icu"
is 'Malay (Latin)';

create collation if not exists pg_catalog."ms-Latn-BN-x-icu" (
  locale = 'ms_Latn_BN'
);

comment on collation pg_catalog."ms-Latn-BN-x-icu"
is 'Malay (Latin, Brunei)';

create collation if not exists pg_catalog."ms-Latn-MY-x-icu" (
  locale = 'ms_Latn_MY'
);

comment on collation pg_catalog."ms-Latn-MY-x-icu"
is 'Malay (Latin, Malaysia)';

create collation if not exists pg_catalog."ms-Latn-SG-x-icu" (
  locale = 'ms_Latn_SG'
);

comment on collation pg_catalog."ms-Latn-SG-x-icu"
is 'Malay (Latin, Singapore)';

create collation if not exists pg_catalog."mt-x-icu" (
  locale = 'mt'
);

comment on collation pg_catalog."mt-x-icu"
is 'Maltese';

create collation if not exists pg_catalog."mt-MT-x-icu" (
  locale = 'mt_MT'
);

comment on collation pg_catalog."mt-MT-x-icu"
is 'Maltese (Malta)';

create collation if not exists pg_catalog."mua-x-icu" (
  locale = 'mua'
);

comment on collation pg_catalog."mua-x-icu"
is 'Mundang';

create collation if not exists pg_catalog."mua-CM-x-icu" (
  locale = 'mua_CM'
);

comment on collation pg_catalog."mua-CM-x-icu"
is 'Mundang (Cameroon)';

create collation if not exists pg_catalog."my-x-icu" (
  locale = 'my'
);

comment on collation pg_catalog."my-x-icu"
is 'Burmese';

create collation if not exists pg_catalog."my-MM-x-icu" (
  locale = 'my_MM'
);

comment on collation pg_catalog."my-MM-x-icu"
is 'Burmese (Myanmar [Burma])';

create collation if not exists pg_catalog."naq-x-icu" (
  locale = 'naq'
);

comment on collation pg_catalog."naq-x-icu"
is 'Nama';

create collation if not exists pg_catalog."naq-NA-x-icu" (
  locale = 'naq_NA'
);

comment on collation pg_catalog."naq-NA-x-icu"
is 'Nama (Namibia)';

create collation if not exists pg_catalog."nb-x-icu" (
  locale = 'nb'
);

create collation if not exists pg_catalog."nb-NO-x-icu" (
  locale = 'nb_NO'
);

create collation if not exists pg_catalog."nb-SJ-x-icu" (
  locale = 'nb_SJ'
);

create collation if not exists pg_catalog."nd-x-icu" (
  locale = 'nd'
);

comment on collation pg_catalog."nd-x-icu"
is 'North Ndebele';

create collation if not exists pg_catalog."nd-ZW-x-icu" (
  locale = 'nd_ZW'
);

comment on collation pg_catalog."nd-ZW-x-icu"
is 'North Ndebele (Zimbabwe)';

create collation if not exists pg_catalog."ne-x-icu" (
  locale = 'ne'
);

comment on collation pg_catalog."ne-x-icu"
is 'Nepali';

create collation if not exists pg_catalog."ne-IN-x-icu" (
  locale = 'ne_IN'
);

comment on collation pg_catalog."ne-IN-x-icu"
is 'Nepali (India)';

create collation if not exists pg_catalog."ne-NP-x-icu" (
  locale = 'ne_NP'
);

comment on collation pg_catalog."ne-NP-x-icu"
is 'Nepali (Nepal)';

create collation if not exists pg_catalog."nl-x-icu" (
  locale = 'nl'
);

comment on collation pg_catalog."nl-x-icu"
is 'Dutch';

create collation if not exists pg_catalog."nl-AW-x-icu" (
  locale = 'nl_AW'
);

comment on collation pg_catalog."nl-AW-x-icu"
is 'Dutch (Aruba)';

create collation if not exists pg_catalog."nl-BE-x-icu" (
  locale = 'nl_BE'
);

comment on collation pg_catalog."nl-BE-x-icu"
is 'Dutch (Belgium)';

create collation if not exists pg_catalog."nl-BQ-x-icu" (
  locale = 'nl_BQ'
);

comment on collation pg_catalog."nl-BQ-x-icu"
is 'Dutch (Caribbean Netherlands)';

create collation if not exists pg_catalog."nl-CW-x-icu" (
  locale = 'nl_CW'
);

create collation if not exists pg_catalog."nl-NL-x-icu" (
  locale = 'nl_NL'
);

comment on collation pg_catalog."nl-NL-x-icu"
is 'Dutch (Netherlands)';

create collation if not exists pg_catalog."nl-SR-x-icu" (
  locale = 'nl_SR'
);

comment on collation pg_catalog."nl-SR-x-icu"
is 'Dutch (Suriname)';

create collation if not exists pg_catalog."nl-SX-x-icu" (
  locale = 'nl_SX'
);

comment on collation pg_catalog."nl-SX-x-icu"
is 'Dutch (Sint Maarten)';

create collation if not exists pg_catalog."nmg-x-icu" (
  locale = 'nmg'
);

comment on collation pg_catalog."nmg-x-icu"
is 'Kwasio';

create collation if not exists pg_catalog."nmg-CM-x-icu" (
  locale = 'nmg_CM'
);

comment on collation pg_catalog."nmg-CM-x-icu"
is 'Kwasio (Cameroon)';

create collation if not exists pg_catalog."nn-x-icu" (
  locale = 'nn'
);

comment on collation pg_catalog."nn-x-icu"
is 'Norwegian Nynorsk';

create collation if not exists pg_catalog."nn-NO-x-icu" (
  locale = 'nn_NO'
);

comment on collation pg_catalog."nn-NO-x-icu"
is 'Norwegian Nynorsk (Norway)';

create collation if not exists pg_catalog."nnh-x-icu" (
  locale = 'nnh'
);

comment on collation pg_catalog."nnh-x-icu"
is 'Ngiemboon';

create collation if not exists pg_catalog."nnh-CM-x-icu" (
  locale = 'nnh_CM'
);

comment on collation pg_catalog."nnh-CM-x-icu"
is 'Ngiemboon (Cameroon)';

create collation if not exists pg_catalog."nus-x-icu" (
  locale = 'nus'
);

comment on collation pg_catalog."nus-x-icu"
is 'Nuer';

create collation if not exists pg_catalog."nus-SD-x-icu" (
  locale = 'nus_SD'
);

comment on collation pg_catalog."nus-SD-x-icu"
is 'Nuer (Sudan)';

create collation if not exists pg_catalog."nyn-x-icu" (
  locale = 'nyn'
);

comment on collation pg_catalog."nyn-x-icu"
is 'Nyankole';

create collation if not exists pg_catalog."nyn-UG-x-icu" (
  locale = 'nyn_UG'
);

comment on collation pg_catalog."nyn-UG-x-icu"
is 'Nyankole (Uganda)';

create collation if not exists pg_catalog."om-x-icu" (
  locale = 'om'
);

comment on collation pg_catalog."om-x-icu"
is 'Oromo';

create collation if not exists pg_catalog."om-ET-x-icu" (
  locale = 'om_ET'
);

comment on collation pg_catalog."om-ET-x-icu"
is 'Oromo (Ethiopia)';

create collation if not exists pg_catalog."om-KE-x-icu" (
  locale = 'om_KE'
);

comment on collation pg_catalog."om-KE-x-icu"
is 'Oromo (Kenya)';

create collation if not exists pg_catalog."or-x-icu" (
  locale = 'or'
);

comment on collation pg_catalog."or-x-icu"
is 'Oriya';

create collation if not exists pg_catalog."or-IN-x-icu" (
  locale = 'or_IN'
);

comment on collation pg_catalog."or-IN-x-icu"
is 'Oriya (India)';

create collation if not exists pg_catalog."pa-x-icu" (
  locale = 'pa'
);

comment on collation pg_catalog."pa-x-icu"
is 'Punjabi';

create collation if not exists pg_catalog."pa-Arab-x-icu" (
  locale = 'pa_Arab'
);

comment on collation pg_catalog."pa-Arab-x-icu"
is 'Punjabi (Arabic)';

create collation if not exists pg_catalog."pa-Arab-PK-x-icu" (
  locale = 'pa_Arab_PK'
);

comment on collation pg_catalog."pa-Arab-PK-x-icu"
is 'Punjabi (Arabic, Pakistan)';

create collation if not exists pg_catalog."pa-Guru-x-icu" (
  locale = 'pa_Guru'
);

comment on collation pg_catalog."pa-Guru-x-icu"
is 'Punjabi (Gurmukhi)';

create collation if not exists pg_catalog."pa-Guru-IN-x-icu" (
  locale = 'pa_Guru_IN'
);

comment on collation pg_catalog."pa-Guru-IN-x-icu"
is 'Punjabi (Gurmukhi, India)';

create collation if not exists pg_catalog."pl-x-icu" (
  locale = 'pl'
);

comment on collation pg_catalog."pl-x-icu"
is 'Polish';

create collation if not exists pg_catalog."pl-PL-x-icu" (
  locale = 'pl_PL'
);

comment on collation pg_catalog."pl-PL-x-icu"
is 'Polish (Poland)';

create collation if not exists pg_catalog."ps-x-icu" (
  locale = 'ps'
);

comment on collation pg_catalog."ps-x-icu"
is 'Pashto';

create collation if not exists pg_catalog."ps-AF-x-icu" (
  locale = 'ps_AF'
);

comment on collation pg_catalog."ps-AF-x-icu"
is 'Pashto (Afghanistan)';

create collation if not exists pg_catalog."pt-x-icu" (
  locale = 'pt'
);

comment on collation pg_catalog."pt-x-icu"
is 'Portuguese';

create collation if not exists pg_catalog."pt-AO-x-icu" (
  locale = 'pt_AO'
);

comment on collation pg_catalog."pt-AO-x-icu"
is 'Portuguese (Angola)';

create collation if not exists pg_catalog."pt-BR-x-icu" (
  locale = 'pt_BR'
);

comment on collation pg_catalog."pt-BR-x-icu"
is 'Portuguese (Brazil)';

create collation if not exists pg_catalog."pt-CV-x-icu" (
  locale = 'pt_CV'
);

comment on collation pg_catalog."pt-CV-x-icu"
is 'Portuguese (Cape Verde)';

create collation if not exists pg_catalog."pt-GW-x-icu" (
  locale = 'pt_GW'
);

comment on collation pg_catalog."pt-GW-x-icu"
is 'Portuguese (Guinea-Bissau)';

create collation if not exists pg_catalog."pt-MO-x-icu" (
  locale = 'pt_MO'
);

comment on collation pg_catalog."pt-MO-x-icu"
is 'Portuguese (Macau SAR China)';

create collation if not exists pg_catalog."pt-MZ-x-icu" (
  locale = 'pt_MZ'
);

comment on collation pg_catalog."pt-MZ-x-icu"
is 'Portuguese (Mozambique)';

create collation if not exists pg_catalog."pt-PT-x-icu" (
  locale = 'pt_PT'
);

comment on collation pg_catalog."pt-PT-x-icu"
is 'Portuguese (Portugal)';

create collation if not exists pg_catalog."pt-ST-x-icu" (
  locale = 'pt_ST'
);

create collation if not exists pg_catalog."pt-TL-x-icu" (
  locale = 'pt_TL'
);

comment on collation pg_catalog."pt-TL-x-icu"
is 'Portuguese (Timor-Leste)';

create collation if not exists pg_catalog."rm-x-icu" (
  locale = 'rm'
);

comment on collation pg_catalog."rm-x-icu"
is 'Romansh';

create collation if not exists pg_catalog."rm-CH-x-icu" (
  locale = 'rm_CH'
);

comment on collation pg_catalog."rm-CH-x-icu"
is 'Romansh (Switzerland)';

create collation if not exists pg_catalog."rn-x-icu" (
  locale = 'rn'
);

comment on collation pg_catalog."rn-x-icu"
is 'Rundi';

create collation if not exists pg_catalog."rn-BI-x-icu" (
  locale = 'rn_BI'
);

comment on collation pg_catalog."rn-BI-x-icu"
is 'Rundi (Burundi)';

create collation if not exists pg_catalog."ro-x-icu" (
  locale = 'ro'
);

comment on collation pg_catalog."ro-x-icu"
is 'Romanian';

create collation if not exists pg_catalog."ro-MD-x-icu" (
  locale = 'ro_MD'
);

comment on collation pg_catalog."ro-MD-x-icu"
is 'Romanian (Moldova)';

create collation if not exists pg_catalog."ro-RO-x-icu" (
  locale = 'ro_RO'
);

comment on collation pg_catalog."ro-RO-x-icu"
is 'Romanian (Romania)';

create collation if not exists pg_catalog."rof-x-icu" (
  locale = 'rof'
);

comment on collation pg_catalog."rof-x-icu"
is 'Rombo';

create collation if not exists pg_catalog."rof-TZ-x-icu" (
  locale = 'rof_TZ'
);

comment on collation pg_catalog."rof-TZ-x-icu"
is 'Rombo (Tanzania)';

create collation if not exists pg_catalog."ru-x-icu" (
  locale = 'ru'
);

comment on collation pg_catalog."ru-x-icu"
is 'Russian';

create collation if not exists pg_catalog."ru-BY-x-icu" (
  locale = 'ru_BY'
);

comment on collation pg_catalog."ru-BY-x-icu"
is 'Russian (Belarus)';

create collation if not exists pg_catalog."ru-KG-x-icu" (
  locale = 'ru_KG'
);

comment on collation pg_catalog."ru-KG-x-icu"
is 'Russian (Kyrgyzstan)';

create collation if not exists pg_catalog."ru-KZ-x-icu" (
  locale = 'ru_KZ'
);

comment on collation pg_catalog."ru-KZ-x-icu"
is 'Russian (Kazakhstan)';

create collation if not exists pg_catalog."ru-MD-x-icu" (
  locale = 'ru_MD'
);

comment on collation pg_catalog."ru-MD-x-icu"
is 'Russian (Moldova)';

create collation if not exists pg_catalog."ru-RU-x-icu" (
  locale = 'ru_RU'
);

comment on collation pg_catalog."ru-RU-x-icu"
is 'Russian (Russia)';

create collation if not exists pg_catalog."ru-UA-x-icu" (
  locale = 'ru_UA'
);

comment on collation pg_catalog."ru-UA-x-icu"
is 'Russian (Ukraine)';

create collation if not exists pg_catalog."rw-x-icu" (
  locale = 'rw'
);

comment on collation pg_catalog."rw-x-icu"
is 'Kinyarwanda';

create collation if not exists pg_catalog."rw-RW-x-icu" (
  locale = 'rw_RW'
);

comment on collation pg_catalog."rw-RW-x-icu"
is 'Kinyarwanda (Rwanda)';

create collation if not exists pg_catalog."rwk-x-icu" (
  locale = 'rwk'
);

comment on collation pg_catalog."rwk-x-icu"
is 'Rwa';

create collation if not exists pg_catalog."rwk-TZ-x-icu" (
  locale = 'rwk_TZ'
);

comment on collation pg_catalog."rwk-TZ-x-icu"
is 'Rwa (Tanzania)';

create collation if not exists pg_catalog."saq-x-icu" (
  locale = 'saq'
);

comment on collation pg_catalog."saq-x-icu"
is 'Samburu';

create collation if not exists pg_catalog."saq-KE-x-icu" (
  locale = 'saq_KE'
);

comment on collation pg_catalog."saq-KE-x-icu"
is 'Samburu (Kenya)';

create collation if not exists pg_catalog."sbp-x-icu" (
  locale = 'sbp'
);

comment on collation pg_catalog."sbp-x-icu"
is 'Sangu';

create collation if not exists pg_catalog."sbp-TZ-x-icu" (
  locale = 'sbp_TZ'
);

comment on collation pg_catalog."sbp-TZ-x-icu"
is 'Sangu (Tanzania)';

create collation if not exists pg_catalog."seh-x-icu" (
  locale = 'seh'
);

comment on collation pg_catalog."seh-x-icu"
is 'Sena';

create collation if not exists pg_catalog."seh-MZ-x-icu" (
  locale = 'seh_MZ'
);

comment on collation pg_catalog."seh-MZ-x-icu"
is 'Sena (Mozambique)';

create collation if not exists pg_catalog."ses-x-icu" (
  locale = 'ses'
);

comment on collation pg_catalog."ses-x-icu"
is 'Koyraboro Senni';

create collation if not exists pg_catalog."ses-ML-x-icu" (
  locale = 'ses_ML'
);

comment on collation pg_catalog."ses-ML-x-icu"
is 'Koyraboro Senni (Mali)';

create collation if not exists pg_catalog."sg-x-icu" (
  locale = 'sg'
);

comment on collation pg_catalog."sg-x-icu"
is 'Sango';

create collation if not exists pg_catalog."sg-CF-x-icu" (
  locale = 'sg_CF'
);

comment on collation pg_catalog."sg-CF-x-icu"
is 'Sango (Central African Republic)';

create collation if not exists pg_catalog."shi-x-icu" (
  locale = 'shi'
);

comment on collation pg_catalog."shi-x-icu"
is 'Tachelhit';

create collation if not exists pg_catalog."shi-Latn-x-icu" (
  locale = 'shi_Latn'
);

comment on collation pg_catalog."shi-Latn-x-icu"
is 'Tachelhit (Latin)';

create collation if not exists pg_catalog."shi-Latn-MA-x-icu" (
  locale = 'shi_Latn_MA'
);

comment on collation pg_catalog."shi-Latn-MA-x-icu"
is 'Tachelhit (Latin, Morocco)';

create collation if not exists pg_catalog."shi-Tfng-x-icu" (
  locale = 'shi_Tfng'
);

comment on collation pg_catalog."shi-Tfng-x-icu"
is 'Tachelhit (Tifinagh)';

create collation if not exists pg_catalog."shi-Tfng-MA-x-icu" (
  locale = 'shi_Tfng_MA'
);

comment on collation pg_catalog."shi-Tfng-MA-x-icu"
is 'Tachelhit (Tifinagh, Morocco)';

create collation if not exists pg_catalog."si-x-icu" (
  locale = 'si'
);

comment on collation pg_catalog."si-x-icu"
is 'Sinhala';

create collation if not exists pg_catalog."si-LK-x-icu" (
  locale = 'si_LK'
);

comment on collation pg_catalog."si-LK-x-icu"
is 'Sinhala (Sri Lanka)';

create collation if not exists pg_catalog."sk-x-icu" (
  locale = 'sk'
);

comment on collation pg_catalog."sk-x-icu"
is 'Slovak';

create collation if not exists pg_catalog."sk-SK-x-icu" (
  locale = 'sk_SK'
);

comment on collation pg_catalog."sk-SK-x-icu"
is 'Slovak (Slovakia)';

create collation if not exists pg_catalog."sl-x-icu" (
  locale = 'sl'
);

comment on collation pg_catalog."sl-x-icu"
is 'Slovenian';

create collation if not exists pg_catalog."sl-SI-x-icu" (
  locale = 'sl_SI'
);

comment on collation pg_catalog."sl-SI-x-icu"
is 'Slovenian (Slovenia)';

create collation if not exists pg_catalog."sn-x-icu" (
  locale = 'sn'
);

comment on collation pg_catalog."sn-x-icu"
is 'Shona';

create collation if not exists pg_catalog."sn-ZW-x-icu" (
  locale = 'sn_ZW'
);

comment on collation pg_catalog."sn-ZW-x-icu"
is 'Shona (Zimbabwe)';

create collation if not exists pg_catalog."so-x-icu" (
  locale = 'so'
);

comment on collation pg_catalog."so-x-icu"
is 'Somali';

create collation if not exists pg_catalog."so-DJ-x-icu" (
  locale = 'so_DJ'
);

comment on collation pg_catalog."so-DJ-x-icu"
is 'Somali (Djibouti)';

create collation if not exists pg_catalog."so-ET-x-icu" (
  locale = 'so_ET'
);

comment on collation pg_catalog."so-ET-x-icu"
is 'Somali (Ethiopia)';

create collation if not exists pg_catalog."so-KE-x-icu" (
  locale = 'so_KE'
);

comment on collation pg_catalog."so-KE-x-icu"
is 'Somali (Kenya)';

create collation if not exists pg_catalog."so-SO-x-icu" (
  locale = 'so_SO'
);

comment on collation pg_catalog."so-SO-x-icu"
is 'Somali (Somalia)';

create collation if not exists pg_catalog."sq-x-icu" (
  locale = 'sq'
);

comment on collation pg_catalog."sq-x-icu"
is 'Albanian';

create collation if not exists pg_catalog."sq-AL-x-icu" (
  locale = 'sq_AL'
);

comment on collation pg_catalog."sq-AL-x-icu"
is 'Albanian (Albania)';

create collation if not exists pg_catalog."sq-MK-x-icu" (
  locale = 'sq_MK'
);

comment on collation pg_catalog."sq-MK-x-icu"
is 'Albanian (Macedonia)';

create collation if not exists pg_catalog."sq-XK-x-icu" (
  locale = 'sq_XK'
);

comment on collation pg_catalog."sq-XK-x-icu"
is 'Albanian (Kosovo)';

create collation if not exists pg_catalog."sr-x-icu" (
  locale = 'sr'
);

comment on collation pg_catalog."sr-x-icu"
is 'Serbian';

create collation if not exists pg_catalog."sr-Cyrl-x-icu" (
  locale = 'sr_Cyrl'
);

comment on collation pg_catalog."sr-Cyrl-x-icu"
is 'Serbian (Cyrillic)';

create collation if not exists pg_catalog."sr-Cyrl-BA-x-icu" (
  locale = 'sr_Cyrl_BA'
);

comment on collation pg_catalog."sr-Cyrl-BA-x-icu"
is 'Serbian (Cyrillic, Bosnia and Herzegovina)';

create collation if not exists pg_catalog."sr-Cyrl-ME-x-icu" (
  locale = 'sr_Cyrl_ME'
);

comment on collation pg_catalog."sr-Cyrl-ME-x-icu"
is 'Serbian (Cyrillic, Montenegro)';

create collation if not exists pg_catalog."sr-Cyrl-RS-x-icu" (
  locale = 'sr_Cyrl_RS'
);

comment on collation pg_catalog."sr-Cyrl-RS-x-icu"
is 'Serbian (Cyrillic, Serbia)';

create collation if not exists pg_catalog."sr-Cyrl-XK-x-icu" (
  locale = 'sr_Cyrl_XK'
);

comment on collation pg_catalog."sr-Cyrl-XK-x-icu"
is 'Serbian (Cyrillic, Kosovo)';

create collation if not exists pg_catalog."sr-Latn-x-icu" (
  locale = 'sr_Latn'
);

comment on collation pg_catalog."sr-Latn-x-icu"
is 'Serbian (Latin)';

create collation if not exists pg_catalog."sr-Latn-BA-x-icu" (
  locale = 'sr_Latn_BA'
);

comment on collation pg_catalog."sr-Latn-BA-x-icu"
is 'Serbian (Latin, Bosnia and Herzegovina)';

create collation if not exists pg_catalog."sr-Latn-ME-x-icu" (
  locale = 'sr_Latn_ME'
);

comment on collation pg_catalog."sr-Latn-ME-x-icu"
is 'Serbian (Latin, Montenegro)';

create collation if not exists pg_catalog."sr-Latn-RS-x-icu" (
  locale = 'sr_Latn_RS'
);

comment on collation pg_catalog."sr-Latn-RS-x-icu"
is 'Serbian (Latin, Serbia)';

create collation if not exists pg_catalog."sr-Latn-XK-x-icu" (
  locale = 'sr_Latn_XK'
);

comment on collation pg_catalog."sr-Latn-XK-x-icu"
is 'Serbian (Latin, Kosovo)';

create collation if not exists pg_catalog."sv-x-icu" (
  locale = 'sv'
);

comment on collation pg_catalog."sv-x-icu"
is 'Swedish';

create collation if not exists pg_catalog."sv-AX-x-icu" (
  locale = 'sv_AX'
);

create collation if not exists pg_catalog."sv-FI-x-icu" (
  locale = 'sv_FI'
);

comment on collation pg_catalog."sv-FI-x-icu"
is 'Swedish (Finland)';

create collation if not exists pg_catalog."sv-SE-x-icu" (
  locale = 'sv_SE'
);

comment on collation pg_catalog."sv-SE-x-icu"
is 'Swedish (Sweden)';

create collation if not exists pg_catalog."sw-x-icu" (
  locale = 'sw'
);

comment on collation pg_catalog."sw-x-icu"
is 'Swahili';

create collation if not exists pg_catalog."sw-KE-x-icu" (
  locale = 'sw_KE'
);

comment on collation pg_catalog."sw-KE-x-icu"
is 'Swahili (Kenya)';

create collation if not exists pg_catalog."sw-TZ-x-icu" (
  locale = 'sw_TZ'
);

comment on collation pg_catalog."sw-TZ-x-icu"
is 'Swahili (Tanzania)';

create collation if not exists pg_catalog."sw-UG-x-icu" (
  locale = 'sw_UG'
);

comment on collation pg_catalog."sw-UG-x-icu"
is 'Swahili (Uganda)';

create collation if not exists pg_catalog."swc-x-icu" (
  locale = 'swc'
);

comment on collation pg_catalog."swc-x-icu"
is 'Congo Swahili';

create collation if not exists pg_catalog."swc-CD-x-icu" (
  locale = 'swc_CD'
);

comment on collation pg_catalog."swc-CD-x-icu"
is 'Congo Swahili (Congo - Kinshasa)';

create collation if not exists pg_catalog."ta-x-icu" (
  locale = 'ta'
);

comment on collation pg_catalog."ta-x-icu"
is 'Tamil';

create collation if not exists pg_catalog."ta-IN-x-icu" (
  locale = 'ta_IN'
);

comment on collation pg_catalog."ta-IN-x-icu"
is 'Tamil (India)';

create collation if not exists pg_catalog."ta-LK-x-icu" (
  locale = 'ta_LK'
);

comment on collation pg_catalog."ta-LK-x-icu"
is 'Tamil (Sri Lanka)';

create collation if not exists pg_catalog."ta-MY-x-icu" (
  locale = 'ta_MY'
);

comment on collation pg_catalog."ta-MY-x-icu"
is 'Tamil (Malaysia)';

create collation if not exists pg_catalog."ta-SG-x-icu" (
  locale = 'ta_SG'
);

comment on collation pg_catalog."ta-SG-x-icu"
is 'Tamil (Singapore)';

create collation if not exists pg_catalog."te-x-icu" (
  locale = 'te'
);

comment on collation pg_catalog."te-x-icu"
is 'Telugu';

create collation if not exists pg_catalog."te-IN-x-icu" (
  locale = 'te_IN'
);

comment on collation pg_catalog."te-IN-x-icu"
is 'Telugu (India)';

create collation if not exists pg_catalog."teo-x-icu" (
  locale = 'teo'
);

comment on collation pg_catalog."teo-x-icu"
is 'Teso';

create collation if not exists pg_catalog."teo-KE-x-icu" (
  locale = 'teo_KE'
);

comment on collation pg_catalog."teo-KE-x-icu"
is 'Teso (Kenya)';

create collation if not exists pg_catalog."teo-UG-x-icu" (
  locale = 'teo_UG'
);

comment on collation pg_catalog."teo-UG-x-icu"
is 'Teso (Uganda)';

create collation if not exists pg_catalog."th-x-icu" (
  locale = 'th'
);

comment on collation pg_catalog."th-x-icu"
is 'Thai';

create collation if not exists pg_catalog."th-TH-x-icu" (
  locale = 'th_TH'
);

comment on collation pg_catalog."th-TH-x-icu"
is 'Thai (Thailand)';

create collation if not exists pg_catalog."ti-x-icu" (
  locale = 'ti'
);

comment on collation pg_catalog."ti-x-icu"
is 'Tigrinya';

create collation if not exists pg_catalog."ti-ER-x-icu" (
  locale = 'ti_ER'
);

comment on collation pg_catalog."ti-ER-x-icu"
is 'Tigrinya (Eritrea)';

create collation if not exists pg_catalog."ti-ET-x-icu" (
  locale = 'ti_ET'
);

comment on collation pg_catalog."ti-ET-x-icu"
is 'Tigrinya (Ethiopia)';

create collation if not exists pg_catalog."to-x-icu" (
  locale = 'to'
);

comment on collation pg_catalog."to-x-icu"
is 'Tongan';

create collation if not exists pg_catalog."to-TO-x-icu" (
  locale = 'to_TO'
);

comment on collation pg_catalog."to-TO-x-icu"
is 'Tongan (Tonga)';

create collation if not exists pg_catalog."tr-x-icu" (
  locale = 'tr'
);

comment on collation pg_catalog."tr-x-icu"
is 'Turkish';

create collation if not exists pg_catalog."tr-CY-x-icu" (
  locale = 'tr_CY'
);

comment on collation pg_catalog."tr-CY-x-icu"
is 'Turkish (Cyprus)';

create collation if not exists pg_catalog."tr-TR-x-icu" (
  locale = 'tr_TR'
);

comment on collation pg_catalog."tr-TR-x-icu"
is 'Turkish (Turkey)';

create collation if not exists pg_catalog."twq-x-icu" (
  locale = 'twq'
);

comment on collation pg_catalog."twq-x-icu"
is 'Tasawaq';

create collation if not exists pg_catalog."twq-NE-x-icu" (
  locale = 'twq_NE'
);

comment on collation pg_catalog."twq-NE-x-icu"
is 'Tasawaq (Niger)';

create collation if not exists pg_catalog."tzm-x-icu" (
  locale = 'tzm'
);

comment on collation pg_catalog."tzm-x-icu"
is 'Central Atlas Tamazight';

create collation if not exists pg_catalog."tzm-Latn-x-icu" (
  locale = 'tzm_Latn'
);

comment on collation pg_catalog."tzm-Latn-x-icu"
is 'Central Atlas Tamazight (Latin)';

create collation if not exists pg_catalog."tzm-Latn-MA-x-icu" (
  locale = 'tzm_Latn_MA'
);

comment on collation pg_catalog."tzm-Latn-MA-x-icu"
is 'Central Atlas Tamazight (Latin, Morocco)';

create collation if not exists pg_catalog."ug-x-icu" (
  locale = 'ug'
);

comment on collation pg_catalog."ug-x-icu"
is 'Uyghur';

create collation if not exists pg_catalog."ug-Arab-x-icu" (
  locale = 'ug_Arab'
);

comment on collation pg_catalog."ug-Arab-x-icu"
is 'Uyghur (Arabic)';

create collation if not exists pg_catalog."ug-Arab-CN-x-icu" (
  locale = 'ug_Arab_CN'
);

comment on collation pg_catalog."ug-Arab-CN-x-icu"
is 'Uyghur (Arabic, China)';

create collation if not exists pg_catalog."uk-x-icu" (
  locale = 'uk'
);

comment on collation pg_catalog."uk-x-icu"
is 'Ukrainian';

create collation if not exists pg_catalog."uk-UA-x-icu" (
  locale = 'uk_UA'
);

comment on collation pg_catalog."uk-UA-x-icu"
is 'Ukrainian (Ukraine)';

create collation if not exists pg_catalog."ur-x-icu" (
  locale = 'ur'
);

comment on collation pg_catalog."ur-x-icu"
is 'Urdu';

create collation if not exists pg_catalog."ur-IN-x-icu" (
  locale = 'ur_IN'
);

comment on collation pg_catalog."ur-IN-x-icu"
is 'Urdu (India)';

create collation if not exists pg_catalog."ur-PK-x-icu" (
  locale = 'ur_PK'
);

comment on collation pg_catalog."ur-PK-x-icu"
is 'Urdu (Pakistan)';

create collation if not exists pg_catalog."uz-x-icu" (
  locale = 'uz'
);

comment on collation pg_catalog."uz-x-icu"
is 'Uzbek';

create collation if not exists pg_catalog."uz-Arab-x-icu" (
  locale = 'uz_Arab'
);

comment on collation pg_catalog."uz-Arab-x-icu"
is 'Uzbek (Arabic)';

create collation if not exists pg_catalog."uz-Arab-AF-x-icu" (
  locale = 'uz_Arab_AF'
);

comment on collation pg_catalog."uz-Arab-AF-x-icu"
is 'Uzbek (Arabic, Afghanistan)';

create collation if not exists pg_catalog."uz-Cyrl-x-icu" (
  locale = 'uz_Cyrl'
);

comment on collation pg_catalog."uz-Cyrl-x-icu"
is 'Uzbek (Cyrillic)';

create collation if not exists pg_catalog."uz-Cyrl-UZ-x-icu" (
  locale = 'uz_Cyrl_UZ'
);

comment on collation pg_catalog."uz-Cyrl-UZ-x-icu"
is 'Uzbek (Cyrillic, Uzbekistan)';

create collation if not exists pg_catalog."uz-Latn-x-icu" (
  locale = 'uz_Latn'
);

comment on collation pg_catalog."uz-Latn-x-icu"
is 'Uzbek (Latin)';

create collation if not exists pg_catalog."uz-Latn-UZ-x-icu" (
  locale = 'uz_Latn_UZ'
);

comment on collation pg_catalog."uz-Latn-UZ-x-icu"
is 'Uzbek (Latin, Uzbekistan)';

create collation if not exists pg_catalog."vai-x-icu" (
  locale = 'vai'
);

comment on collation pg_catalog."vai-x-icu"
is 'Vai';

create collation if not exists pg_catalog."vai-Latn-x-icu" (
  locale = 'vai_Latn'
);

comment on collation pg_catalog."vai-Latn-x-icu"
is 'Vai (Latin)';

create collation if not exists pg_catalog."vai-Latn-LR-x-icu" (
  locale = 'vai_Latn_LR'
);

comment on collation pg_catalog."vai-Latn-LR-x-icu"
is 'Vai (Latin, Liberia)';

create collation if not exists pg_catalog."vai-Vaii-x-icu" (
  locale = 'vai_Vaii'
);

comment on collation pg_catalog."vai-Vaii-x-icu"
is 'Vai (Vai)';

create collation if not exists pg_catalog."vai-Vaii-LR-x-icu" (
  locale = 'vai_Vaii_LR'
);

comment on collation pg_catalog."vai-Vaii-LR-x-icu"
is 'Vai (Vai, Liberia)';

create collation if not exists pg_catalog."vi-x-icu" (
  locale = 'vi'
);

comment on collation pg_catalog."vi-x-icu"
is 'Vietnamese';

create collation if not exists pg_catalog."vi-VN-x-icu" (
  locale = 'vi_VN'
);

comment on collation pg_catalog."vi-VN-x-icu"
is 'Vietnamese (Vietnam)';

create collation if not exists pg_catalog."vun-x-icu" (
  locale = 'vun'
);

comment on collation pg_catalog."vun-x-icu"
is 'Vunjo';

create collation if not exists pg_catalog."vun-TZ-x-icu" (
  locale = 'vun_TZ'
);

comment on collation pg_catalog."vun-TZ-x-icu"
is 'Vunjo (Tanzania)';

create collation if not exists pg_catalog."xog-x-icu" (
  locale = 'xog'
);

comment on collation pg_catalog."xog-x-icu"
is 'Soga';

create collation if not exists pg_catalog."xog-UG-x-icu" (
  locale = 'xog_UG'
);

comment on collation pg_catalog."xog-UG-x-icu"
is 'Soga (Uganda)';

create collation if not exists pg_catalog."yav-x-icu" (
  locale = 'yav'
);

comment on collation pg_catalog."yav-x-icu"
is 'Yangben';

create collation if not exists pg_catalog."yav-CM-x-icu" (
  locale = 'yav_CM'
);

comment on collation pg_catalog."yav-CM-x-icu"
is 'Yangben (Cameroon)';

create collation if not exists pg_catalog."yo-x-icu" (
  locale = 'yo'
);

comment on collation pg_catalog."yo-x-icu"
is 'Yoruba';

create collation if not exists pg_catalog."yo-BJ-x-icu" (
  locale = 'yo_BJ'
);

comment on collation pg_catalog."yo-BJ-x-icu"
is 'Yoruba (Benin)';

create collation if not exists pg_catalog."yo-NG-x-icu" (
  locale = 'yo_NG'
);

comment on collation pg_catalog."yo-NG-x-icu"
is 'Yoruba (Nigeria)';

create collation if not exists pg_catalog."zgh-x-icu" (
  locale = 'zgh'
);

comment on collation pg_catalog."zgh-x-icu"
is 'Standard Moroccan Tamazight';

create collation if not exists pg_catalog."zgh-MA-x-icu" (
  locale = 'zgh_MA'
);

comment on collation pg_catalog."zgh-MA-x-icu"
is 'Standard Moroccan Tamazight (Morocco)';

create collation if not exists pg_catalog."zh-x-icu" (
  locale = 'zh'
);

comment on collation pg_catalog."zh-x-icu"
is 'Chinese';

create collation if not exists pg_catalog."zh-Hans-x-icu" (
  locale = 'zh_Hans'
);

comment on collation pg_catalog."zh-Hans-x-icu"
is 'Chinese (Simplified)';

create collation if not exists pg_catalog."zh-Hans-CN-x-icu" (
  locale = 'zh_Hans_CN'
);

comment on collation pg_catalog."zh-Hans-CN-x-icu"
is 'Chinese (Simplified, China)';

create collation if not exists pg_catalog."zh-Hans-HK-x-icu" (
  locale = 'zh_Hans_HK'
);

comment on collation pg_catalog."zh-Hans-HK-x-icu"
is 'Chinese (Simplified, Hong Kong SAR China)';

create collation if not exists pg_catalog."zh-Hans-MO-x-icu" (
  locale = 'zh_Hans_MO'
);

comment on collation pg_catalog."zh-Hans-MO-x-icu"
is 'Chinese (Simplified, Macau SAR China)';

create collation if not exists pg_catalog."zh-Hans-SG-x-icu" (
  locale = 'zh_Hans_SG'
);

comment on collation pg_catalog."zh-Hans-SG-x-icu"
is 'Chinese (Simplified, Singapore)';

create collation if not exists pg_catalog."zh-Hant-x-icu" (
  locale = 'zh_Hant'
);

comment on collation pg_catalog."zh-Hant-x-icu"
is 'Chinese (Traditional)';

create collation if not exists pg_catalog."zh-Hant-HK-x-icu" (
  locale = 'zh_Hant_HK'
);

comment on collation pg_catalog."zh-Hant-HK-x-icu"
is 'Chinese (Traditional, Hong Kong SAR China)';

create collation if not exists pg_catalog."zh-Hant-MO-x-icu" (
  locale = 'zh_Hant_MO'
);

comment on collation pg_catalog."zh-Hant-MO-x-icu"
is 'Chinese (Traditional, Macau SAR China)';

create collation if not exists pg_catalog."zh-Hant-TW-x-icu" (
  locale = 'zh_Hant_TW'
);

comment on collation pg_catalog."zh-Hant-TW-x-icu"
is 'Chinese (Traditional, Taiwan)';

create collation if not exists pg_catalog."zu-x-icu" (
  locale = 'zu'
);

comment on collation pg_catalog."zu-x-icu"
is 'Zulu';

create collation if not exists pg_catalog."zu-ZA-x-icu" (
  locale = 'zu_ZA'
);

comment on collation pg_catalog."zu-ZA-x-icu"
is 'Zulu (South Africa)';

create aggregate pg_catalog.max(anyarray) (
  sfunc = pg_catalog.array_larger,
  stype = anyarray,
  combinefunc = pg_catalog.array_larger,
  parallel = safe,
  sortop = operator (pg_catalog.>)
);

comment on aggregate pg_catalog.max(anyarray)
is 'maximum value of all anyarray input values';

create aggregate pg_catalog.min(anyarray) (
  sfunc = pg_catalog.array_smaller,
  stype = anyarray,
  combinefunc = pg_catalog.array_smaller,
  parallel = safe,
  sortop = operator (pg_catalog.<)
);

comment on aggregate pg_catalog.min(anyarray)
is 'minimum value of all anyarray input values';

create aggregate pg_catalog.avg(bigint) (
  sfunc = pg_catalog.int8_avg_accum,
  stype = internal,
  sspace = 48,
  finalfunc = pg_catalog.numeric_poly_avg,
  combinefunc = pg_catalog.int8_avg_combine,
  serialfunc = pg_catalog.int8_avg_serialize,
  deserialfunc = pg_catalog.int8_avg_deserialize,
  parallel = safe,
  msfunc = pg_catalog.int8_avg_accum,
  minvfunc = pg_catalog.int8_avg_accum_inv,
  mstype = internal,
  msspace = 48,
  mfinalfunc = pg_catalog.numeric_poly_avg
);

comment on aggregate pg_catalog.avg(bigint)
is 'the average (arithmetic mean) as numeric of all bigint values';

create aggregate pg_catalog.avg(integer) (
  sfunc = pg_catalog.int4_avg_accum,
  stype = bigint [],
  finalfunc = pg_catalog.int8_avg,
  combinefunc = pg_catalog.int4_avg_combine,
  initcond = '{0,0}',
  parallel = safe,
  msfunc = pg_catalog.int4_avg_accum,
  minvfunc = pg_catalog.int4_avg_accum_inv,
  mstype = bigint [],
  mfinalfunc = pg_catalog.int8_avg,
  minitcond = '{0,0}'
);

comment on aggregate pg_catalog.avg(integer)
is 'the average (arithmetic mean) as numeric of all integer values';

create aggregate pg_catalog.avg(smallint) (
  sfunc = pg_catalog.int2_avg_accum,
  stype = bigint [],
  finalfunc = pg_catalog.int8_avg,
  combinefunc = pg_catalog.int4_avg_combine,
  initcond = '{0,0}',
  parallel = safe,
  msfunc = pg_catalog.int2_avg_accum,
  minvfunc = pg_catalog.int2_avg_accum_inv,
  mstype = bigint [],
  mfinalfunc = pg_catalog.int8_avg,
  minitcond = '{0,0}'
);

comment on aggregate pg_catalog.avg(smallint)
is 'the average (arithmetic mean) as numeric of all smallint values';

create aggregate pg_catalog.avg(numeric) (
  sfunc = pg_catalog.numeric_avg_accum,
  stype = internal,
  sspace = 128,
  finalfunc = pg_catalog.numeric_avg,
  combinefunc = pg_catalog.numeric_avg_combine,
  serialfunc = pg_catalog.numeric_avg_serialize,
  deserialfunc = pg_catalog.numeric_avg_deserialize,
  parallel = safe,
  msfunc = pg_catalog.numeric_avg_accum,
  minvfunc = pg_catalog.numeric_accum_inv,
  mstype = internal,
  msspace = 128,
  mfinalfunc = pg_catalog.numeric_avg
);

comment on aggregate pg_catalog.avg(numeric)
is 'the average (arithmetic mean) as numeric of all numeric values';

create aggregate pg_catalog.avg(real) (
  sfunc = pg_catalog.float4_accum,
  stype = double precision [],
  finalfunc = pg_catalog.float8_avg,
  combinefunc = pg_catalog.float8_combine,
  initcond = '{0,0,0}',
  parallel = safe
);

comment on aggregate pg_catalog.avg(real)
is 'the average (arithmetic mean) as float8 of all float4 values';

create aggregate pg_catalog.avg(double precision) (
  sfunc = pg_catalog.float8_accum,
  stype = double precision [],
  finalfunc = pg_catalog.float8_avg,
  combinefunc = pg_catalog.float8_combine,
  initcond = '{0,0,0}',
  parallel = safe
);

comment on aggregate pg_catalog.avg(double precision)
is 'the average (arithmetic mean) as float8 of all float8 values';

create aggregate pg_catalog.avg(interval) (
  sfunc = pg_catalog.interval_accum,
  stype = interval [],
  finalfunc = pg_catalog.interval_avg,
  combinefunc = pg_catalog.interval_combine,
  initcond = '{0 second,0 second}',
  parallel = safe,
  msfunc = pg_catalog.interval_accum,
  minvfunc = pg_catalog.interval_accum_inv,
  mstype = interval [],
  mfinalfunc = pg_catalog.interval_avg,
  minitcond = '{0 second,0 second}'
);

comment on aggregate pg_catalog.avg(interval)
is 'the average (arithmetic mean) as interval of all interval values';

create aggregate pg_catalog.sum(bigint) (
  sfunc = pg_catalog.int8_avg_accum,
  stype = internal,
  sspace = 48,
  finalfunc = pg_catalog.numeric_poly_sum,
  combinefunc = pg_catalog.int8_avg_combine,
  serialfunc = pg_catalog.int8_avg_serialize,
  deserialfunc = pg_catalog.int8_avg_deserialize,
  parallel = safe,
  msfunc = pg_catalog.int8_avg_accum,
  minvfunc = pg_catalog.int8_avg_accum_inv,
  mstype = internal,
  msspace = 48,
  mfinalfunc = pg_catalog.numeric_poly_sum
);

comment on aggregate pg_catalog.sum(bigint)
is 'sum as numeric across all bigint input values';

create aggregate pg_catalog.sum(integer) (
  sfunc = pg_catalog.int4_sum,
  stype = bigint,
  combinefunc = pg_catalog.int8pl,
  parallel = safe,
  msfunc = pg_catalog.int4_avg_accum,
  minvfunc = pg_catalog.int4_avg_accum_inv,
  mstype = bigint [],
  mfinalfunc = pg_catalog.int2int4_sum,
  minitcond = '{0,0}'
);

comment on aggregate pg_catalog.sum(integer)
is 'sum as bigint across all integer input values';

create aggregate pg_catalog.sum(smallint) (
  sfunc = pg_catalog.int2_sum,
  stype = bigint,
  combinefunc = pg_catalog.int8pl,
  parallel = safe,
  msfunc = pg_catalog.int2_avg_accum,
  minvfunc = pg_catalog.int2_avg_accum_inv,
  mstype = bigint [],
  mfinalfunc = pg_catalog.int2int4_sum,
  minitcond = '{0,0}'
);

comment on aggregate pg_catalog.sum(smallint)
is 'sum as bigint across all smallint input values';

create aggregate pg_catalog.sum(real) (
  sfunc = pg_catalog.float4pl,
  stype = real,
  combinefunc = pg_catalog.float4pl,
  parallel = safe
);

comment on aggregate pg_catalog.sum(real)
is 'sum as float4 across all float4 input values';

create aggregate pg_catalog.sum(double precision) (
  sfunc = pg_catalog.float8pl,
  stype = double precision,
  combinefunc = pg_catalog.float8pl,
  parallel = safe
);

comment on aggregate pg_catalog.sum(double precision)
is 'sum as float8 across all float8 input values';

create aggregate pg_catalog.sum(money) (
  sfunc = pg_catalog.cash_pl,
  stype = money,
  combinefunc = pg_catalog.cash_pl,
  parallel = safe,
  msfunc = pg_catalog.cash_pl,
  minvfunc = pg_catalog.cash_mi,
  mstype = money
);

comment on aggregate pg_catalog.sum(money)
is 'sum as money across all money input values';

create aggregate pg_catalog.sum(interval) (
  sfunc = pg_catalog.interval_pl,
  stype = interval,
  combinefunc = pg_catalog.interval_pl,
  parallel = safe,
  msfunc = pg_catalog.interval_pl,
  minvfunc = pg_catalog.interval_mi,
  mstype = interval
);

comment on aggregate pg_catalog.sum(interval)
is 'sum as interval across all interval input values';

create aggregate pg_catalog.sum(numeric) (
  sfunc = pg_catalog.numeric_avg_accum,
  stype = internal,
  sspace = 128,
  finalfunc = pg_catalog.numeric_sum,
  combinefunc = pg_catalog.numeric_avg_combine,
  serialfunc = pg_catalog.numeric_avg_serialize,
  deserialfunc = pg_catalog.numeric_avg_deserialize,
  parallel = safe,
  msfunc = pg_catalog.numeric_avg_accum,
  minvfunc = pg_catalog.numeric_accum_inv,
  mstype = internal,
  msspace = 128,
  mfinalfunc = pg_catalog.numeric_sum
);

comment on aggregate pg_catalog.sum(numeric)
is 'sum as numeric across all numeric input values';

create aggregate pg_catalog.max(bigint) (
  sfunc = pg_catalog.int8larger,
  stype = bigint,
  combinefunc = pg_catalog.int8larger,
  parallel = safe,
  sortop = operator (pg_catalog.>)
);

comment on aggregate pg_catalog.max(bigint)
is 'maximum value of all bigint input values';

create aggregate pg_catalog.max(integer) (
  sfunc = pg_catalog.int4larger,
  stype = integer,
  combinefunc = pg_catalog.int4larger,
  parallel = safe,
  sortop = operator (pg_catalog.>)
);

comment on aggregate pg_catalog.max(integer)
is 'maximum value of all integer input values';

create aggregate pg_catalog.max(smallint) (
  sfunc = pg_catalog.int2larger,
  stype = smallint,
  combinefunc = pg_catalog.int2larger,
  parallel = safe,
  sortop = operator (pg_catalog.>)
);

comment on aggregate pg_catalog.max(smallint)
is 'maximum value of all smallint input values';

create aggregate pg_catalog.max(oid) (
  sfunc = pg_catalog.oidlarger,
  stype = oid,
  combinefunc = pg_catalog.oidlarger,
  parallel = safe,
  sortop = operator (pg_catalog.>)
);

comment on aggregate pg_catalog.max(oid)
is 'maximum value of all oid input values';

create aggregate pg_catalog.max(real) (
  sfunc = pg_catalog.float4larger,
  stype = real,
  combinefunc = pg_catalog.float4larger,
  parallel = safe,
  sortop = operator (pg_catalog.>)
);

comment on aggregate pg_catalog.max(real)
is 'maximum value of all float4 input values';

create aggregate pg_catalog.max(double precision) (
  sfunc = pg_catalog.float8larger,
  stype = double precision,
  combinefunc = pg_catalog.float8larger,
  parallel = safe,
  sortop = operator (pg_catalog.>)
);

comment on aggregate pg_catalog.max(double precision)
is 'maximum value of all float8 input values';

create aggregate pg_catalog.max(abstime) (
  sfunc = pg_catalog.int4larger,
  stype = abstime,
  combinefunc = pg_catalog.int4larger,
  parallel = safe,
  sortop = operator (pg_catalog.>)
);

comment on aggregate pg_catalog.max(abstime)
is 'maximum value of all abstime input values';

create aggregate pg_catalog.max(date) (
  sfunc = pg_catalog.date_larger,
  stype = date,
  combinefunc = pg_catalog.date_larger,
  parallel = safe,
  sortop = operator (pg_catalog.>)
);

comment on aggregate pg_catalog.max(date)
is 'maximum value of all date input values';

create aggregate pg_catalog.max(time) (
  sfunc = pg_catalog.time_larger,
  stype = time,
  combinefunc = pg_catalog.time_larger,
  parallel = safe,
  sortop = operator (pg_catalog.>)
);

comment on aggregate pg_catalog.max(time)
is 'maximum value of all time input values';

create aggregate pg_catalog.max(time with time zone) (
  sfunc = pg_catalog.timetz_larger,
  stype = time with time zone,
  combinefunc = pg_catalog.timetz_larger,
  parallel = safe,
  sortop = operator (pg_catalog.>)
);

comment on aggregate pg_catalog.max(time with time zone)
is 'maximum value of all time with time zone input values';

create aggregate pg_catalog.max(money) (
  sfunc = pg_catalog.cashlarger,
  stype = money,
  combinefunc = pg_catalog.cashlarger,
  parallel = safe,
  sortop = operator (pg_catalog.>)
);

comment on aggregate pg_catalog.max(money)
is 'maximum value of all money input values';

create aggregate pg_catalog.max(timestamp) (
  sfunc = pg_catalog.timestamp_larger,
  stype = timestamp,
  combinefunc = pg_catalog.timestamp_larger,
  parallel = safe,
  sortop = operator (pg_catalog.>)
);

comment on aggregate pg_catalog.max(timestamp)
is 'maximum value of all timestamp input values';

create aggregate pg_catalog.max(timestamp with time zone) (
  sfunc = pg_catalog.timestamptz_larger,
  stype = timestamp with time zone,
  combinefunc = pg_catalog.timestamptz_larger,
  parallel = safe,
  sortop = operator (pg_catalog.>)
);

comment on aggregate pg_catalog.max(timestamp with time zone)
is 'maximum value of all timestamp with time zone input values';

create aggregate pg_catalog.max(interval) (
  sfunc = pg_catalog.interval_larger,
  stype = interval,
  combinefunc = pg_catalog.interval_larger,
  parallel = safe,
  sortop = operator (pg_catalog.>)
);

comment on aggregate pg_catalog.max(interval)
is 'maximum value of all interval input values';

create aggregate pg_catalog.max(text) (
  sfunc = pg_catalog.text_larger,
  stype = text,
  combinefunc = pg_catalog.text_larger,
  parallel = safe,
  sortop = operator (pg_catalog.>)
);

comment on aggregate pg_catalog.max(text)
is 'maximum value of all text input values';

create aggregate pg_catalog.max(numeric) (
  sfunc = pg_catalog.numeric_larger,
  stype = numeric,
  combinefunc = pg_catalog.numeric_larger,
  parallel = safe,
  sortop = operator (pg_catalog.>)
);

comment on aggregate pg_catalog.max(numeric)
is 'maximum value of all numeric input values';

create aggregate pg_catalog.min(bigint) (
  sfunc = pg_catalog.int8smaller,
  stype = bigint,
  combinefunc = pg_catalog.int8smaller,
  parallel = safe,
  sortop = operator (pg_catalog.<)
);

comment on aggregate pg_catalog.min(bigint)
is 'minimum value of all bigint input values';

create aggregate pg_catalog.min(integer) (
  sfunc = pg_catalog.int4smaller,
  stype = integer,
  combinefunc = pg_catalog.int4smaller,
  parallel = safe,
  sortop = operator (pg_catalog.<)
);

comment on aggregate pg_catalog.min(integer)
is 'minimum value of all integer input values';

create aggregate pg_catalog.min(smallint) (
  sfunc = pg_catalog.int2smaller,
  stype = smallint,
  combinefunc = pg_catalog.int2smaller,
  parallel = safe,
  sortop = operator (pg_catalog.<)
);

comment on aggregate pg_catalog.min(smallint)
is 'minimum value of all smallint input values';

create aggregate pg_catalog.min(oid) (
  sfunc = pg_catalog.oidsmaller,
  stype = oid,
  combinefunc = pg_catalog.oidsmaller,
  parallel = safe,
  sortop = operator (pg_catalog.<)
);

comment on aggregate pg_catalog.min(oid)
is 'minimum value of all oid input values';

create aggregate pg_catalog.min(real) (
  sfunc = pg_catalog.float4smaller,
  stype = real,
  combinefunc = pg_catalog.float4smaller,
  parallel = safe,
  sortop = operator (pg_catalog.<)
);

comment on aggregate pg_catalog.min(real)
is 'minimum value of all float4 input values';

create aggregate pg_catalog.min(double precision) (
  sfunc = pg_catalog.float8smaller,
  stype = double precision,
  combinefunc = pg_catalog.float8smaller,
  parallel = safe,
  sortop = operator (pg_catalog.<)
);

comment on aggregate pg_catalog.min(double precision)
is 'minimum value of all float8 input values';

create aggregate pg_catalog.min(abstime) (
  sfunc = pg_catalog.int4smaller,
  stype = abstime,
  combinefunc = pg_catalog.int4smaller,
  parallel = safe,
  sortop = operator (pg_catalog.<)
);

comment on aggregate pg_catalog.min(abstime)
is 'minimum value of all abstime input values';

create aggregate pg_catalog.min(date) (
  sfunc = pg_catalog.date_smaller,
  stype = date,
  combinefunc = pg_catalog.date_smaller,
  parallel = safe,
  sortop = operator (pg_catalog.<)
);

comment on aggregate pg_catalog.min(date)
is 'minimum value of all date input values';

create aggregate pg_catalog.min(time) (
  sfunc = pg_catalog.time_smaller,
  stype = time,
  combinefunc = pg_catalog.time_smaller,
  parallel = safe,
  sortop = operator (pg_catalog.<)
);

comment on aggregate pg_catalog.min(time)
is 'minimum value of all time input values';

create aggregate pg_catalog.min(time with time zone) (
  sfunc = pg_catalog.timetz_smaller,
  stype = time with time zone,
  combinefunc = pg_catalog.timetz_smaller,
  parallel = safe,
  sortop = operator (pg_catalog.<)
);

comment on aggregate pg_catalog.min(time with time zone)
is 'minimum value of all time with time zone input values';

create aggregate pg_catalog.min(money) (
  sfunc = pg_catalog.cashsmaller,
  stype = money,
  combinefunc = pg_catalog.cashsmaller,
  parallel = safe,
  sortop = operator (pg_catalog.<)
);

comment on aggregate pg_catalog.min(money)
is 'minimum value of all money input values';

create aggregate pg_catalog.min(timestamp) (
  sfunc = pg_catalog.timestamp_smaller,
  stype = timestamp,
  combinefunc = pg_catalog.timestamp_smaller,
  parallel = safe,
  sortop = operator (pg_catalog.<)
);

comment on aggregate pg_catalog.min(timestamp)
is 'minimum value of all timestamp input values';

create aggregate pg_catalog.min(timestamp with time zone) (
  sfunc = pg_catalog.timestamptz_smaller,
  stype = timestamp with time zone,
  combinefunc = pg_catalog.timestamptz_smaller,
  parallel = safe,
  sortop = operator (pg_catalog.<)
);

comment on aggregate pg_catalog.min(timestamp with time zone)
is 'minimum value of all timestamp with time zone input values';

create aggregate pg_catalog.min(interval) (
  sfunc = pg_catalog.interval_smaller,
  stype = interval,
  combinefunc = pg_catalog.interval_smaller,
  parallel = safe,
  sortop = operator (pg_catalog.<)
);

comment on aggregate pg_catalog.min(interval)
is 'minimum value of all interval input values';

create aggregate pg_catalog.min(text) (
  sfunc = pg_catalog.text_smaller,
  stype = text,
  combinefunc = pg_catalog.text_smaller,
  parallel = safe,
  sortop = operator (pg_catalog.<)
);

comment on aggregate pg_catalog.min(text)
is 'minimum value of all text values';

create aggregate pg_catalog.min(numeric) (
  sfunc = pg_catalog.numeric_smaller,
  stype = numeric,
  combinefunc = pg_catalog.numeric_smaller,
  parallel = safe,
  sortop = operator (pg_catalog.<)
);

comment on aggregate pg_catalog.min(numeric)
is 'minimum value of all numeric input values';

create aggregate pg_catalog.count("any") (
  sfunc = pg_catalog.int8inc_any,
  stype = bigint,
  combinefunc = pg_catalog.int8pl,
  initcond = '0',
  parallel = safe,
  msfunc = pg_catalog.int8inc_any,
  minvfunc = pg_catalog.int8dec_any,
  mstype = bigint,
  minitcond = '0'
);

comment on aggregate pg_catalog.count("any")
is 'number of input rows for which the input expression is not null';

create aggregate pg_catalog.variance(bigint) (
  sfunc = pg_catalog.int8_accum,
  stype = internal,
  sspace = 128,
  finalfunc = pg_catalog.numeric_var_samp,
  combinefunc = pg_catalog.numeric_combine,
  serialfunc = pg_catalog.numeric_serialize,
  deserialfunc = pg_catalog.numeric_deserialize,
  parallel = safe,
  msfunc = pg_catalog.int8_accum,
  minvfunc = pg_catalog.int8_accum_inv,
  mstype = internal,
  msspace = 128,
  mfinalfunc = pg_catalog.numeric_var_samp
);

comment on aggregate pg_catalog.variance(bigint)
is 'historical alias for var_samp';

create aggregate pg_catalog.variance(integer) (
  sfunc = pg_catalog.int4_accum,
  stype = internal,
  sspace = 48,
  finalfunc = pg_catalog.numeric_poly_var_samp,
  combinefunc = pg_catalog.numeric_poly_combine,
  serialfunc = pg_catalog.numeric_poly_serialize,
  deserialfunc = pg_catalog.numeric_poly_deserialize,
  parallel = safe,
  msfunc = pg_catalog.int4_accum,
  minvfunc = pg_catalog.int4_accum_inv,
  mstype = internal,
  msspace = 48,
  mfinalfunc = pg_catalog.numeric_poly_var_samp
);

comment on aggregate pg_catalog.variance(integer)
is 'historical alias for var_samp';

create aggregate pg_catalog.variance(smallint) (
  sfunc = pg_catalog.int2_accum,
  stype = internal,
  sspace = 48,
  finalfunc = pg_catalog.numeric_poly_var_samp,
  combinefunc = pg_catalog.numeric_poly_combine,
  serialfunc = pg_catalog.numeric_poly_serialize,
  deserialfunc = pg_catalog.numeric_poly_deserialize,
  parallel = safe,
  msfunc = pg_catalog.int2_accum,
  minvfunc = pg_catalog.int2_accum_inv,
  mstype = internal,
  msspace = 48,
  mfinalfunc = pg_catalog.numeric_poly_var_samp
);

comment on aggregate pg_catalog.variance(smallint)
is 'historical alias for var_samp';

create aggregate pg_catalog.variance(real) (
  sfunc = pg_catalog.float4_accum,
  stype = double precision [],
  finalfunc = pg_catalog.float8_var_samp,
  combinefunc = pg_catalog.float8_combine,
  initcond = '{0,0,0}',
  parallel = safe
);

comment on aggregate pg_catalog.variance(real)
is 'historical alias for var_samp';

create aggregate pg_catalog.variance(double precision) (
  sfunc = pg_catalog.float8_accum,
  stype = double precision [],
  finalfunc = pg_catalog.float8_var_samp,
  combinefunc = pg_catalog.float8_combine,
  initcond = '{0,0,0}',
  parallel = safe
);

comment on aggregate pg_catalog.variance(double precision)
is 'historical alias for var_samp';

create aggregate pg_catalog.variance(numeric) (
  sfunc = pg_catalog.numeric_accum,
  stype = internal,
  sspace = 128,
  finalfunc = pg_catalog.numeric_var_samp,
  combinefunc = pg_catalog.numeric_combine,
  serialfunc = pg_catalog.numeric_serialize,
  deserialfunc = pg_catalog.numeric_deserialize,
  parallel = safe,
  msfunc = pg_catalog.numeric_accum,
  minvfunc = pg_catalog.numeric_accum_inv,
  mstype = internal,
  msspace = 128,
  mfinalfunc = pg_catalog.numeric_var_samp
);

comment on aggregate pg_catalog.variance(numeric)
is 'historical alias for var_samp';

create aggregate pg_catalog.stddev(bigint) (
  sfunc = pg_catalog.int8_accum,
  stype = internal,
  sspace = 128,
  finalfunc = pg_catalog.numeric_stddev_samp,
  combinefunc = pg_catalog.numeric_combine,
  serialfunc = pg_catalog.numeric_serialize,
  deserialfunc = pg_catalog.numeric_deserialize,
  parallel = safe,
  msfunc = pg_catalog.int8_accum,
  minvfunc = pg_catalog.int8_accum_inv,
  mstype = internal,
  msspace = 128,
  mfinalfunc = pg_catalog.numeric_stddev_samp
);

comment on aggregate pg_catalog.stddev(bigint)
is 'historical alias for stddev_samp';

create aggregate pg_catalog.stddev(integer) (
  sfunc = pg_catalog.int4_accum,
  stype = internal,
  sspace = 48,
  finalfunc = pg_catalog.numeric_poly_stddev_samp,
  combinefunc = pg_catalog.numeric_poly_combine,
  serialfunc = pg_catalog.numeric_poly_serialize,
  deserialfunc = pg_catalog.numeric_poly_deserialize,
  parallel = safe,
  msfunc = pg_catalog.int4_accum,
  minvfunc = pg_catalog.int4_accum_inv,
  mstype = internal,
  msspace = 48,
  mfinalfunc = pg_catalog.numeric_poly_stddev_samp
);

comment on aggregate pg_catalog.stddev(integer)
is 'historical alias for stddev_samp';

create aggregate pg_catalog.stddev(smallint) (
  sfunc = pg_catalog.int2_accum,
  stype = internal,
  sspace = 48,
  finalfunc = pg_catalog.numeric_poly_stddev_samp,
  combinefunc = pg_catalog.numeric_poly_combine,
  serialfunc = pg_catalog.numeric_poly_serialize,
  deserialfunc = pg_catalog.numeric_poly_deserialize,
  parallel = safe,
  msfunc = pg_catalog.int2_accum,
  minvfunc = pg_catalog.int2_accum_inv,
  mstype = internal,
  msspace = 48,
  mfinalfunc = pg_catalog.numeric_poly_stddev_samp
);

comment on aggregate pg_catalog.stddev(smallint)
is 'historical alias for stddev_samp';

create aggregate pg_catalog.stddev(real) (
  sfunc = pg_catalog.float4_accum,
  stype = double precision [],
  finalfunc = pg_catalog.float8_stddev_samp,
  combinefunc = pg_catalog.float8_combine,
  initcond = '{0,0,0}',
  parallel = safe
);

comment on aggregate pg_catalog.stddev(real)
is 'historical alias for stddev_samp';

create aggregate pg_catalog.stddev(double precision) (
  sfunc = pg_catalog.float8_accum,
  stype = double precision [],
  finalfunc = pg_catalog.float8_stddev_samp,
  combinefunc = pg_catalog.float8_combine,
  initcond = '{0,0,0}',
  parallel = safe
);

comment on aggregate pg_catalog.stddev(double precision)
is 'historical alias for stddev_samp';

create aggregate pg_catalog.stddev(numeric) (
  sfunc = pg_catalog.numeric_accum,
  stype = internal,
  sspace = 128,
  finalfunc = pg_catalog.numeric_stddev_samp,
  combinefunc = pg_catalog.numeric_combine,
  serialfunc = pg_catalog.numeric_serialize,
  deserialfunc = pg_catalog.numeric_deserialize,
  parallel = safe,
  msfunc = pg_catalog.numeric_accum,
  minvfunc = pg_catalog.numeric_accum_inv,
  mstype = internal,
  msspace = 128,
  mfinalfunc = pg_catalog.numeric_stddev_samp
);

comment on aggregate pg_catalog.stddev(numeric)
is 'historical alias for stddev_samp';

create aggregate pg_catalog.bit_and(smallint) (
  sfunc = pg_catalog.int2and,
  stype = smallint,
  combinefunc = pg_catalog.int2and,
  parallel = safe
);

comment on aggregate pg_catalog.bit_and(smallint)
is 'bitwise-and smallint aggregate';

create aggregate pg_catalog.bit_or(smallint) (
  sfunc = pg_catalog.int2or,
  stype = smallint,
  combinefunc = pg_catalog.int2or,
  parallel = safe
);

comment on aggregate pg_catalog.bit_or(smallint)
is 'bitwise-or smallint aggregate';

create aggregate pg_catalog.bit_and(integer) (
  sfunc = pg_catalog.int4and,
  stype = integer,
  combinefunc = pg_catalog.int4and,
  parallel = safe
);

comment on aggregate pg_catalog.bit_and(integer)
is 'bitwise-and integer aggregate';

create aggregate pg_catalog.bit_or(integer) (
  sfunc = pg_catalog.int4or,
  stype = integer,
  combinefunc = pg_catalog.int4or,
  parallel = safe
);

comment on aggregate pg_catalog.bit_or(integer)
is 'bitwise-or integer aggregate';

create aggregate pg_catalog.bit_and(bigint) (
  sfunc = pg_catalog.int8and,
  stype = bigint,
  combinefunc = pg_catalog.int8and,
  parallel = safe
);

comment on aggregate pg_catalog.bit_and(bigint)
is 'bitwise-and bigint aggregate';

create aggregate pg_catalog.bit_or(bigint) (
  sfunc = pg_catalog.int8or,
  stype = bigint,
  combinefunc = pg_catalog.int8or,
  parallel = safe
);

comment on aggregate pg_catalog.bit_or(bigint)
is 'bitwise-or bigint aggregate';

create aggregate pg_catalog.bit_and(bit) (
  sfunc = pg_catalog.bitand,
  stype = bit,
  combinefunc = pg_catalog.bitand,
  parallel = safe
);

comment on aggregate pg_catalog.bit_and(bit)
is 'bitwise-and bit aggregate';

create aggregate pg_catalog.bit_or(bit) (
  sfunc = pg_catalog.bitor,
  stype = bit,
  combinefunc = pg_catalog.bitor,
  parallel = safe
);

comment on aggregate pg_catalog.bit_or(bit)
is 'bitwise-or bit aggregate';

create aggregate pg_catalog.max(char) (
  sfunc = pg_catalog.bpchar_larger,
  stype = char,
  combinefunc = pg_catalog.bpchar_larger,
  parallel = safe,
  sortop = operator (pg_catalog.>)
);

comment on aggregate pg_catalog.max(char)
is 'maximum value of all bpchar input values';

create aggregate pg_catalog.min(char) (
  sfunc = pg_catalog.bpchar_smaller,
  stype = char,
  combinefunc = pg_catalog.bpchar_smaller,
  parallel = safe,
  sortop = operator (pg_catalog.<)
);

comment on aggregate pg_catalog.min(char)
is 'minimum value of all bpchar input values';

create aggregate pg_catalog.array_agg(anynonarray) (
  sfunc = pg_catalog.array_agg_transfn,
  stype = internal,
  finalfunc = pg_catalog.array_agg_finalfn,
  finalfunc_extra,
  parallel = safe
);

comment on aggregate pg_catalog.array_agg(anynonarray)
is 'concatenate aggregate input into an array';

create aggregate pg_catalog.bool_and(boolean) (
  sfunc = pg_catalog.booland_statefunc,
  stype = boolean,
  combinefunc = pg_catalog.booland_statefunc,
  parallel = safe,
  msfunc = pg_catalog.bool_accum,
  minvfunc = pg_catalog.bool_accum_inv,
  mstype = internal,
  msspace = 16,
  mfinalfunc = pg_catalog.bool_alltrue,
  sortop = operator (pg_catalog.<)
);

comment on aggregate pg_catalog.bool_and(boolean)
is 'boolean-and aggregate';

create aggregate pg_catalog.bool_or(boolean) (
  sfunc = pg_catalog.boolor_statefunc,
  stype = boolean,
  combinefunc = pg_catalog.boolor_statefunc,
  parallel = safe,
  msfunc = pg_catalog.bool_accum,
  minvfunc = pg_catalog.bool_accum_inv,
  mstype = internal,
  msspace = 16,
  mfinalfunc = pg_catalog.bool_anytrue,
  sortop = operator (pg_catalog.>)
);

comment on aggregate pg_catalog.bool_or(boolean)
is 'boolean-or aggregate';

create aggregate pg_catalog.every(boolean) (
  sfunc = pg_catalog.booland_statefunc,
  stype = boolean,
  combinefunc = pg_catalog.booland_statefunc,
  parallel = safe,
  msfunc = pg_catalog.bool_accum,
  minvfunc = pg_catalog.bool_accum_inv,
  mstype = internal,
  msspace = 16,
  mfinalfunc = pg_catalog.bool_alltrue,
  sortop = operator (pg_catalog.<)
);

comment on aggregate pg_catalog.every(boolean)
is 'boolean-and aggregate';

create aggregate pg_catalog.var_samp(bigint) (
  sfunc = pg_catalog.int8_accum,
  stype = internal,
  sspace = 128,
  finalfunc = pg_catalog.numeric_var_samp,
  combinefunc = pg_catalog.numeric_combine,
  serialfunc = pg_catalog.numeric_serialize,
  deserialfunc = pg_catalog.numeric_deserialize,
  parallel = safe,
  msfunc = pg_catalog.int8_accum,
  minvfunc = pg_catalog.int8_accum_inv,
  mstype = internal,
  msspace = 128,
  mfinalfunc = pg_catalog.numeric_var_samp
);

comment on aggregate pg_catalog.var_samp(bigint)
is 'sample variance of bigint input values (square of the sample standard deviation)';

create aggregate pg_catalog.var_samp(integer) (
  sfunc = pg_catalog.int4_accum,
  stype = internal,
  sspace = 48,
  finalfunc = pg_catalog.numeric_poly_var_samp,
  combinefunc = pg_catalog.numeric_poly_combine,
  serialfunc = pg_catalog.numeric_poly_serialize,
  deserialfunc = pg_catalog.numeric_poly_deserialize,
  parallel = safe,
  msfunc = pg_catalog.int4_accum,
  minvfunc = pg_catalog.int4_accum_inv,
  mstype = internal,
  msspace = 48,
  mfinalfunc = pg_catalog.numeric_poly_var_samp
);

comment on aggregate pg_catalog.var_samp(integer)
is 'sample variance of integer input values (square of the sample standard deviation)';

create aggregate pg_catalog.var_samp(smallint) (
  sfunc = pg_catalog.int2_accum,
  stype = internal,
  sspace = 48,
  finalfunc = pg_catalog.numeric_poly_var_samp,
  combinefunc = pg_catalog.numeric_poly_combine,
  serialfunc = pg_catalog.numeric_poly_serialize,
  deserialfunc = pg_catalog.numeric_poly_deserialize,
  parallel = safe,
  msfunc = pg_catalog.int2_accum,
  minvfunc = pg_catalog.int2_accum_inv,
  mstype = internal,
  msspace = 48,
  mfinalfunc = pg_catalog.numeric_poly_var_samp
);

comment on aggregate pg_catalog.var_samp(smallint)
is 'sample variance of smallint input values (square of the sample standard deviation)';

create aggregate pg_catalog.var_samp(real) (
  sfunc = pg_catalog.float4_accum,
  stype = double precision [],
  finalfunc = pg_catalog.float8_var_samp,
  combinefunc = pg_catalog.float8_combine,
  initcond = '{0,0,0}',
  parallel = safe
);

comment on aggregate pg_catalog.var_samp(real)
is 'sample variance of float4 input values (square of the sample standard deviation)';

create aggregate pg_catalog.var_samp(double precision) (
  sfunc = pg_catalog.float8_accum,
  stype = double precision [],
  finalfunc = pg_catalog.float8_var_samp,
  combinefunc = pg_catalog.float8_combine,
  initcond = '{0,0,0}',
  parallel = safe
);

comment on aggregate pg_catalog.var_samp(double precision)
is 'sample variance of float8 input values (square of the sample standard deviation)';

create aggregate pg_catalog.var_samp(numeric) (
  sfunc = pg_catalog.numeric_accum,
  stype = internal,
  sspace = 128,
  finalfunc = pg_catalog.numeric_var_samp,
  combinefunc = pg_catalog.numeric_combine,
  serialfunc = pg_catalog.numeric_serialize,
  deserialfunc = pg_catalog.numeric_deserialize,
  parallel = safe,
  msfunc = pg_catalog.numeric_accum,
  minvfunc = pg_catalog.numeric_accum_inv,
  mstype = internal,
  msspace = 128,
  mfinalfunc = pg_catalog.numeric_var_samp
);

comment on aggregate pg_catalog.var_samp(numeric)
is 'sample variance of numeric input values (square of the sample standard deviation)';

create aggregate pg_catalog.stddev_samp(bigint) (
  sfunc = pg_catalog.int8_accum,
  stype = internal,
  sspace = 128,
  finalfunc = pg_catalog.numeric_stddev_samp,
  combinefunc = pg_catalog.numeric_combine,
  serialfunc = pg_catalog.numeric_serialize,
  deserialfunc = pg_catalog.numeric_deserialize,
  parallel = safe,
  msfunc = pg_catalog.int8_accum,
  minvfunc = pg_catalog.int8_accum_inv,
  mstype = internal,
  msspace = 128,
  mfinalfunc = pg_catalog.numeric_stddev_samp
);

comment on aggregate pg_catalog.stddev_samp(bigint)
is 'sample standard deviation of bigint input values';

create aggregate pg_catalog.stddev_samp(integer) (
  sfunc = pg_catalog.int4_accum,
  stype = internal,
  sspace = 48,
  finalfunc = pg_catalog.numeric_poly_stddev_samp,
  combinefunc = pg_catalog.numeric_poly_combine,
  serialfunc = pg_catalog.numeric_poly_serialize,
  deserialfunc = pg_catalog.numeric_poly_deserialize,
  parallel = safe,
  msfunc = pg_catalog.int4_accum,
  minvfunc = pg_catalog.int4_accum_inv,
  mstype = internal,
  msspace = 48,
  mfinalfunc = pg_catalog.numeric_poly_stddev_samp
);

comment on aggregate pg_catalog.stddev_samp(integer)
is 'sample standard deviation of integer input values';

create aggregate pg_catalog.stddev_samp(smallint) (
  sfunc = pg_catalog.int2_accum,
  stype = internal,
  sspace = 48,
  finalfunc = pg_catalog.numeric_poly_stddev_samp,
  combinefunc = pg_catalog.numeric_poly_combine,
  serialfunc = pg_catalog.numeric_poly_serialize,
  deserialfunc = pg_catalog.numeric_poly_deserialize,
  parallel = safe,
  msfunc = pg_catalog.int2_accum,
  minvfunc = pg_catalog.int2_accum_inv,
  mstype = internal,
  msspace = 48,
  mfinalfunc = pg_catalog.numeric_poly_stddev_samp
);

comment on aggregate pg_catalog.stddev_samp(smallint)
is 'sample standard deviation of smallint input values';

create aggregate pg_catalog.stddev_samp(real) (
  sfunc = pg_catalog.float4_accum,
  stype = double precision [],
  finalfunc = pg_catalog.float8_stddev_samp,
  combinefunc = pg_catalog.float8_combine,
  initcond = '{0,0,0}',
  parallel = safe
);

comment on aggregate pg_catalog.stddev_samp(real)
is 'sample standard deviation of float4 input values';

create aggregate pg_catalog.stddev_samp(double precision) (
  sfunc = pg_catalog.float8_accum,
  stype = double precision [],
  finalfunc = pg_catalog.float8_stddev_samp,
  combinefunc = pg_catalog.float8_combine,
  initcond = '{0,0,0}',
  parallel = safe
);

comment on aggregate pg_catalog.stddev_samp(double precision)
is 'sample standard deviation of float8 input values';

create aggregate pg_catalog.stddev_samp(numeric) (
  sfunc = pg_catalog.numeric_accum,
  stype = internal,
  sspace = 128,
  finalfunc = pg_catalog.numeric_stddev_samp,
  combinefunc = pg_catalog.numeric_combine,
  serialfunc = pg_catalog.numeric_serialize,
  deserialfunc = pg_catalog.numeric_deserialize,
  parallel = safe,
  msfunc = pg_catalog.numeric_accum,
  minvfunc = pg_catalog.numeric_accum_inv,
  mstype = internal,
  msspace = 128,
  mfinalfunc = pg_catalog.numeric_stddev_samp
);

comment on aggregate pg_catalog.stddev_samp(numeric)
is 'sample standard deviation of numeric input values';

create aggregate pg_catalog.var_pop(bigint) (
  sfunc = pg_catalog.int8_accum,
  stype = internal,
  sspace = 128,
  finalfunc = pg_catalog.numeric_var_pop,
  combinefunc = pg_catalog.numeric_combine,
  serialfunc = pg_catalog.numeric_serialize,
  deserialfunc = pg_catalog.numeric_deserialize,
  parallel = safe,
  msfunc = pg_catalog.int8_accum,
  minvfunc = pg_catalog.int8_accum_inv,
  mstype = internal,
  msspace = 128,
  mfinalfunc = pg_catalog.numeric_var_pop
);

comment on aggregate pg_catalog.var_pop(bigint)
is 'population variance of bigint input values (square of the population standard deviation)';

create aggregate pg_catalog.var_pop(integer) (
  sfunc = pg_catalog.int4_accum,
  stype = internal,
  sspace = 48,
  finalfunc = pg_catalog.numeric_poly_var_pop,
  combinefunc = pg_catalog.numeric_poly_combine,
  serialfunc = pg_catalog.numeric_poly_serialize,
  deserialfunc = pg_catalog.numeric_poly_deserialize,
  parallel = safe,
  msfunc = pg_catalog.int4_accum,
  minvfunc = pg_catalog.int4_accum_inv,
  mstype = internal,
  msspace = 48,
  mfinalfunc = pg_catalog.numeric_poly_var_pop
);

comment on aggregate pg_catalog.var_pop(integer)
is 'population variance of integer input values (square of the population standard deviation)';

create aggregate pg_catalog.var_pop(smallint) (
  sfunc = pg_catalog.int2_accum,
  stype = internal,
  sspace = 48,
  finalfunc = pg_catalog.numeric_poly_var_pop,
  combinefunc = pg_catalog.numeric_poly_combine,
  serialfunc = pg_catalog.numeric_poly_serialize,
  deserialfunc = pg_catalog.numeric_poly_deserialize,
  parallel = safe,
  msfunc = pg_catalog.int2_accum,
  minvfunc = pg_catalog.int2_accum_inv,
  mstype = internal,
  msspace = 48,
  mfinalfunc = pg_catalog.numeric_poly_var_pop
);

comment on aggregate pg_catalog.var_pop(smallint)
is 'population variance of smallint input values (square of the population standard deviation)';

create aggregate pg_catalog.var_pop(real) (
  sfunc = pg_catalog.float4_accum,
  stype = double precision [],
  finalfunc = pg_catalog.float8_var_pop,
  combinefunc = pg_catalog.float8_combine,
  initcond = '{0,0,0}',
  parallel = safe
);

comment on aggregate pg_catalog.var_pop(real)
is 'population variance of float4 input values (square of the population standard deviation)';

create aggregate pg_catalog.var_pop(double precision) (
  sfunc = pg_catalog.float8_accum,
  stype = double precision [],
  finalfunc = pg_catalog.float8_var_pop,
  combinefunc = pg_catalog.float8_combine,
  initcond = '{0,0,0}',
  parallel = safe
);

comment on aggregate pg_catalog.var_pop(double precision)
is 'population variance of float8 input values (square of the population standard deviation)';

create aggregate pg_catalog.var_pop(numeric) (
  sfunc = pg_catalog.numeric_accum,
  stype = internal,
  sspace = 128,
  finalfunc = pg_catalog.numeric_var_pop,
  combinefunc = pg_catalog.numeric_combine,
  serialfunc = pg_catalog.numeric_serialize,
  deserialfunc = pg_catalog.numeric_deserialize,
  parallel = safe,
  msfunc = pg_catalog.numeric_accum,
  minvfunc = pg_catalog.numeric_accum_inv,
  mstype = internal,
  msspace = 128,
  mfinalfunc = pg_catalog.numeric_var_pop
);

comment on aggregate pg_catalog.var_pop(numeric)
is 'population variance of numeric input values (square of the population standard deviation)';

create aggregate pg_catalog.stddev_pop(bigint) (
  sfunc = pg_catalog.int8_accum,
  stype = internal,
  sspace = 128,
  finalfunc = pg_catalog.numeric_stddev_pop,
  combinefunc = pg_catalog.numeric_combine,
  serialfunc = pg_catalog.numeric_serialize,
  deserialfunc = pg_catalog.numeric_deserialize,
  parallel = safe,
  msfunc = pg_catalog.int8_accum,
  minvfunc = pg_catalog.int8_accum_inv,
  mstype = internal,
  msspace = 128,
  mfinalfunc = pg_catalog.numeric_stddev_pop
);

comment on aggregate pg_catalog.stddev_pop(bigint)
is 'population standard deviation of bigint input values';

create aggregate pg_catalog.stddev_pop(integer) (
  sfunc = pg_catalog.int4_accum,
  stype = internal,
  sspace = 48,
  finalfunc = pg_catalog.numeric_poly_stddev_pop,
  combinefunc = pg_catalog.numeric_poly_combine,
  serialfunc = pg_catalog.numeric_poly_serialize,
  deserialfunc = pg_catalog.numeric_poly_deserialize,
  parallel = safe,
  msfunc = pg_catalog.int4_accum,
  minvfunc = pg_catalog.int4_accum_inv,
  mstype = internal,
  msspace = 48,
  mfinalfunc = pg_catalog.numeric_poly_stddev_pop
);

comment on aggregate pg_catalog.stddev_pop(integer)
is 'population standard deviation of integer input values';

create aggregate pg_catalog.stddev_pop(smallint) (
  sfunc = pg_catalog.int2_accum,
  stype = internal,
  sspace = 48,
  finalfunc = pg_catalog.numeric_poly_stddev_pop,
  combinefunc = pg_catalog.numeric_poly_combine,
  serialfunc = pg_catalog.numeric_poly_serialize,
  deserialfunc = pg_catalog.numeric_poly_deserialize,
  parallel = safe,
  msfunc = pg_catalog.int2_accum,
  minvfunc = pg_catalog.int2_accum_inv,
  mstype = internal,
  msspace = 48,
  mfinalfunc = pg_catalog.numeric_poly_stddev_pop
);

comment on aggregate pg_catalog.stddev_pop(smallint)
is 'population standard deviation of smallint input values';

create aggregate pg_catalog.stddev_pop(real) (
  sfunc = pg_catalog.float4_accum,
  stype = double precision [],
  finalfunc = pg_catalog.float8_stddev_pop,
  combinefunc = pg_catalog.float8_combine,
  initcond = '{0,0,0}',
  parallel = safe
);

comment on aggregate pg_catalog.stddev_pop(real)
is 'population standard deviation of float4 input values';

create aggregate pg_catalog.stddev_pop(double precision) (
  sfunc = pg_catalog.float8_accum,
  stype = double precision [],
  finalfunc = pg_catalog.float8_stddev_pop,
  combinefunc = pg_catalog.float8_combine,
  initcond = '{0,0,0}',
  parallel = safe
);

comment on aggregate pg_catalog.stddev_pop(double precision)
is 'population standard deviation of float8 input values';

create aggregate pg_catalog.stddev_pop(numeric) (
  sfunc = pg_catalog.numeric_accum,
  stype = internal,
  sspace = 128,
  finalfunc = pg_catalog.numeric_stddev_pop,
  combinefunc = pg_catalog.numeric_combine,
  serialfunc = pg_catalog.numeric_serialize,
  deserialfunc = pg_catalog.numeric_deserialize,
  parallel = safe,
  msfunc = pg_catalog.numeric_accum,
  minvfunc = pg_catalog.numeric_accum_inv,
  mstype = internal,
  msspace = 128,
  mfinalfunc = pg_catalog.numeric_stddev_pop
);

comment on aggregate pg_catalog.stddev_pop(numeric)
is 'population standard deviation of numeric input values';

create aggregate pg_catalog.max(tid) (
  sfunc = pg_catalog.tidlarger,
  stype = tid,
  combinefunc = pg_catalog.tidlarger,
  parallel = safe,
  sortop = operator (pg_catalog.>)
);

comment on aggregate pg_catalog.max(tid)
is 'maximum value of all tid input values';

create aggregate pg_catalog.min(tid) (
  sfunc = pg_catalog.tidsmaller,
  stype = tid,
  combinefunc = pg_catalog.tidsmaller,
  parallel = safe,
  sortop = operator (pg_catalog.<)
);

comment on aggregate pg_catalog.min(tid)
is 'minimum value of all tid input values';

create aggregate pg_catalog.count() (
  sfunc = pg_catalog.int8inc,
  stype = bigint,
  combinefunc = pg_catalog.int8pl,
  initcond = '0',
  parallel = safe,
  msfunc = pg_catalog.int8inc,
  minvfunc = pg_catalog.int8dec,
  mstype = bigint,
  minitcond = '0'
);

comment on aggregate pg_catalog.count()
is 'number of input rows';

create aggregate pg_catalog.regr_count(double precision, double precision) (
  sfunc = pg_catalog.int8inc_float8_float8,
  stype = bigint,
  combinefunc = pg_catalog.int8pl,
  initcond = '0',
  parallel = safe
);

comment on aggregate pg_catalog.regr_count(double precision, double precision)
is 'number of input rows in which both expressions are not null';

create aggregate pg_catalog.regr_sxx(double precision, double precision) (
  sfunc = pg_catalog.float8_regr_accum,
  stype = double precision [],
  finalfunc = pg_catalog.float8_regr_sxx,
  combinefunc = pg_catalog.float8_regr_combine,
  initcond = '{0,0,0,0,0,0}',
  parallel = safe
);

comment on aggregate pg_catalog.regr_sxx(double precision, double precision)
is 'sum of squares of the independent variable (sum(X^2) - sum(X)^2/N)';

create aggregate pg_catalog.regr_syy(double precision, double precision) (
  sfunc = pg_catalog.float8_regr_accum,
  stype = double precision [],
  finalfunc = pg_catalog.float8_regr_syy,
  combinefunc = pg_catalog.float8_regr_combine,
  initcond = '{0,0,0,0,0,0}',
  parallel = safe
);

comment on aggregate pg_catalog.regr_syy(double precision, double precision)
is 'sum of squares of the dependent variable (sum(Y^2) - sum(Y)^2/N)';

create aggregate pg_catalog.regr_sxy(double precision, double precision) (
  sfunc = pg_catalog.float8_regr_accum,
  stype = double precision [],
  finalfunc = pg_catalog.float8_regr_sxy,
  combinefunc = pg_catalog.float8_regr_combine,
  initcond = '{0,0,0,0,0,0}',
  parallel = safe
);

comment on aggregate pg_catalog.regr_sxy(double precision, double precision)
is 'sum of products of independent times dependent variable (sum(X*Y) - sum(X) * sum(Y)/N)';

create aggregate pg_catalog.regr_avgx(double precision, double precision) (
  sfunc = pg_catalog.float8_regr_accum,
  stype = double precision [],
  finalfunc = pg_catalog.float8_regr_avgx,
  combinefunc = pg_catalog.float8_regr_combine,
  initcond = '{0,0,0,0,0,0}',
  parallel = safe
);

comment on aggregate pg_catalog.regr_avgx(double precision, double precision)
is 'average of the independent variable (sum(X)/N)';

create aggregate pg_catalog.regr_avgy(double precision, double precision) (
  sfunc = pg_catalog.float8_regr_accum,
  stype = double precision [],
  finalfunc = pg_catalog.float8_regr_avgy,
  combinefunc = pg_catalog.float8_regr_combine,
  initcond = '{0,0,0,0,0,0}',
  parallel = safe
);

comment on aggregate pg_catalog.regr_avgy(double precision, double precision)
is 'average of the dependent variable (sum(Y)/N)';

create aggregate pg_catalog.regr_r2(double precision, double precision) (
  sfunc = pg_catalog.float8_regr_accum,
  stype = double precision [],
  finalfunc = pg_catalog.float8_regr_r2,
  combinefunc = pg_catalog.float8_regr_combine,
  initcond = '{0,0,0,0,0,0}',
  parallel = safe
);

comment on aggregate pg_catalog.regr_r2(double precision, double precision)
is 'square of the correlation coefficient';

create aggregate pg_catalog.regr_slope(double precision, double precision) (
  sfunc = pg_catalog.float8_regr_accum,
  stype = double precision [],
  finalfunc = pg_catalog.float8_regr_slope,
  combinefunc = pg_catalog.float8_regr_combine,
  initcond = '{0,0,0,0,0,0}',
  parallel = safe
);

comment on aggregate pg_catalog.regr_slope(double precision, double precision)
is 'slope of the least-squares-fit linear equation determined by the (X, Y) pairs';

create aggregate pg_catalog.regr_intercept(double precision, double precision) (
  sfunc = pg_catalog.float8_regr_accum,
  stype = double precision [],
  finalfunc = pg_catalog.float8_regr_intercept,
  combinefunc = pg_catalog.float8_regr_combine,
  initcond = '{0,0,0,0,0,0}',
  parallel = safe
);

comment on aggregate pg_catalog.regr_intercept(double precision, double precision)
is 'y-intercept of the least-squares-fit linear equation determined by the (X, Y) pairs';

create aggregate pg_catalog.covar_pop(double precision, double precision) (
  sfunc = pg_catalog.float8_regr_accum,
  stype = double precision [],
  finalfunc = pg_catalog.float8_covar_pop,
  combinefunc = pg_catalog.float8_regr_combine,
  initcond = '{0,0,0,0,0,0}',
  parallel = safe
);

comment on aggregate pg_catalog.covar_pop(double precision, double precision)
is 'population covariance';

create aggregate pg_catalog.covar_samp(double precision, double precision) (
  sfunc = pg_catalog.float8_regr_accum,
  stype = double precision [],
  finalfunc = pg_catalog.float8_covar_samp,
  combinefunc = pg_catalog.float8_regr_combine,
  initcond = '{0,0,0,0,0,0}',
  parallel = safe
);

comment on aggregate pg_catalog.covar_samp(double precision, double precision)
is 'sample covariance';

create aggregate pg_catalog.corr(double precision, double precision) (
  sfunc = pg_catalog.float8_regr_accum,
  stype = double precision [],
  finalfunc = pg_catalog.float8_corr,
  combinefunc = pg_catalog.float8_regr_combine,
  initcond = '{0,0,0,0,0,0}',
  parallel = safe
);

comment on aggregate pg_catalog.corr(double precision, double precision)
is 'correlation coefficient';

create aggregate pg_catalog.xmlagg(xml) (
  sfunc = pg_catalog.xmlconcat2,
  stype = xml,
  parallel = safe
);

comment on aggregate pg_catalog.xmlagg(xml)
is 'concatenate XML values';

create aggregate pg_catalog.json_agg(anyelement) (
  sfunc = pg_catalog.json_agg_transfn,
  stype = internal,
  finalfunc = pg_catalog.json_agg_finalfn,
  parallel = safe
);

comment on aggregate pg_catalog.json_agg(anyelement)
is 'aggregate input into json';

create aggregate pg_catalog.json_object_agg("any", "any") (
  sfunc = pg_catalog.json_object_agg_transfn,
  stype = internal,
  finalfunc = pg_catalog.json_object_agg_finalfn,
  parallel = safe
);

comment on aggregate pg_catalog.json_object_agg("any", "any")
is 'aggregate input into a json object';

create aggregate pg_catalog.jsonb_agg(anyelement) (
  sfunc = pg_catalog.jsonb_agg_transfn,
  stype = internal,
  finalfunc = pg_catalog.jsonb_agg_finalfn,
  parallel = safe
);

comment on aggregate pg_catalog.jsonb_agg(anyelement)
is 'aggregate input into jsonb';

create aggregate pg_catalog.jsonb_object_agg("any", "any") (
  sfunc = pg_catalog.jsonb_object_agg_transfn,
  stype = internal,
  finalfunc = pg_catalog.jsonb_object_agg_finalfn,
  parallel = safe
);

comment on aggregate pg_catalog.jsonb_object_agg("any", "any")
is 'aggregate inputs into jsonb object';

create aggregate pg_catalog.max(anyenum) (
  sfunc = pg_catalog.enum_larger,
  stype = anyenum,
  combinefunc = pg_catalog.enum_larger,
  parallel = safe,
  sortop = operator (pg_catalog.>)
);

comment on aggregate pg_catalog.max(anyenum)
is 'maximum value of all enum input values';

create aggregate pg_catalog.min(anyenum) (
  sfunc = pg_catalog.enum_smaller,
  stype = anyenum,
  combinefunc = pg_catalog.enum_smaller,
  parallel = safe,
  sortop = operator (pg_catalog.<)
);

comment on aggregate pg_catalog.min(anyenum)
is 'minimum value of all enum input values';

create aggregate pg_catalog.string_agg(text, text) (
  sfunc = pg_catalog.string_agg_transfn,
  stype = internal,
  finalfunc = pg_catalog.string_agg_finalfn,
  parallel = safe
);

comment on aggregate pg_catalog.string_agg(text, text)
is 'concatenate aggregate input into a string';

create aggregate pg_catalog.string_agg(bytea, bytea) (
  sfunc = pg_catalog.bytea_string_agg_transfn,
  stype = internal,
  finalfunc = pg_catalog.bytea_string_agg_finalfn,
  parallel = safe
);

comment on aggregate pg_catalog.string_agg(bytea, bytea)
is 'concatenate aggregate input into a bytea';

create aggregate pg_catalog.max(inet) (
  sfunc = pg_catalog.network_larger,
  stype = inet,
  combinefunc = pg_catalog.network_larger,
  parallel = safe,
  sortop = operator (pg_catalog.>)
);

comment on aggregate pg_catalog.max(inet)
is 'maximum value of all inet input values';

create aggregate pg_catalog.min(inet) (
  sfunc = pg_catalog.network_smaller,
  stype = inet,
  combinefunc = pg_catalog.network_smaller,
  parallel = safe,
  sortop = operator (pg_catalog.<)
);

comment on aggregate pg_catalog.min(inet)
is 'minimum value of all inet input values';

create aggregate pg_catalog.percentile_disc(double precision order by anyelement) (
  sfunc = pg_catalog.ordered_set_transition,
  stype = internal,
  finalfunc = pg_catalog.percentile_disc_final,
  finalfunc_extra,
  parallel = safe
);

comment on aggregate pg_catalog.percentile_disc(double precision, anyelement)
is 'discrete percentile';

create aggregate pg_catalog.percentile_cont(double precision order by double precision) (
  sfunc = pg_catalog.ordered_set_transition,
  stype = internal,
  finalfunc = pg_catalog.percentile_cont_float8_final,
  parallel = safe
);

comment on aggregate pg_catalog.percentile_cont(double precision, double precision)
is 'continuous distribution percentile';

create aggregate pg_catalog.percentile_cont(double precision order by interval) (
  sfunc = pg_catalog.ordered_set_transition,
  stype = internal,
  finalfunc = pg_catalog.percentile_cont_interval_final,
  parallel = safe
);

comment on aggregate pg_catalog.percentile_cont(double precision, interval)
is 'continuous distribution percentile';

create aggregate pg_catalog.percentile_disc(double precision [] order by anyelement) (
  sfunc = pg_catalog.ordered_set_transition,
  stype = internal,
  finalfunc = pg_catalog.percentile_disc_multi_final,
  finalfunc_extra,
  parallel = safe
);

comment on aggregate pg_catalog.percentile_disc(double precision [], anyelement)
is 'multiple discrete percentiles';

create aggregate pg_catalog.percentile_cont(double precision [] order by double precision) (
  sfunc = pg_catalog.ordered_set_transition,
  stype = internal,
  finalfunc = pg_catalog.percentile_cont_float8_multi_final,
  parallel = safe
);

comment on aggregate pg_catalog.percentile_cont(double precision [], double precision)
is 'multiple continuous percentiles';

create aggregate pg_catalog.percentile_cont(double precision [] order by interval) (
  sfunc = pg_catalog.ordered_set_transition,
  stype = internal,
  finalfunc = pg_catalog.percentile_cont_interval_multi_final,
  parallel = safe
);

comment on aggregate pg_catalog.percentile_cont(double precision [], interval)
is 'multiple continuous percentiles';

create aggregate pg_catalog.mode(order by anyelement) (
  sfunc = pg_catalog.ordered_set_transition,
  stype = internal,
  finalfunc = pg_catalog.mode_final,
  finalfunc_extra,
  parallel = safe
);

comment on aggregate pg_catalog.mode(anyelement)
is 'most common value';

create aggregate pg_catalog.rank("any") (
  sfunc = pg_catalog.ordered_set_transition_multi,
  stype = internal,
  finalfunc = pg_catalog.rank_final,
  finalfunc_extra,
  parallel = safe,
  hypothetical
);

comment on aggregate pg_catalog.rank("any")
is 'rank of hypothetical row';

create aggregate pg_catalog.percent_rank("any") (
  sfunc = pg_catalog.ordered_set_transition_multi,
  stype = internal,
  finalfunc = pg_catalog.percent_rank_final,
  finalfunc_extra,
  parallel = safe,
  hypothetical
);

comment on aggregate pg_catalog.percent_rank("any")
is 'fractional rank of hypothetical row';

create aggregate pg_catalog.cume_dist("any") (
  sfunc = pg_catalog.ordered_set_transition_multi,
  stype = internal,
  finalfunc = pg_catalog.cume_dist_final,
  finalfunc_extra,
  parallel = safe,
  hypothetical
);

comment on aggregate pg_catalog.cume_dist("any")
is 'cumulative distribution of hypothetical row';

create aggregate pg_catalog.dense_rank("any") (
  sfunc = pg_catalog.ordered_set_transition_multi,
  stype = internal,
  finalfunc = pg_catalog.dense_rank_final,
  finalfunc_extra,
  parallel = safe,
  hypothetical
);

comment on aggregate pg_catalog.dense_rank("any")
is 'rank of hypothetical row without gaps';

create aggregate pg_catalog.array_agg(anyarray) (
  sfunc = pg_catalog.array_agg_array_transfn,
  stype = internal,
  finalfunc = pg_catalog.array_agg_array_finalfn,
  finalfunc_extra,
  parallel = safe
);

comment on aggregate pg_catalog.array_agg(anyarray)
is 'concatenate aggregate input into an array';


